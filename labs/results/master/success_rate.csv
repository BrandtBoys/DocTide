Success,Comment
True,"""""""
Returns the value of the requested attribute, or raises an AttributeError if it does not exist.

The function is used to handle special attributes that are deprecated and will be removed in future versions of Flask.
It provides a way to access these attributes while still raising a warning about their deprecation.

Attributes:
    - `_app_ctx_stack`: The application context stack. (Deprecated)
    - `_request_ctx_stack`: The request context stack. (Deprecated)
    - `escape`: A function for escaping HTML characters. (Deprecated, use markupsafe.escape instead)
    - `Markup`: A class for representing unescaped HTML. (Deprecated, use markupsafe.Markup instead)
    - `signals_available`: Always returns True, as signals are always available.

Raises:
    AttributeError: If the requested attribute does not exist.
"""""""
False,"def make_response(self, rv: ft.ResponseReturnValue) -> Response:
    """"""
    Creates a response object from the given view function result.

    The response object is created based on the type of the view function result.
    If the result is a tuple, it is unpacked into body, status, and headers.
    If the result is None, a TypeError is raised.
    If the result is not an instance of the response class, it is converted to
    the correct type.

    Args:
        rv: The view function result.

    Returns:
        A Response object.

    Raises:
        TypeError: If the view function did not return a valid response tuple,
            or if the result is None.
    """""""
True,"""""""
Saves a session cookie to the client's browser.

This method sets a session cookie based on the provided `app`, `session`, and `response` objects.
It determines the necessary cookie attributes (name, domain, path, secure, samesite, httponly) using
the `get_cookie_name`, `get_cookie_domain`, `get_cookie_path`, `get_cookie_secure`, 
`get_cookie_samesite`, and `get_cookie_httponly` methods.

If the session was accessed at all, it adds a ""Vary: Cookie"" header to the response.
If the session is empty or modified to be empty, it removes the cookie from the response.
Otherwise, it sets the cookie with the determined attributes and adds a ""Vary: Cookie"" header.

Parameters:
app (Flask): The Flask application instance.
session (SessionMixin): The session object being saved.
response (Response): The HTTP response object.

Returns:
None
"""""""
True,"""""""
Test session vary cookie functionality.

This function tests the behavior of Flask's session object when
varying headers. It checks that the 'Vary' header is set correctly
for different routes and scenarios.

Parameters:
app (Flask application): The Flask application instance.
client (requests Session): The requests client instance.

Returns:
None

Tests:

- /set: Tests setting a value in the session and verifying the 'Vary'
  header is not set.
- /get: Tests getting a value from the session and verifying the 'Vary'
  header is not set.
- /getitem: Tests getting a value from the session using indexing and
  verifying the 'Vary' header is not set.
- /setdefault: Tests setting a default value in the session and verifying
  the 'Vary' header is not set.
- /clear: Tests clearing the session and verifying the 'Vary' header is
  not set.
- /vary-cookie-header-set: Tests varying the 'Cookie' header when setting
  a value in the session.
- /vary-header-set: Tests varying multiple headers when setting a value
  in the session.
- /no-vary-header: Tests that no 'Vary' header is set for this route.

Note:
The `expect` function is used to test each route. It sends a GET request
to the specified path and verifies the 'Vary' header is set correctly.
If the expected value is not provided, it checks that the 'Vary' header
is not present at all.
"""""""
True,"""""""
Clears the Flask session.

This function uses the `flask.session.clear()` method to remove all items from the current session. It returns an empty string, indicating that no data was cleared.

Args:
    None

Returns:
    str: An empty string indicating success
"""""""
True,"""""""
Tests the behavior of session refresh with the Vary header.

This test suite verifies that when a user navigates to a login page and then
refreshes their session, the server responds with a Vary: Cookie header.
Additionally, it checks that this behavior is consistent even when navigating
to an ignored route.

Args:
    app (Flask application): The Flask application instance.
    client (TestClient): A TestClient instance for making HTTP requests.

Returns:
    None

Raises:
    AssertionError: If the Vary header does not match the expected value.
"""""""
True,"""""""
Login Function.

This function sets the user ID in the session to 1 and makes the session permanent.
 
Parameters:
None
 
Returns:
An empty string indicating successful login.
 
Raises:
None
 
Notes:
This function is a placeholder for actual authentication logic. It should be replaced with a secure method of verifying user credentials.
"""""""
True,"""""""
This function is intentionally left empty and does not perform any meaningful operation. It is intended to be an example of a function that returns an empty string.

Returns:
    str: An empty string, indicating that no value was returned by this function.
"""""""
True,"""""""
Returns the value of the requested attribute, or raises an AttributeError if it does not exist.

This function is used to handle special attributes that are deprecated and will be removed in future versions of Flask.
It provides a way to access these attributes while still raising a warning about their deprecation.

Attributes:
    - `_app_ctx_stack`: The application context stack. (Deprecated)
    - `_request_ctx_stack`: The request context stack. (Deprecated)
    - `escape`: A function for escaping HTML characters. (Deprecated, use markupsafe.escape instead)
    - `Markup`: A class for representing unescaped HTML. (Deprecated, use markupsafe.Markup instead)
    - `signals_available`: Always returns True, as signals are always available.

Raises:
    AttributeError: If the requested attribute does not exist.
"""""""
True,"""""""
Initialize the application.

This method is called when an instance of this class is created. It takes in various parameters to configure the application's URL structure.

Parameters:
app (Flask): The Flask application instance.
path (str): The root path of the application. Defaults to ""/"".
base_url (Optional[str]): The base URL of the application. If provided, subdomain and url_scheme cannot be used. Defaults to None.
subdomain (Optional[str]): The subdomain of the application. If provided with a base_url, it will override the base_url. Defaults to None.
url_scheme (Optional[str]): The scheme of the URL. If not provided, it will use the preferred scheme from the Flask configuration. Defaults to None.

Returns:
None
"""""""
False,"""""""
Initialize the documentation assistant.

This function initializes a new instance of the documentation assistant, 
setting default values for its attributes and calling the parent class's constructor.

Args:
    *args: Variable length argument list containing any additional arguments.
    **kwargs: Keyworded arguments containing any additional keyword arguments.

Returns:
    None
""""""
def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
    super().__init__(*args, **kwargs)
    self.preserve_context = False
    self._new_contexts: t.List[t.ContextManager[t.Any]] = []
    self._context_stack = ExitStack()
    self.environ_base = {
        ""REMOTE_ADDR"": ""127.0.0.1"",
        ""HTTP_USER_AGENT"": f""werkzeug/{werkzeug.__version__}"",
    }"
False,"""""""
Yields a new session object for the given test request context.

This function is used to create and manage sessions in a test environment.
It handles the creation of cookies and updates them based on the response headers.

Args:
    *args: Variable arguments passed to the test request context.
    **kwargs: Keyword arguments passed to the test request context.

Returns:
    A generator yielding session objects, or None if no session is created.
""""""
def session_transaction(
        self, 
        *args: t.Any, 
        **kwargs: t.Any
    ) -> t.Generator[SessionMixin, None, None]:"
True,"""""""
Opens a new test request.

This method is used to create a new test request, which can be used to simulate HTTP requests and responses.
It takes several keyword arguments that control the behavior of the request:

- `buffered`: If True, the response will be buffered. Otherwise, it will be sent immediately.
- `follow_redirects`: If True, redirects will be followed.

If no request is provided, one will be created from the given arguments and keyword arguments.

Returns:
    TestResponse: The response object for the test request.
"""""""
True,"""""""
    Enters the context of a Flask client.

    This method is used to create a new context for the Flask client. It sets the `preserve_context` attribute to `True`, 
    indicating that subsequent invocations will preserve the current context. If an attempt is made to nest client invocations, 
    a RuntimeError is raised.

    Returns:
        The instance of the FlaskClient class, allowing for method chaining.
    
    Raises:
        RuntimeError: If an attempt is made to nest client invocations.
"""""""
True,"""""""
Closes the context stack and sets preserve_context to False.

This method is called when the exception handling context is exited. It ensures that the context is properly cleaned up by closing the context stack, which helps prevent resource leaks. The `preserve_context` flag is also set to False to indicate that the current context should not be preserved for future use.

Args:
    exc_type (type): The type of the exception that was raised.
    exc_value (BaseException): The value of the exception that was raised.
    tb (TracebackType): The traceback object associated with the exception.

Returns:
    None
"""""""
True,"""""""
Initialize a new instance of the class.

Args:
    app (Flask): The Flask application instance.
    **kwargs (t.Any): Additional keyword arguments to pass to the superclass's __init__ method.

Returns:
    None
"""""""
False,"""""""
Raises a RuntimeError indicating that the session is unavailable due to an unconfigured secret key.

Args:
    *args: Variable length argument list.
    **kwargs: Arbitrary keyword arguments.

Returns:
    te.NoReturn: An exception indicating that the function cannot be continued due to an error."
True,"""""""
Creates and returns a null session instance for the given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    NullSession: A null session instance.
"""""""
True,"""""""
Returns the name of the cookie used to store session data in a Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The name of the session cookie.
"""""""
False,"def get_cookie_domain(self, app: ""Flask"") -> t.Optional[str]:
    """"""
    Returns the session cookie domain for a given Flask application.

    If the domain is not set or invalid (e.g., an IP address), returns None.
    Otherwise, sets the domain in the application's configuration and returns it.

    :param app: The Flask application instance
    :return: The session cookie domain as a string, or None if invalid
    """"""
    rv = app.config[""SESSION_COOKIE_DOMAIN""]

    # set explicitly, or cached from SERVER_NAME detection
    # if False, return None
    if rv is not None:
        return rv if rv else None

    rv = app.config[""SERVER_NAME""]

    # server name not set, cache False to return none next time
    if not rv:
        app.config[""SESSION_COOKIE_DOMAIN""] = False
        return None

    # chop off the port which is usually not supported by browsers
    # remove any leading '.' since we'll add that later
    rv = rv.rsplit("":"", 1)[0].lstrip(""."")

    if ""."" not in rv:
        # Chrome doesn't allow names without a '.'. This should only
        # come up with localhost. Hack around this by not setting
        # the name, and show a warning.
        warnings.warn(
            f""{rv!r} is not a valid cookie domain, it must contain""
            "" a '.'. Add an entry to your hosts file, for example""
            f"" '{rv}.localdomain', and use that instead.""
        )
        app.config[""SESSION_COOKIE_DOMAIN""] = False
        return None

    ip = is_ip(rv)

    if ip:
        warnings.warn(
            ""The session cookie domain is an IP address. This may not work""
            "" as intended in some browsers. Add an entry to your hosts""
            ' file, for example ""localhost.localdomain"", and use that'
            "" instead.""
        )

    # if this is not an ip and app is mounted at the root, allow subdomain
    # matching by adding a '.' prefix
    if self.get_cookie_path(app) == ""/"" and not ip:
        rv = f"".{rv}""

    app.config[""SESSION_COOKIE_DOMAIN""] = rv
    return rv"
True,"""""""
Returns the path of the cookie used by a Flask application.

If 'SESSION_COOKIE_PATH' is set in the application's configuration,
its value will be returned. Otherwise, the value of
'APPLICATION_ROOT' will be used as a fallback.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The path of the cookie.
"""""""
True,"""""""
Returns whether the session cookie is set to be HTTP-only in the given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    bool: True if the session cookie is HTTP-only, False otherwise.
"""""""
True,"""""""
Returns whether the session cookie is secure.

This method checks if the `SESSION_COOKIE_SECURE` configuration variable
is set to True in the Flask application's configuration. If it is, the
session cookie will be transmitted over a secure protocol (HTTPS).

Args:
    app: The Flask application instance.

Returns:
    bool: Whether the session cookie is secure.
"""""""
True,"""""""
Returns the value of the `SESSION_COOKIE_SAMESITE` configuration option from the provided Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The value of the `SESSION_COOKIE_SAMESITE` configuration option.
"""""""
True,"""""""
Returns the expiration time of a Flask session.

If the session is permanent, returns the current UTC time plus the permanent session lifetime.
Otherwise, returns None.

Args:
    self: The instance of the class that this method belongs to (not used in this implementation).
    app: A Flask application object.
    session: A SessionMixin object representing the session.

Returns:
    datetime: The expiration time of the session, or None if the session is not permanent.
"""""""
False,"""""""
Determines whether a cookie should be set based on the Flask application's configuration.

Args:
    - `app`: The Flask application instance.
    - `session`: A SessionMixin object representing the current session.

Returns:
    bool: True if a cookie should be set, False otherwise."
True,"""""""
Opens a new session for the given Flask application and request.

Args:
    - `app`: The Flask application instance.
    - `request`: The HTTP request object.

Returns:
    An optional SessionMixin object, indicating whether a session was successfully opened. If not implemented by subclasses, raises NotImplementedError.

Raises:
    NotImplementedError: If the method is not implemented by subclasses.
"""""""
True,"""""""
Saves a session.

This method is intended to be overridden by subclasses. It takes in the Flask application,
the session object, and the response object as parameters. The implementation of this
method should be provided by the subclass.

Parameters:
app (Flask): The Flask application instance.
session (SessionMixin): The session object.
response (Response): The response object.

Returns:
None

Raises:
NotImplementedError: This method is intended to be overridden and should not be called directly.
"""""""
True,"""""""
Returns a signing serializer for the provided Flask application.

If the application's secret key is not set, returns None. Otherwise, creates a
URLSafeTimedSerializer instance with the secret key and additional configuration
from the application's settings.

Args:
    app (Flask): The Flask application to generate the serializer for.
Returns:
    URLSafeTimedSerializer: The generated signing serializer, or None if the
        application's secret key is not set.
"""""""
True,"""""""
Opens a new session for the given Flask application and request.

Args:
    app (Flask): The Flask application instance.
    request (Request): The HTTP request object.

Returns:
    t.Optional[SecureCookieSession]: The opened session, or None if creation fails.
"""""""
True,"""""""
Saves a session cookie to the client's browser.

This method sets a session cookie based on the provided `app`, `session`, and `response` objects.
It determines the necessary cookie attributes (name, domain, path, secure, samesite, httponly) using
the `get_cookie_name`, `get_cookie_domain`, `get_cookie_path`, `get_cookie_secure`, 
`get_cookie_samesite`, and `get_cookie_httponly` methods.

Parameters:
app (Flask): The Flask application instance.
session (SessionMixin): The session object being saved.
response (Response): The HTTP response object.

Returns:
None
"""""""
True,"""""""
Test session using server name.

This function tests the functionality of Flask's session handling when using a server name.
It updates the session with a value and then checks if the session is correctly set for the domain specified by the `SERVER_NAME` configuration variable.

Parameters:
app (Flask application): The Flask application instance to use for testing.
client (requests Session): A requests session object used to make HTTP requests.

Returns:
None
"""""""
False,"""""""
Test session using server name and port.

This function tests the functionality of Flask's session handling when using a server name and port.
It updates the session with a value, sends a GET request to the root URL, and checks if the `Set-Cookie` header contains the expected domain information.

Parameters:
    app (Flask application): The Flask application instance.
    client (requests Session): The requests session instance.

Returns:
    None
""""""
def test_session_using_server_name_and_port(app, client):
    app.config.update(SERVER_NAME=""example.com:8080"")

    @app.route(""/"")
    def index():
        flask.session[""testing""] = 42
        return ""Hello World""

    rv = client.get(""/"", ""http://example.com:8080/"")
    cookie = rv.headers[""set-cookie""].lower()
    # or condition for Werkzeug < 2.3
    assert ""domain=example.com"" in cookie or ""domain=.example.com"" in cookie"
True,"""""""
Flask Session Initialization and Response Generation

This function initializes a Flask session variable 'testing' with value 42 and returns a string response.

Parameters:
None

Returns:
str: A greeting message ""Hello World""

Side Effects:
- Initializes the Flask session variable 'testing' with value 42
"""""""
False,"""""""
Test session using server name, port and path.

This function tests the creation of a Flask session using the `server_name`, 
`application_root` configuration options. It verifies that the session is 
correctly set with the expected domain, path, and HTTP-only flags in the 
set-cookie header.

Parameters:
    app (Flask application): The Flask application instance.
    client (requests Session): The requests session instance.

Returns:
    None
""""""
def test_session_using_server_name_port_and_path(app, client):"
True,"""""""
Flask Session Initialization and Response Generation

This function initializes a Flask session variable 'testing' with value 42 and returns a string response.

Parameters:
None

Returns:
str: A greeting message ""Hello World""

Side Effects:
- Initializes the Flask session variable 'testing' with value 42
"""""""
True,"""""""
Test session warning for localhost.

This function tests the behavior of Flask's session warnings when using a local server.
It updates the session with a test value, sends a request to the index route,
and verifies that the correct warning is raised and its message matches the expected value.

Parameters:
    recwarn (WarningRegistry): The registry of warnings to be popped from.
    app (Flask application instance): The Flask application instance.
    client (TestClient): The test client for making requests to the application.

Returns:
    None
"""""""
True,"""""""
Flask Session Test Function

This function tests the functionality of Flask's session management.
It sets a test value in the session and returns a success message.

Returns:
    str: A success message indicating that the test was run successfully.

Note:
    This function should be used as part of a larger application to test session management.
"""""""
True,"""""""
Test session IP warning.

This function tests the behavior of Flask when setting a cookie with an IP address as its domain.
It verifies that a UserWarning is raised and that the warning message contains the expected text.

Parameters:
    recwarn (warnings.Warnings): The warnings registry to use for this test.
    app (Flask application instance): The Flask application instance to use for this test.
    client (requests.Session): The requests session to use for making HTTP requests.

Returns:
    None
"""""""
True,"""""""
Flask Session Test Function

This function tests the functionality of Flask's session management.
It sets a test value in the session and returns a success message.

Returns:
    str: A success message indicating that the test was run successfully.

Note:
    This function should be used as part of a larger application to test session management.
"""""""
True,"""""""
Test session special types.

This function tests the behavior of Flask's session object when storing
special types such as bytes, Markup objects, and UUIDs. It verifies that
these types are stored correctly and can be retrieved from the session.

Parameters:
app (Flask application): The Flask application instance.
client (Client): The Client instance used for testing.

Returns:
None
"""""""
True,"""""""
Dumps session contents into the Flask session.

This function populates the Flask session with various data types, including a tuple, bytes, markup, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).

Note:
- The `flask.session` object is used to store and retrieve session data.
- The `the_uuid`, `now` variables are assumed to be defined elsewhere in the application.

Returns:
    tuple: A tuple containing an empty string and a status code of 204.
"""""""
False,"""""""
Test the functionality of the Flask flash messaging system.

This test suite covers various scenarios, including:

- Flashing messages with different categories
- Filtering flashed messages by category
- Retrieving flashed messages with and without categories

The tests ensure that the flash messaging system behaves as expected in different situations.
""""""

def test_extended_flashing(app):
    # Be sure app.testing=True below, else tests can fail silently.
    #
    # Specifically, if app.testing is not set to True, the AssertionErrors
    # in the view functions will cause a 500 response to the test client
    # instead of propagating exceptions."
True,"""""""
Flashes messages to the user with different types of flash messages.

This function uses Flask's built-in `flash` method to display messages
to the user. The first argument is the message itself, and the second
argument (optional) specifies the type of flash message.

Available types:
- 'info': displays a success or info message.
- 'warning': displays a warning message.
- 'error': displays an error message.

Example usage:

    index()
"""""""
True,"""""""
Tests that the `get_flashed_messages` function returns a list of flashed messages.

This test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.
It asserts that the returned list contains the expected messages, including HTML markup.

Args:
    None

Returns:
    str: An empty string indicating successful execution of the test.

Raises:
    AssertionError: If the returned list does not match the expected output.
"""""""
True,"""""""
Tests the functionality of getting flashed messages with categories.

This function tests the `flask.get_flashed_messages(with_categories=True)` method, 
which returns a list of tuples containing message category and corresponding message. 

It asserts that the length of the returned list is 3 and checks if it contains the expected messages.
"""""""
False,"""""""
Tests the functionality of `flask.get_flashed_messages` with category filtering.

This function tests that the `get_flashed_messages` method returns a list of
flashed messages, filtered by categories. The test case checks that the
filtered messages match the expected output.

Parameters:
    None

Returns:
    A string indicating whether the test passed or failed.
""""""
def test_filters():"
False,"""""""
Tests the functionality of getting flashed messages with a category filter.

This function tests that the `flask.get_flashed_messages` method returns two messages
when called with a category filter. The first message is expected to be ""Hello World""
and the second message is expected to be an HTML-marked string ""<em>Testing</em>"".
""""""

def test_filters2():
    messages = flask.get_flashed_messages(category_filter=[""message"", ""warning""])
    assert len(messages) == 2
    assert messages[0] == ""Hello World""
    assert messages[1] == flask.Markup(""<em>Testing</em>"")
    return """""
True,"""""""
Renders the first request to an application.

This function simulates a client making a GET request to the root URL of the application.
It asserts that the `debug` attribute is set to True, and that the response from the server matches the expected value.
Additionally, it tests that attempting to add a new route after the first request raises an AssertionError with a specific message.

Args:
    app (Flask application): The Flask application instance being tested.
    client (requests.Session): A requests session object used to simulate the client's request.

Returns:
    None
"""""""
True,"""""""
Request Functions for Application Testing

This function tests the application's behavior when making requests before and after the first request.

Parameters:
app (object): The application object to be tested.
client (object): The client object used to make HTTP requests.

Returns:
None
"""""""
True,"""""""
Adds 42 to the 'got' list.

This function is not intended for external use and should only be accessed internally within the application.
"""""""
True,"""""""
Concurrently tests the application's routing functionality by making a request to the root URL while another thread is asserting that a value was appended to the `got` list.

This function uses pytest's deprecated_call context manager to ensure that the `foo` function, which appends a value to the `got` list, is called before the first request is made. It then creates a new thread that runs the `get_and_assert` function in parallel with the main thread.

The `get_and_assert` function makes a GET request to the root URL and asserts that the value appended to the `got` list matches the expected value. The main thread waits for the thread to finish before asserting that the application's `got_first_request` attribute is set to True.

This test ensures that the application's routing functionality works correctly even when multiple threads are making requests concurrently.
"""""""
True,"""""""
Returns the result of appending 42 to the 'got' list after a 200ms delay.

Args:
    None

Returns:
    None

Raises:
    None

Example:
    >>> get_and_asse()
"""""""
False,"""""""
Tests the functionality of the get method on the client object.

This test case checks if the get method returns a list containing the expected value when called with the root URL (""/"").

Args:
    None

Returns:
    None

Raises:
    AssertionError: If the returned list does not match the expected output.
""""""

client.get(""/"")
assert got == [42]

""""""
Tests the functionality of threading in Python.

This test case checks if the Thread class can be instantiated correctly and if it can target a specific function.

Args:
    None

Returns:
    None

Raises:
    AssertionError: If the thread is not created successfully or if it does not target the expected function.
""""""

t = Thread(target=  # <--- Missing keyword 'self'"
True,"""""""
Returns the value of the requested attribute, or raises an AttributeError if it does not exist.

This function is used to handle special attributes that are deprecated and will be removed in future versions of Flask.
It provides a way to access these attributes while still raising a warning about their deprecation.

Attributes:
    - `_app_ctx_stack`: The application context stack. (Deprecated)
    - `_request_ctx_stack`: The request context stack. (Deprecated)
    - `escape`: A function for escaping HTML characters. (Deprecated, use markupsafe.escape instead)
    - `Markup`: A class for representing unescaped HTML. (Deprecated, use markupsafe.Markup instead)
    - `signals_available`: Always returns True, as signals are always available.

Raises:
    AttributeError: If the requested attribute does not exist.
"""""""
True,"""""""
Raises a RuntimeError indicating that the session is unavailable due to an unconfigured secret key.

Args:
    *args: Variable length argument list.
    **kwargs: Arbitrary keyword arguments.

Returns:
    None, as this function does not return any value. Instead, it raises a RuntimeError with a descriptive error message.

Raises:
    RuntimeError: If the session is unavailable because no secret key was set.
"""""""
True,"""""""
Creates and returns a null session instance for the given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    NullSession: A null session instance.

Raises:
    TypeError: If the provided `app` is not an instance of Flask.

Note:
This method creates a new instance of the `NullSession` class, which does not store any data. It is intended for use in testing or other scenarios where no session data needs to be stored.
"""""""
False,"""""""
Returns the name of the cookie used to store session data in a Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The name of the session cookie."
True,"""""""
Returns the domain of the session cookie from a given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str | None: The domain of the session cookie, or None if not set.
"""""""
False,"""""""
Returns the path of the cookie used by a Flask application.

If 'SESSION_COOKIE_PATH' is set in the application's configuration,
its value will be returned. Otherwise, the value of
'APPLICATION_ROOT' will be used as a fallback.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The path of the cookie.
""""""
def get_cookie_path(self, app: Flask) -> str:"
False,"""""""
Returns whether the session cookie is set to be HTTP-only in the given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    bool: True if the session cookie is HTTP-only, False otherwise."
True,"""""""
Returns whether the session cookie is secure.

This method checks if the `SESSION_COOKIE_SECURE` configuration variable
is set to True in the Flask application's configuration. If it is, the
session cookie will be transmitted over a secure protocol (HTTPS).

Args:
    app: The Flask application instance.

Returns:
    bool: Whether the session cookie is secure.
"""""""
False,"def get_cookie_samesite(self, app: Flask) -> str:
    """"""
    Returns the value of the `SESSION_COOKIE_SAMESITE` configuration option from the provided Flask application.

    Args:
        app (Flask): The Flask application instance.

    Returns:
        str: The value of the `SESSION_COOKIE_SAMESITE` configuration option.
    """""""
False,"""""""
Returns the expiration time of a Flask session.

If the session is permanent, returns the current UTC time plus the permanent session lifetime.
Otherwise, returns None.

Args:
    self: The instance of the class that this method belongs to (not used in this implementation).
    app: A Flask application object.
    session: A SessionMixin object representing the session.

Returns:
    datetime: The expiration time of the session, or None if the session is not permanent."
False,"""""""
Determines whether a cookie should be set based on the session's modification status and configuration.

Args:
    - `app`: The Flask application instance.
    - `session`: The session mixin instance.

Returns:
    bool: True if a cookie should be set, False otherwise."
True,"""""""
Opens a new session for the given Flask application and request.

Args:
    - `app`: The Flask application instance.
    - `request`: The HTTP request object.

Returns:
    An optional SessionMixin object, indicating whether a session was successfully opened. If not implemented by subclasses, raises NotImplementedError.

Raises:
    NotImplementedError: If the method is not implemented by subclasses.
"""""""
False,"""""""
Saves a session by overriding the implementation of this method in subclasses.

Parameters
----------
app : Flask
    The Flask application instance.
session : SessionMixin
    The session object.
response : Response
    The response object.

Returns
-------
None

Raises
------
NotImplementedError
    This method is intended to be overridden and should not be called directly."
False,"""""""
Returns a signing serializer for the provided Flask application.

If the application's secret key is not set, returns None. Otherwise, creates a
URLSafeTimedSerializer instance with the secret key and additional configuration
from the application's settings.

Args:
    app (Flask): The Flask application to generate the serializer for.
Returns:
    URLSafeTimedSerializer: The generated signing serializer, or None if the
        application's secret key is not set."
False,"""""""
Opens a new session for the given Flask application and request.

Args:
    app (Flask): The Flask application instance.
    request (Request): The HTTP request object.

Returns:
    SecureCookieSession | None: The opened session, or None if creation fails."
True,"""""""
Saves a session cookie to the client's browser.

This method sets a session cookie based on the provided `app`, `session`, and `response` objects.
It determines the necessary cookie attributes (name, domain, path, secure, samesite, httponly) using
the `get_cookie_name`, `get_cookie_domain`, `get_cookie_path`, `get_cookie_secure`, 
`get_cookie_samesite`, and `get_cookie_httponly` methods.

Parameters:
    app (Flask): The Flask application instance.
    session (SessionMixin): The session object being saved.
    response (Response): The HTTP response object.

Returns:
    None
"""""""
False,"""""""
Initialize the application.

This method is called when an instance of this class is created. It takes in various parameters to configure the application's URL structure.

Parameters:
app (Flask): The Flask application instance.
path (str): The root path of the application. Defaults to ""/"".
base_url (Optional[str]): The base URL of the application. If provided, subdomain and url_scheme cannot be used. Defaults to None.
subdomain (Optional[str]): The subdomain of the application. If provided with a base_url, it will override the base_url. Defaults to None.
url_scheme (Optional[str]): The scheme of the URL. If not provided, it will use the preferred scheme from the Flask configuration. Defaults to None.

Returns:
None

Raises:
AssertionError: If ""subdomain"" or ""url_scheme"" is passed with ""base_url"".

Note:
- This method modifies the `app` instance by setting its `APPLICATION_ROOT` and `PREFERRED_URL_SCHEME`.
- It also updates the `path` parameter based on the provided `base_url`, `subdomain`, and `url_scheme`."
False,"""""""
Initialize the documentation assistant.

This function initializes a new instance of the documentation assistant, 
setting default values for its attributes and calling the parent class's constructor.

Args:
    *args: Variable length argument list containing any additional arguments.
    **kwargs: Keyworded arguments containing any additional keyword arguments.

Returns:
    None
""""""
def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
    super().__init__(*args, **kwargs)
    self.preserve_context = False
    self._new_contexts: list[t.ContextManager[t.Any]] = []
    self._context_stack = ExitStack()
    self.environ_base = {
        ""REMOTE_ADDR"": ""127.0.0.1"",
        ""HTTP_USER_AGENT"": f""werkzeug/{werkzeug.__version__}"",
    }"
True,"""""""
Yield a session object for the current test request context.

This function is used to create and manage sessions for testing purposes.
It checks if cookies are enabled, sets up the WSGI context, opens a new session,
and saves it after use. If the session backend fails to open a session, a
RuntimeError is raised.

Args:
    *args: Variable length argument list containing any arguments passed to the test request context.
    **kwargs: Keyworded arguments for the test request context.

Returns:
    A generator yielding SessionMixin objects.
"""""""
True,"""""""
Opens a new test request.

This method is used to create a new test request, which can be used to simulate HTTP requests and responses.
It takes several keyword arguments that control the behavior of the request:

- `buffered`: If True, the response will be buffered. Otherwise, it will be sent immediately.
- `follow_redirects`: If True, redirects will be followed.

If no request is provided, one will be created from the given arguments and keyword arguments.

Returns:
    TestResponse: The response object for the test request.

Raises:
    ValueError: If the request cannot be created from the given arguments and keyword arguments.
"""""""
True,"""""""
Enters the context of a Flask client.

This method is used to create a new context for the Flask client. It sets the `preserve_context` attribute to `True`, 
indicating that subsequent invocations will preserve the current context. If an attempt is made to nest client invocations, 
a RuntimeError is raised.

Returns:
    The instance of the FlaskClient class, allowing for method chaining.
    
Raises:
    RuntimeError: If an attempt is made to nest client invocations.
"""""""
True,"""""""
Closes the context stack and sets preserve_context to False.

This method is called when the exception handling context is exited. It ensures that the context is properly cleaned up by closing the context stack, which helps prevent resource leaks. The `preserve_context` flag is also set to False to indicate that the current context should not be preserved for future use.

Args:
    exc_type (type): The type of the exception that was raised.
    exc_value (BaseException): The value of the exception that was raised.
    tb (TracebackType): The traceback object associated with the exception.

Returns:
    None
"""""""
True,"""""""
Initialize a new instance of the class.

Args:
    app (Flask): The Flask application instance.
    **kwargs (t.Any): Additional keyword arguments to pass to the superclass's __init__ method.

Returns:
    None
"""""""
False,"def test_session_path(app, client):
    """"""
    Test session using server name.

    This function tests the functionality of Flask's session handling when using a server name.
    It updates the session with a value and then checks if the session is correctly set for the domain specified by the `SERVER_NAME` configuration variable.

    Parameters:
        app (Flask application): The Flask application instance to use for testing.
        client (requests Session): A requests session object used to make HTTP requests.

    Returns:
        None
    """""""
True,"""""""
Tests the behavior of Flask's session object when storing special types such as bytes, Markup objects, and UUIDs.

This function tests that these types are stored correctly and can be retrieved from the session.

Parameters:
    app (Flask application): The Flask application instance.
    client (Client): The Client instance used for testing.

Returns:
    None
"""""""
False,"""""""
Dumps session contents into the Flask session.

This function populates the Flask session with various data types, including a tuple, bytes, markup, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).

Note:
- The `flask.session` object is used to store and retrieve session data.
- The `the_uuid`, `now` variables are assumed to be defined elsewhere in the application.

Returns:
    tuple: A tuple containing an empty string and a status code of 204."
False,"def test_extended_flashing(app):
    """"""
    Tests the functionality of flashing messages to the user with different types of flash messages.

    This function uses Flask's built-in `flash` method to display messages
    to the user. The first argument is the message itself, and the second
    argument (optional) specifies the type of flash message.

    Available types:
    - 'info': displays a success or info message.
    - 'warning': displays a warning message.
    - 'error': displays an error message.

    Example usage:

        index()
""""""
    flask.flash(""Hello World"")
    flask.flash(""Hello World"", ""error"")
    flask.flash(Markup(""<em>Testing</em>""), ""warning"")
    return """""
True,"""""""
Flashes messages to the user with different types of flash messages.

This function uses Flask's built-in `flash` method to display messages
to the user. The first argument is the message itself, and the second
argument (optional) specifies the type of flash message.

Available types:
- 'info': displays a success or info message.
- 'warning': displays a warning message.
- 'error': displays an error message.

Example usage:

    index()
"""""""
False,"""""""
Tests that the `get_flashed_messages` function returns a list of flashed messages.

This test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.
It asserts that the returned list contains the expected messages, including HTML markup.

Args:
    None

Returns:
    str: An empty string indicating successful execution of the test.

Raises:
    AssertionError: If the returned list does not match the expected output."
True,"""""""
Tests the functionality of getting flashed messages with categories.

This function tests the `flask.get_flashed_messages(with_categories=True)` method, 
which returns a list of tuples containing message category and corresponding message. 

It asserts that the length of the returned list is 3 and checks if it contains the expected messages.
"""""""
False,"""""""
Tests the functionality of the `get_flashed_messages` function from Flask, 
specifically when using category filters.

This test case checks that the function returns a list of messages with their respective categories,
and that it correctly handles the 'with_categories' parameter.

Parameters:
- None

Returns:
- A string indicating whether the test passed or failed.
""""""
def test_filters():
    messages = flask.get_flashed_messages(
        category_filter=[""message"", ""warning""], with_categories=True
    )
    assert list(messages) == [
        (""message"", ""Hello World""),
        (""warning"", Markup(""<em>Testing</em>"")),
    ]
    return """""
True,"""""""
Tests the functionality of getting flashed messages with a category filter.

This function tests that the `flask.get_flashed_messages` method returns two messages
when called with a category filter. The first message is expected to be ""Hello World""
and the second message is expected to be an HTML-marked string ""<em>Testing</em>"".
"""""""
True,"""""""
Returns the value of the requested attribute, or raises an AttributeError if it does not exist.

This function is used to handle special attributes that are deprecated and will be removed in future versions of Flask.
It provides a way to access these attributes while still raising a warning about their deprecation.

Attributes:
    - `_app_ctx_stack`: The application context stack. (Deprecated)
    - `_request_ctx_stack`: The request context stack. (Deprecated)
    - `escape`: A function for escaping HTML characters. (Deprecated, use markupsafe.escape instead)
    - `Markup`: A class for representing unescaped HTML. (Deprecated, use markupsafe.Markup instead)
    - `signals_available`: Always returns True, as signals are always available.

Raises:
    AttributeError: If the requested attribute does not exist.
"""""""
True,"""""""
Raises a RuntimeError indicating that the session is unavailable due to an unconfigured secret key.

Args:
    *args: Variable length argument list.
    **kwargs: Arbitrary keyword arguments.

Returns:
    None, as this function does not return any value. Instead, it raises a RuntimeError with a descriptive error message.

Raises:
    RuntimeError: If the session is unavailable because no secret key was set.
"""""""
True,"""""""
Creates and returns a null session instance for the given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    NullSession: A null session instance.

Raises:
    TypeError: If the provided `app` is not an instance of Flask.

Note:
This method creates a new instance of the `NullSession` class, which does not store any data. It is intended for use in testing or other scenarios where no session data needs to be stored.
"""""""
False,"""""""
Returns the name of the cookie used to store session data in a Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The name of the session cookie."
True,"""""""
Returns the domain of the session cookie from a given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str | None: The domain of the session cookie, or None if not set.
"""""""
False,"""""""
Returns the path of the cookie used by a Flask application.

If 'SESSION_COOKIE_PATH' is set in the application's configuration,
its value will be returned. Otherwise, the value of
'APPLICATION_ROOT' will be used as a fallback.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The path of the cookie.
""""""
def get_cookie_path(self, app: ""Flask"") -> str:"
False,"""""""
Returns whether the session cookie is set to be HTTP-only in the given Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    bool: True if the session cookie is HTTP-only, False otherwise."
True,"""""""
Returns whether the session cookie is secure.

This method checks if the `SESSION_COOKIE_SECURE` configuration variable
is set to True in the Flask application's configuration. If it is, the
session cookie will be transmitted over a secure protocol (HTTPS).

Args:
    app: The Flask application instance.

Returns:
    bool: Whether the session cookie is secure.
"""""""
True,"""""""
Returns the value of the `SESSION_COOKIE_SAMESITE` configuration option from the provided Flask application.

Args:
    app (Flask): The Flask application instance.

Returns:
    str: The value of the `SESSION_COOKIE_SAMESITE` configuration option.
"""""""
False,"""""""
Returns the expiration time of a Flask session.

If the session is permanent, returns the current UTC time plus the permanent session lifetime.
Otherwise, returns None.

Args:
    app: A Flask application object.
    session: A SessionMixin object representing the session.

Returns:
    datetime: The expiration time of the session, or None if the session is not permanent."
False,"""""""
Determines whether a cookie should be set based on the Flask application's configuration.

Args:
    - `app`: The Flask application instance.
    - `session`: A SessionMixin object representing the current session.

Returns:
    bool: True if a cookie should be set, False otherwise."
False,"""""""
Opens a new session for the given Flask application and request.

Args:
    - `app`: The Flask application instance.
    - `request`: The HTTP request object.

Returns:
    An optional SessionMixin object, indicating whether a session was successfully opened. If not implemented by subclasses, raises NotImplementedError.

Raises:
    NotImplementedError: If the method is not implemented by subclasses."
False,"""""""
Saves a session.

This method is intended to be overridden by subclasses. It takes in the Flask application,
the session object, and the response object as parameters. The implementation of this
method should be provided by the subclass.

Parameters:
app (Flask): The Flask application instance.
session (SessionMixin): The session object.
response (Response): The response object.

Returns:
None

Raises:
NotImplementedError: This method is intended to be overridden and should not be called directly."
False,"""""""
Returns a signing serializer for the provided Flask application.

If the application's secret key is not set, returns None. Otherwise, creates a
URLSafeTimedSerializer instance with the secret key and additional configuration
from the application's settings.

Args:
    app (Flask): The Flask application to generate the serializer for.
Returns:
    URLSafeTimedSerializer: The generated signing serializer, or None if the
        application's secret key is not set."
False,"""""""
Opens a new session for the given Flask application and request.

Args:
    app (Flask): The Flask application instance.
    request (Request): The HTTP request object.

Returns:
    t.Optional[SecureCookieSession]: The opened session, or None if creation fails."
True,"""""""
Saves a session cookie to the client's browser.

This method sets a session cookie based on the provided `app`, `session`, and `response` objects.
It determines the necessary cookie attributes (name, domain, path, secure, samesite, httponly) using
the `get_cookie_name`, `get_cookie_domain`, `get_cookie_path`, `get_cookie_secure`, 
`get_cookie_samesite`, and `get_cookie_httponly` methods.

Parameters:
    app (Flask): The Flask application instance.
    session (SessionMixin): The session object being saved.
    response (Response): The HTTP response object.

Returns:
    None
"""""""
True,"""""""
Initialize the application.

This method is called when an instance of this class is created. It takes in various parameters to configure the application's URL structure.

Parameters:
app (Flask): The Flask application instance.
path (str): The root path of the application. Defaults to ""/"".
base_url (Optional[str]): The base URL of the application. If provided, subdomain and url_scheme cannot be used. Defaults to None.
subdomain (Optional[str]): The subdomain of the application. If provided with a base_url, it will override the base_url. Defaults to None.
url_scheme (Optional[str]): The scheme of the URL. If not provided, it will use the preferred scheme from the Flask configuration. Defaults to None.

Returns:
None

Raises:
AssertionError: If ""subdomain"" or ""url_scheme"" is passed with ""base_url"".

Note:
- This method modifies the `app` instance and its configuration.
- It uses the `super()` method to call the parent class's constructor, passing in the modified parameters.
"""""""
False,"""""""
Initialize the documentation assistant.

This function initializes a new instance of the documentation assistant, 
setting default values for its attributes and calling the parent class's constructor.

Args:
    *args: Variable length argument list containing any additional arguments.
    **kwargs: Keyworded arguments containing any additional keyword arguments.

Returns:
    None
""""""
def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
    super().__init__(*args, **kwargs)
    self.preserve_context = False
    self._new_contexts: t.List[t.ContextManager[t.Any]] = []
    self._context_stack = ExitStack()
    self.environ_base = {
        ""REMOTE_ADDR"": ""127.0.0.1"",
        ""HTTP_USER_AGENT"": f""werkzeug/{werkzeug.__version__}"",
    }"
False,"""""""
Yield a session object for the current test request context.

This function is used to create and manage sessions for testing purposes.
It checks if cookies are enabled, sets up the WSGI context, opens a new session,
and saves it after use. If the session backend fails to open a session, a
RuntimeError is raised.

Args:
    *args: Variable length argument list containing any arguments passed to the test request context.
    **kwargs: Keyworded arguments for the test request context.

Returns:
    A generator yielding SessionMixin objects.
""""""
 
if cookie_storage is None:
    raise TypeError(
        ""Cookies are disabled. Create a client with 'use_cookies=True'.""
    )

app = self.application
ctx = app.test_request_context(*args, **kwargs)

if hasattr(self, ""_add_cookies_to_wsgi""):
    self._add_cookies_to_wsgi(ctx.request.environ)
else:
    self.cookie_jar.inject_wsgi(ctx.request.environ)  # type: ignore[union-attr]

with ctx:
    sess = app.session_interface.open_session(app, ctx.request)

if sess is None:
    raise RuntimeError(""Session backend did not open a session."")

yield sess
resp = app.response_class()

if app.session_interface.is_null_session(sess):
    return

with ctx:
    app.session_interface.save_session(app, sess, resp)

if hasattr(self, ""_update_cookies_from_response""):
    try:
        # Werkzeug>=2.3.3
        self._update_cookies_from_response(
            ctx.request.host.partition("":"")[0],
            ctx.request.path,
            resp.headers.getlist(""Set-Cookie""),
        )
    except TypeError:
        # Werkzeug>=2.3.0,<2.3.3
        self._update_cookies_from_response(  # type: ignore[call-arg]
            ctx.request.host.partition("":"")[0],
            resp.headers.getlist(""Set-Cookie""),  # type: ignore[arg-type]
        )
else:
    # Werkzeug<2.3.0
    self.cookie_jar.extract_wsgi(  # type: ignore[union-attr]
        ctx.request.environ, resp.headers
    )"
True,"""""""
Opens a new test request.

This method is used to create a new test request, which can be used to simulate HTTP requests and responses.
It takes several keyword arguments that control the behavior of the request:

- `buffered`: If True, the response will be buffered. Otherwise, it will be sent immediately.
- `follow_redirects`: If True, redirects will be followed.

If no request is provided, one will be created from the given arguments and keyword arguments.

Returns:
    TestResponse: The response object for the test request.

Raises:
    ValueError: If the request cannot be created from the given arguments and keyword arguments.
"""""""
False,"```
# Enters the context of a Flask client.

## Parameters

- `self`: The instance of the class, used to access its attributes and methods.

## Returns

The instance of the FlaskClient class, allowing for method chaining.

## Raises

- `RuntimeError`: If an attempt is made to nest client invocations.
```"
True,"""""""
Closes the context stack and sets preserve_context to False.

This method is called when the exception handling context is exited. It ensures that the context is properly cleaned up by closing the context stack, which helps prevent resource leaks. The `preserve_context` flag is also set to False to indicate that the current context should not be preserved for future use.

Args:
    exc_type (type): The type of the exception that was raised.
    exc_value (BaseException): The value of the exception that was raised.
    tb (TracebackType): The traceback object associated with the exception.

Returns:
    None
"""""""
True,"""""""
Initialize a new instance of the class.

Args:
    app (Flask): The Flask application instance.
    **kwargs (t.Any): Additional keyword arguments to pass to the superclass's __init__ method.

Returns:
    None
"""""""
True,"""""""
Test session using server name.

This function tests the functionality of Flask's session handling when using a server name.
It updates the session with a value and then checks if the session is correctly set for the domain specified by the `SERVER_NAME` configuration variable.

Parameters:
app (Flask application): The Flask application instance to use for testing.
client (requests Session): A requests session object used to make HTTP requests.

Returns:
None
"""""""
False,"""""""
Test session using server name and port.

This function tests the functionality of Flask's session handling when using a server name and port.
It updates the session with a value, sends a GET request to the root URL, and checks if the `Set-Cookie` header contains the expected domain information.

Parameters:
    app (Flask application): The Flask application instance.
    client (requests Session): The requests session instance.

Returns:
    None
""""""
def test_session_using_server_name_and_port(app, client):
    app.config.update(SERVER_NAME=""example.com:8080"")

    @app.route(""/"")
    def index():
        flask.session[""testing""] = 42
        return ""Hello World""

    rv = client.get(""/"", ""http://example.com:8080/"")
    cookie = rv.headers[""set-cookie""].lower()
    # or condition for Werkzeug < 2.3
    assert ""domain=example.com"" in cookie or ""domain=.example.com"" in cookie"
True,"""""""
Flask Session Initialization and Response Generation

This function initializes a Flask session variable 'testing' with value 42 and returns a string response.

Parameters:
None

Returns:
str: A greeting message ""Hello World""

Side Effects:
- Initializes the Flask session variable 'testing' with value 42
"""""""
False,"""""""
Test session using server name, port and path.

This function tests the creation of a Flask session using the `server_name`, 
`application_root` configuration options. It verifies that the session is 
correctly set with the expected domain, path, and HTTP-only flags in the 
set-cookie header.

Parameters:
    app (Flask application): The Flask application instance.
    client (requests Session): The requests session instance.

Returns:
    None
""""""
def test_session_using_server_name_port_and_path(app, client):"
True,"""""""
Flask Session Initialization and Response Generation

This function initializes a Flask session variable 'testing' with value 42 and returns a string response.

Parameters:
None

Returns:
str: A greeting message ""Hello World""

Side Effects:
- Initializes the Flask session variable 'testing' with value 42
"""""""
True,"""""""
Test session warning for localhost.

This function tests the behavior of Flask's session warnings when using a local server.
It updates the session with a test value, sends a request to the index route,
and verifies that the correct warning is raised and its message matches the expected value.

Parameters:
    recwarn (WarningRegistry): The registry of warnings to be popped from.
    app (Flask application instance): The Flask application instance.
    client (TestClient): The test client for making requests to the application.

Returns:
    None
"""""""
True,"""""""
Flask Session Test Function

This function tests the functionality of Flask's session management.
It sets a test value in the session and returns a success message.

Returns:
    str: A success message indicating that the test was run successfully.

Note:
    This function should be used as part of a larger application to test session management.
"""""""
True,"""""""
Test session IP warning.

This function tests the behavior of Flask when setting a cookie with an IP address as its domain.
It verifies that a UserWarning is raised and that the warning message contains the expected text.

Parameters:
    recwarn (warnings.Warnings): The warnings registry to use for this test.
    app (Flask application instance): The Flask application instance to use for this test.
    client (requests.Session): The requests session to use for making HTTP requests.

Returns:
    None
"""""""
True,"""""""
Flask Session Test Function

This function tests the functionality of Flask's session management.
It sets a test value in the session and returns a success message.

Returns:
    str: A success message indicating that the test was run successfully.

Note:
    This function should be used as part of a larger application to test session management.
"""""""
False,"""""""
Tests the behavior of Flask's session object when storing special types such as bytes, Markup objects, and UUIDs.

This function tests that these types are stored correctly and can be retrieved from the session.

Parameters:
    app (Flask application): The Flask application instance.
    client (Client): The Client instance used for testing.

Returns:
    None
""""""
def test_session_special_types(app, client):
    """"""
    Dumps session contents into the Flask session.

    This function populates the Flask session with various data types, including a tuple, bytes, markup, UUID, datetime, and dictionaries.
    The returned value is an empty string and a status code of 204 (No Content).

    Note:
        - The `flask.session` object is used to store and retrieve session data.
        - The `the_uuid`, `now` variables are assumed to be defined elsewhere in the application.

    Returns:
        tuple: A tuple containing an empty string and a status code of 204.
""""""
    now = datetime.now(timezone.utc).replace(microsecond=0)
    the_uuid = uuid.uuid4()

    @app.route(""/"")
    def dump_session_contents():
        """"""
        Populates the Flask session with various data types, including a tuple, bytes, markup, UUID, datetime, and dictionaries.

        The returned value is an empty string and a status code of 204 (No Content).

        Note:
            - The `flask.session` object is used to store and retrieve session data.
            - The `the_uuid`, `now` variables are assumed to be defined elsewhere in the application.

        Returns:
            tuple: A tuple containing an empty string and a status code of 204.
        """"""
        flask.session[""t""] = (1, 2, 3)
        flask.session[""b""] = b""\xff""
        flask.session[""m""] = flask.Markup(""<html>"")
        flask.session[""u""] = the_uuid
        flask.session[""d""] = now
        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}
        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}
        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}
        return """", 204"
False,"""""""
Dumps session contents into the Flask session.

This function populates the Flask session with various data types, including a tuple, bytes, markup, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).

Note:
- The `flask.session` object is used to store and retrieve session data.
- The `the_uuid`, `now` variables are assumed to be defined elsewhere in the application.

Returns:
    tuple: A tuple containing an empty string and a status code of 204."
False,"def test_extended_flashing(app):
    """"""
    Tests the functionality of flashing messages to the user with different types of flash messages.

    This function uses Flask's built-in `flash` method to display messages
    to the user. The first argument is the message itself, and the second
    argument (optional) specifies the type of flash message.

    Available types:
    - 'info': displays a success or info message.
    - 'warning': displays a warning message.
    - 'error': displays an error message.

    Example usage:

        index()
""""""
    flask.flash(""Hello World"")
    flask.flash(""Hello World"", ""error"")
    flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")
    return """""
True,"""""""
Flashes messages to the user with different types of flash messages.

This function uses Flask's built-in `flash` method to display messages
to the user. The first argument is the message itself, and the second
argument (optional) specifies the type of flash message.

Available types:
- 'info': displays a success or info message.
- 'warning': displays a warning message.
- 'error': displays an error message.

Example usage:

    index()
"""""""
False,"""""""
Tests that the `get_flashed_messages` function returns a list of flashed messages.

This test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.
It asserts that the returned list contains the expected messages, including HTML markup.

Args:
    None

Returns:
    str: An empty string indicating successful execution of the test.

Raises:
    AssertionError: If the returned list does not match the expected output."
False,"""""""
Tests the functionality of getting flashed messages with categories.

This function tests the `flask.get_flashed_messages(with_categories=True)` method, 
which returns a list of tuples containing message category and corresponding message. 

It asserts that the length of the returned list is 3 and checks if it contains the expected messages.
""""""
def test_with_categories():
    """"""
    Tests the functionality of getting flashed messages with categories.

    Args:
        None

    Returns:
        str: An empty string
    """""""
False,"""""""
Tests the functionality of `flask.get_flashed_messages` with category filtering.

This function tests that the `get_flashed_messages` method returns a list of
flashed messages, filtered by categories. The test case checks that the
filtered messages match the expected output.

Parameters:
    None

Returns:
    A string indicating whether the test passed or failed.
""""""
def test_filters():"
True,"""""""
Tests the functionality of getting flashed messages with a category filter.

This function tests that the `flask.get_flashed_messages` method returns two messages
when called with a category filter. The first message is expected to be ""Hello World""
and the second message is expected to be an HTML-marked string ""<em>Testing</em>"".

Args:
    None

Returns:
    str: An empty string, indicating successful test execution.
"""""""
True,"""""""
Renders the first request to an application.

This function simulates a client making a GET request to the root URL of the application.
It asserts that the `debug` attribute is set to True, and that the response from the server matches the expected value.
Additionally, it tests that attempting to add a new route after the first request raises an AssertionError with a specific message.

Args:
    app (Flask application): The Flask application instance being tested.
    client (requests.Session): A requests session object used to simulate the client's request.

Returns:
    None
"""""""
True,"""""""
Request Functions for Application Testing

This function tests the application's behavior when making requests before and after the first request.

Parameters:
app (object): The application object to be tested.
client (object): The client object used to make HTTP requests.

Returns:
None
"""""""
True,"""""""
Adds 42 to the 'got' list.

This function is not intended for external use and should only be accessed internally within the application.
"""""""
True,"""""""
Concurrently tests the application's routing functionality by making a request to the root URL while another thread is asserting that a value was appended to the `got` list.

This function uses pytest's deprecated_call context manager to ensure that the `foo` function, which appends a value to the `got` list, is called before the first request is made. It then creates a new thread that runs the `get_and_assert` function in parallel with the main thread.

The `get_and_assert` function makes a GET request to the root URL and asserts that the value appended to the `got` list matches the expected value. The main thread waits for the thread to finish before asserting that the application's `got_first_request` attribute is set to True.

This test ensures that the application's routing functionality works correctly even when multiple threads are making requests concurrently.
"""""""
True,"""""""
Returns the result of appending 42 to the 'got' list after a 200ms delay.

Args:
    None

Returns:
    None

Raises:
    None

Example:
    >>> get_and_asse()
"""""""
False,"""""""
Tests the functionality of the get method on the client object.

This test case checks if the get method returns a list containing the expected value when called with the root URL (""/"").

Args:
    None

Returns:
    None

Raises:
    AssertionError: If the returned list does not match the expected output.
""""""

client.get(""/"")
assert got == [42]

""""""
Tests the functionality of threading in Python.

This test case checks if the Thread class can be instantiated correctly and if it can target a specific function.

Args:
    None

Returns:
    None

Raises:
    AssertionError: If the thread is not created successfully or if it does not target the expected function.
""""""

t = Thread(target=  # <--- Missing keyword 'self'"
False,"```
Find Package Path Function

### Overview

This function determines the path to a Python module or package based on its import name.

### Parameters

- `import_name` (str): The full import name of the module or package.

### Returns

The absolute path to the module or package.

### Raises

- `ValueError`: If the module or package is not found.
- `ImportError`: If the module or package is not installed.

### Notes

This function uses various methods to find the package path, including:

*   Checking if the module name exists in the Python path
*   Using PEP 451 loaders to get the package path
*   Getting the filename of the loader and using it to determine the package path"
True,"""""""
Returns a temporary path for modules.

This function creates a new directory at the specified `tmp_path` and prepends it to the system path using `sys.path_prepend`. The returned path is then used as the base for module imports.

Args:
    tmp_path (Path): The base path where the temporary directory will be created.
    monkeypatch (object): An object with a method to prepend the system path.

Returns:
    Path: The temporary path for modules.
"""""""
True,"""""""
Modifies the sys.prefix attribute to use a temporary path for module installation.

Args:
    modules_tmp_path (str): The temporary path where modules will be installed.
    monkeypatch (object): An object used to modify the sys module's attributes.

Returns:
    str: The original temporary path, which is not modified by this function.

Raises:
    None

Note:
    This function uses the monkeypatching technique to temporarily modify the sys.prefix attribute. It does not persist these changes across function calls.
"""""""
False,"def site_packages(modules_tmp_path, monkeypatch):
    """"""
    Creates a temporary directory for Python's site-packages.

    This function creates a new directory structure for Python's site-packages,
    prepends it to the system path, and returns the root of this new structure.
    
    Parameters:
        modules_tmp_path (Path): The base path where the temporary directory will be created.
        monkeypatch (object): An object with syspath_prepend method used to prepend the new path.

    Returns:
        Path: The root of the newly created site-packages directory.
    """""""
True,"""""""
Tests that the Flask application correctly reads configuration from a file with an unusual encoding.

Args:
    tmp_path (pathlib.Path): A temporary path for creating a test file.
    encoding (str): The encoding to use in the test file.

Returns:
    None
"""""""
True,"""""""
Tests the behavior of Flask when a module with an ImportError is passed to its constructor.

Args:
    modules_tmp_path (pathlib.Path): The temporary path where the ""importerror.py"" file will be created.

Raises:
    AssertionError: If Flask(import_name) does not raise an ImportError.
"""""""
True,"""""""
Tests the Flask application's instance path.

This function tests that a ValueError is raised when an absolute instance path
is not provided, and that the instance path can be correctly set using an
absolute path.

Args:
    modules_tmp_path (str): The temporary path to the modules.

Returns:
    None

Raises:
    ValueError: If the instance path is not absolute.
"""""""
True,"""""""
Tests the behavior of an uninstalled module by creating a temporary configuration file and purging the module.

Args:
    modules_tmp_path (Path): The path to the temporary modules directory.
    purge_module (function): A function that takes a module name as input and removes it from the system.

Returns:
    None

Raises:
    AssertionError: If the instance path of the Flask app does not match the expected value.
"""""""
True,"""""""
Tests the paths of an uninstalled package.

This function creates a temporary Flask application in the provided
`modules_tmp_path`, writes an `__init__.py` file to it, and then purges
the module. It then imports the app and asserts that its instance path
matches the expected value.

Parameters:
    modules_tmp_path (Path): The base directory for the test.
    purge_module (function): A function to remove a module from the system.

Returns:
    None

Raises:
    AssertionError: If the instance path of the app does not match the expected value.
"""""""
True,"""""""
Test that the instance path of a Flask application is correctly set when the namespace package is uninstalled.

This test creates two namespaces, one for each package being tested. It then purges the modules from these namespaces and asserts that the instance path of the second package's application is correct.

Args:
    tmp_path (pathlib.Path): A temporary directory used to create project directories.
    monkeypatch (MonkeyPatch): A MonkeyPatch object used to modify the sys.path.
    purge_module (function): A function used to purge modules from a namespace.

Returns:
    None
"""""""
False,"def create_namespace(package):
    """"""
    Creates a new namespace for the given package.

    This function creates a new directory structure for the provided package,
    including an __init__.py file that imports Flask and sets up a basic application.
    
    Args:
        package (str): The name of the package to create a namespace for.
    
    Returns:
        str: The path to the newly created project directory.
    """""""
True,"""""""
Test function to verify installed module paths.

This function tests the installation of a Flask application in a temporary directory.
It creates a `site_app.py` file with a basic Flask app, purges any existing instance,
and then asserts that the instance path matches the expected value.

Parameters:
    modules_tmp_path (str): The path to the temporary directory for module files.
    modules_tmp_path_prefix (str): The prefix for the temporary directory.
    purge_module (function): A function to purge a module from the site-packages.
    site_packages (str): The path to the site-packages directory.
    limit_loader (int): An optional parameter to limit the loader.

Returns:
    None
"""""""
True,"""""""
Test function to verify the installation of a package.

This function tests the installation of a Flask application in a temporary directory.
It creates a temporary directory, installs a Flask application, and then verifies that
the instance path is correctly set.

Parameters:
limit_loader (bool): Whether to limit the loader.
modules_tmp_path (Path): The path to the modules tmp directory.
modules_tmp_path_prefix (str): The prefix for the modules tmp path.
purge_module (str): The module to purge.
monkeypatch (object): A monkey patch object.

Returns:
None
"""""""
True,"""""""
Test prefix package paths.

This function tests the behavior of a package when its path is prefixed.
It creates a temporary directory, installs a Flask app into it, and then
purges the original module. It then imports the package again to verify that
the instance path has been correctly updated.

Parameters:
    limit_loader (bool): Whether to limit the loader.
    modules_tmp_path (Path): The path to the temporary modules directory.
    modules_tmp_path_prefix (str): The prefix for the temporary modules path.
    purge_module (str): The module to purge.
    site_packages (Path): The path to the site-packages directory.

Returns:
    None
"""""""
True,"""""""
Initialize a new instance of the class.

Parameters:
    root_path (str | os.PathLike): The root path to be used for the instance.
    defaults (dict | None, optional): Default values for the instance. Defaults to None.

Returns:
    None
"""""""
False,"def from_pyfile(self, filename: str | os.PathLike, silent: bool = False) -> bool:
    """"""
    Loads a configuration file from a Python file.

    Args:
    - filename (str | os.PathLike): The path to the configuration file.
    - silent (bool, optional): If True, returns False if the file does not exist or is not a directory. Defaults to False.

    Returns:
    - bool: Whether the configuration was loaded successfully.
    """"""
    filename = os.path.join(self.root_path, filename)
    d = types.ModuleType(""config"")
    d.__file__ = filename
    try:
        with open(filename, mode=""rb"") as config_file:
            exec(compile(config_file.read(), filename, ""exec""), d.__dict__)
    except OSError as e:
        if silent and e.errno in (errno.ENOENT, errno.EISDIR, errno.ENOTDIR):
            return False
        e.strerror = f""Unable to load configuration file ({e.strerror})""
        raise
    self.from_object(d)
    return True"
False,"def from_file(
    """"""
    Loads a configuration file into the object's mapping.

    Args:
        filename (str | os.PathLike): The path to the configuration file.
        load (t.Callable[[t.IO[t.Any]], t.Mapping]): A function that loads data from an IO object and returns a Mapping.
        silent (bool, optional): If True, suppresses error messages. Defaults to False.
        text (bool, optional): Specifies whether the file is loaded as text or binary data. Defaults to True.

    Returns:
        bool: Whether the loading was successful.
    """"""
    def load_data(file_path):
        # Load configuration from file
        pass

    return load_data(os.path.join(self.root_path, filename))"
False,"def get_root_path(import_name: str) -> str:
    """"""
    Returns the root path of the given module.

    If the module has already been imported and its file attribute is available,
    it uses that. Otherwise, it checks the loader and falls back to imports if
    necessary. If no file path can be found, it raises a RuntimeError.

    Args:
        import_name (str): The name of the module to find the root path for.

    Returns:
        str: The root path of the given module.
    """""""
False,"def _find_package_path(import_name):
    """"""
    Finds the path to a Python module or package.

    Args:
        import_name (str): The name of the module or package to find.

    Returns:
        str: The absolute path to the module or package.

    Raises:
        ValueError: If the module or package is not found.
    """"""
    # ... (rest of the code remains the same)"
True,"""""""
Returns the root path of the given module.

The function first checks if the module has already been imported and
has a file attribute. If so, it returns the directory of that file.
If not, it attempts to find the spec of the import using `importlib.util.find_spec`.
If the spec is found, it uses the loader's get_filename method to get the filepath.
If the filepath is None, it raises a RuntimeError.

Args:
    import_name (str): The name of the module to find the root path for.

Returns:
    str: The root path of the given module.

Raises:
    ValueError: If the spec is not found.
    RuntimeError: If no file path can be found for the module.
"""""""
False,"""""""
Find the path to a Python package or module.

This function takes an import name as input and returns the path to the corresponding package or module.
If the package or module is not found, it raises a ValueError. If the import fails for any reason, it falls back to the current working directory.

Parameters:
    import_name (str): The name of the package or module to find.

Returns:
    str: The path to the package or module.

Raises:
    ValueError: If the package or module is not found.
""""""

def _find_package_path(import_name):
    # ... (rest of the code remains the same)"
True, '""""""\nSends a file to the client.\n\nThis function is used to send files from the server to the client. It takes various parameters\nto customize the behavior of the file sending process. such as the MIME type. whether to send\nthe file as an attachment. and the last modified date of the file.\n\nParameters:\n- path_or_file (os.PathLike[t.AnyStr] | str | t.BinaryIO): The path or file-like object containing the data to be sent.\n- mimetype (str | None): The MIME type of the file. Defaults to None.\n- as_attachment (bool): Whether to send the file as an attachment. Defaults to False.\n- download_name (str | None): The name of the downloaded file. Defaults to None.\n- conditional (bool): Whether to check for a conditional GET request. Defaults to True.\n- etag (bool | str): Whether to include the ETag in the response headers or its value as a string. Defaults to True.\n- last_modified (datetime | int | float | None): The last modified date of the file. Defaults to None.\n- max_age (None | (int | t.Callable[[str | None]. int | None])): The maximum age of the cached response in seconds. Defaults to None.\n\nReturns:\n- Response: The HTTP response object containing the sent file data.\n""""""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
True, '""""""\nValidate the key for a given certificate.\n\nThis function checks if the provided key is valid based on the type of certificate used.\nIt raises an error if the key is not required or if it\'s used with an invalid certificate type.\n\nArgs:\n    ctx (click.Context): The context object containing the command-line arguments.\n    param (click.Parameter): The parameter being validated.\n    value: The value to be validated.\n\nReturns:\n    value: The validated key value.\n\nRaises:\n    click.BadParameter: If the key is not required or if it\'s used with an invalid certificate type.\n""""""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
False, '""""""\nStream a generator or function with context.\n\nThis function takes an iterator or callable that returns an iterator. and wraps it in a context manager. The context manager pushes the current request context onto the stack when the generator is started. and pops it off when the iteration completes.\n\nIf the input is not an iterator. but rather a callable that returns an iterator. this function will wrap the callable in a decorator to create a new function that takes any arguments and returns the wrapped iterator. The `update_wrapper` function is used to preserve the original function\'s name and docstring.\n\nThe context manager uses the `_cv_request.get(None)` method to retrieve the current request context. If no context is available. it raises a RuntimeError.\n\nThis function can only be used when a request context is active. such as in a view function.\n\nArgs:\n    generator_or_function: An iterator or callable that returns an iterator.\n\nReturns:\n    An iterator over the wrapped generator or function.\n""""""\n```'
True, '""""""\nStream a generator or function with context.\n\nThis function takes an iterator or callable that returns an iterator. and wraps it in a context manager. The context manager pushes the current request context onto the stack when the generator is started. and pops it off when the iteration completes.\n\nIf the input is not an iterator. but rather a callable that returns an iterator. this function will wrap the callable in a decorator to create a new function that takes any arguments and returns an iterator. This allows the original function to be used as if it were an iterator.\n\nThe context manager uses the `_cv_request` object to get the current request context. and pushes it onto the stack when the generator is started. When the iteration completes. the context is popped off the stack.\n\nThis function can only be used when a request context is active. such as in a view function.\n\nArgs:\n    generator_or_function: An iterator or callable that returns an iterator.\n\nReturns:\n    An iterator over the results of the input generator or function.\n""""""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
True, '""""""\nScans a dictionary or list to remove tags.\n\nThis function recursively traverses the input data structure and removes any tags present. It handles both dictionaries and lists. untagging each item within them before returning the modified data structure.\n\nArgs:\n    value (t.Any): The input data structure to be scanned for tags.\n\nReturns:\n    t.Any: The input data structure with all tags removed.\n""""""'
True, '""""""\nLoads and untags a given string.\n\nThis method takes a string as input. applies the `_untag_scan` function to it. \nand returns the result. The `_untag_scan` function is not defined in this snippet.\nbut it\'s assumed to be a part of the class instance (`self`) that this method belongs to.\n\nArgs:\n    value (str): The input string to be loaded and untagged.\n\nReturns:\n    t.Any: The result of applying `_untag_scan` to the input string.\n""""""'
False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[.... t.Iterator[t.AnyStr]].\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator. and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started.\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator. but rather a callable that returns an iterator.\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context. and pushes it onto the stack when the generator is started.\n    When the iteration completes. the context is popped off the stack.\n\n    This function can only be used when a request context is active. such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n    """"""'
True, '""""""\nMakes a response for the application.\n\nThis function takes any number of arguments. which are used to construct the response.\nIf no arguments are provided. it returns an empty response. If one argument is provided.\nit is assumed to be a single value and is returned as-is. Otherwise. all arguments\nare passed through to `current_app.make_response()`.\n\nArgs:\n    *args: Any number of values to include in the response (optional)\n\nReturns:\n    Response: The constructed response object\n\nRaises:\n    None\n""""""'
True, '""""""\nAdds a static route to the application using the provided `static_url_path`. \n`static_host`. and `static_folder`. This is done without checking if \n`static_folder` exists. as it might be created while the server is running. \n\nThis method uses a weakref to avoid creating a reference cycle between the app \nand the view function.\n\nArgs:\n    import_name (str): The name of the module being imported.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike[str] | None): The folder where static files are stored. Defaults to ""static"".\n    static_host (str | None): The host on which the static route is served. Defaults to None.\n    host_matching (bool): Whether the host should be matched. Defaults to False.\n    subdomain_matching (bool): Whether the subdomain should be matched. Defaults to False.\n    template_folder (str | os.PathLike[str] | None): The folder where templates are stored. Defaults to ""templates"".\n    instance_path (str | None): The path of the instance. Defaults to None.\n    instance_relative_config (bool): Whether the configuration is relative to the instance. Defaults to False.\n    root_path (str | None): The root path of the application. Defaults to None.\n\nRaises:\n    AssertionError: If `static_host` and `host_matching` do not match. or if \n        `static_folder` exists but `static_url_path` is not provided.\n""""""'
True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided. it will be used to retrieve the default send file max age from the application configuration.\nOtherwise. the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to retrieve the default send file max age for. If None. the default value will be returned.\n\nReturns:\n    int | None: The maximum age in seconds for sending files. or None if no default value is set.\n""""""'
True, '""""""\nRaises a routing exception if the current request is not handled by the application.\n\nIf `self.debug` is False or the request does not have a valid redirect. and the redirect\'s code is 307 or 308. or if the request method is GET. HEAD. or OPTIONS. this function raises the original routing exception. Otherwise. it returns a FormDataRoutingRedirect instance for debugging purposes.\n\nArgs:\n    request (Request): The current HTTP request.\n\nReturns:\n    t.NoReturn: This function does not return anything.\n""""""'
True, '""""""\nUpdates the template context with additional information from request blueprints and context processors.\n\nArgs:\n    context (dict[str. t.Any]): The initial template context to be updated.\n\nReturns:\n    None\n""""""'
False, 'def make_shell_context(self) -> dict[str. t.Any]:\n    """"""\n    Creates a shell context dictionary by initializing it with the application object and \n    additional data from shell context processors.\n\n    Args:\n        self: The instance of the class that owns this method.\n    \n    Returns:\n        A dictionary containing the application object and any additional data provided by \n        the shell context processors.'
True, '""""""\nHandles HTTP exceptions by checking their code and routing status.\n\nIf the exception does not have an error code (i.e.. it\'s a ProxyException).\nit returns the exception unchanged as an error. If the exception is a RoutingException.\nit also returns it unchanged. as these are internal exceptions used to trigger routing actions.\nOtherwise. it finds an error handler for the exception and calls it with the exception.\n\nArgs:\n    e (HTTPException): The HTTP exception to handle.\nReturns:\n    HTTPException | ft.ResponseReturnValue: The handled exception or a ResponseReturnValue object.\n""""""'
True, '""""""\nHandles exceptions raised by the application and returns an HTTPException or ResponseReturnValue.\n\nIf a BadRequestKeyError occurs and debug mode or the \'TRAP_BAD_REQUEST_ERRORS\' configuration option is enabled.\nthe exception\'s show_exception attribute is set to True. If an HTTPException occurs but it is not trapped.\nit is handled by the handle_http_exception method. Otherwise. the error handler for the given exception\nis found using the _find_error_handler method and its result is returned.\n\nArgs:\n    e (Exception): The exception to be handled.\nReturns:\n    HTTPException | ResponseReturnValue: The handled exception or response value.\nRaises:\n    Exception: If no error handler can be found for the exception.\n""""""'
False, 'def dispatch_request(self) -> ft.ResponseReturnValue:\n    """"""\n    Dispatches a request to the corresponding endpoint.\n\n    If automatic options are provided for the URL and the request is an OPTIONS method.\n    it returns a default options response. Otherwise. it calls the view function with\n    the provided view arguments.\n\n    :return: The response from the dispatched view function.\n    """"""'
True, '""""""\nEnsures that a provided function is synchronous.\n\nIf the function is a coroutine. it is converted to a synchronous function using `async_to_sync`. Otherwise. the original function is returned.\n\nArgs:\n    func (Callable[.... Any]): The function to be ensured as synchronous.\n\nReturns:\n    Callable[.... Any]: The synchronous version of the input function or the original function if it\'s already synchronous.\n""""""'
True, '""""""\nConverts an asynchronous function to a synchronous one.\n\nThis function takes an asynchronous function as input and returns a new function that can be called synchronously.\nIt uses the `async_to_sync` function from the `asgiref.sync` module. which is part of Flask\'s async support.\n\nIf the required `async` extra for Flask is not installed. a `RuntimeError` is raised with an error message.\n\nArgs:\n    func: The asynchronous function to be converted. It should be a coroutine that takes any number of arguments and returns any type of value.\n\nReturns:\n    A new synchronous function that can be called with the same arguments as the original asynchronous function.\n""""""'
False, 'def make_response(self. rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response object is created based on the type of the view function result.\n    If the result is a tuple. it is unpacked into body. status. and headers.\n    If the result is None. a TypeError is raised.\n    If the result is not an instance of the response class. it is converted to\n    the correct type.\n\n    Args:\n        rv: The view function result.\n\n    Returns:\n        A Response object.\n\n    Raises:\n        TypeError: If the view function did not return a valid response tuple.\n            or if the result is None.\n    """"""'
True, '""""""\nPreprocesses the request by applying URL value preprocessors and before request functions.\n\nThis method iterates over the blueprint names in reverse order. applying any URL value preprocessors to each one.\nIt then iterates over the same list again. applying any before request functions to each one. If a function returns\na non-None value. it is returned immediately. Otherwise. None is returned at the end.\n\nArgs:\n    self: The instance of the class this method belongs to.\n\nReturns:\n    ft.ResponseReturnValue | None: The result of the preprocess request. or None if no functions return a value.\n""""""'
True, '""""""\nReturns a new instance of RequestContext with the given WSGI environment.\n\nArgs:\n    environ (WSGIEnvironment): The WSGI environment to use for the context.\n\nReturns:\n    RequestContext: A new instance of RequestContext initialized with the provided environment.\n""""""'
True, '""""""\nWSGI Application Function.\n\nThis function serves as the entry point for the WSGI application. handling incoming requests and responses.\nIt takes in an environment dictionary (`environ`) and a start response callback (`start_response`). \nand returns an iterable of bytes representing the response to the request.\n\nThe function first creates a request context using `self.request_context(environ)`. which sets up the necessary\ncontext for the application. It then attempts to dispatch the request. handling any exceptions that may occur.\nIf an exception is caught. it is handled by the `handle_exception` method and the response is generated accordingly.\nFinally. the function returns the response. popping the context if no error occurred.\n\nNote: This function uses a try-except block with a bare `except` clause to catch all exceptions. \nThis is generally discouraged in favor of specific exception handling. but may be necessary for compatibility reasons.\n""""""'
True, '""""""\nCall the wsgi_app method to handle the request.\n\nArgs:\n    environ (WSGIEnvironment): The environment in which the application is running.\n    start_response (StartResponse): A callable that takes a response status code and headers as arguments.\n\nReturns:\n    cabc.Iterable[bytes]: An iterable of bytes representing the response body.\n""""""'
True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided. it will be used to retrieve the default send file max age from the application configuration.\nOtherwise. the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to retrieve the default send file max age for. If None. the default value will be returned.\n\nReturns:\n    int | None: The maximum age in seconds for sending files. or None if no default value is set.\n""""""'
False, 'def find_best_app(module: ModuleType) -> Flask:\n    """"""\n    Finds the best Flask application within a given module.\n\n    The function searches for the most common names (""app"" or ""application"") first.\n    If multiple applications are found. it raises a NoAppException with a message\n    suggesting to use the :name syntax to specify the correct one.\n\n    After searching for named applications. it looks for app factory functions.\n    If a factory function is found and can be called without arguments. it uses\n    that as the application. Otherwise. it raises a NoAppException with a message\n    suggesting to call the factory function with arguments.\n\n    If no Flask application or factory is found. it raises a NoAppException with a\n    message suggesting to use the :name syntax to specify one.\n\n    Args:\n        module (ModuleType): The module to search for the Flask application in.\n\n    Returns:\n        Flask: The best Flask application found in the module.\n\n    Raises:\n        NoAppException: If no Flask application or factory is found.\n    """"""'
True, '""""""\nChecks if a given Flask function was called with incorrect arguments.\n\nArgs:\n    f (callable): The Flask function to check.\n\nReturns:\n    bool: True if the function was not called with correct arguments. False otherwise.\n""""""'
False, '```\nFind App by String Function\n==========================\n\n### Purpose\n\nThis function finds an application within a given module based on the provided string.\n\n### Parameters\n\n*   `module`: The module to search for the application.\n*   `app_name`: The name of the application to find.\n\n### Returns\n\nA Flask application object if found. otherwise raises a NoAppException.\n\n### Raises\n\n*   NoAppException: If the application cannot be found or parsed as an attribute name or function call.\n\n### Notes\n\nThis function uses the ast module for parsing and inspect module for checking function types. It also uses getattr to get the attribute from the module and isinstance to check if the attribute is a Flask application object.\n```'
True, '""""""\nPrepares the import path for a Python module.\n\nThis function takes a file path as input and returns the relative import path\nfor the corresponding module. It handles cases where the input path is within\na package structure. and adjusts the sys.path accordingly.\n\nArgs:\n    path (str): The absolute or relative path to the Python module.\n\nReturns:\n    str: The relative import path for the module.\n""""""'
True, '""""""\nLocate an application within a given Flask module.\n\nThis function takes in the name of the module and the application to locate.\nas well as an optional parameter to raise an exception if the application is not found.\n\nArgs:\n    - `module_name` (str): The name of the module to search for.\n    - `app_name` (str | None): The name of the application to locate. If None. all applications will be returned.\n    - `raise_if_not_found` (bool. optional): Whether to raise an exception if the application is not found. Defaults to True.\n\nReturns:\n    Flask: The located Flask application object.\n\nRaises:\n    ValueError: If `app_name` is not provided and `raise_if_not_found` is False.\n""""""'
True, '""""""\nLocate an application within a given module.\n\nThis function searches for an application with the specified name within a given module.\nIt returns the found application or `None` if not found. If `raise_if_not_found` is set to `True`. it raises a `ValueError` if the application is not found.\n\nArgs:\n    - **module_name** (str): The name of the module to search in.\n    - **app_name** (str | None): The name of the application to locate. If `None`. all applications will be returned.\n    - **raise_if_not_found** (bool. optional): Whether to raise an error if the application is not found. Defaults to `False`.\n\nReturns:\n    - Flask | None: The located application or `None` if not found.\n\nRaises:\n    ValueError: If `raise_if_not_found` is set to `True` and the application is not found.\n""""""'
True, '""""""\nLocate an application within a given module.\n\nThis function attempts to import the specified module and then searches for\nthe requested application. If the application is not found. it will raise a\n`NoAppException`.\n\nArgs:\n    - `module_name`: The name of the module to search in.\n    - `app_name`: The name of the application to locate (optional).\n    - `raise_if_not_found`: Whether to raise an exception if the application\n        is not found. Defaults to True.\n\nReturns:\n    - The located Flask application. or None if no application was found.\n""""""'
True, '""""""\nReturns the version information of Python. Flask. and Werkzeug.\n\nThis function is used to display the versions of these dependencies when running a Click command.\nIt checks if the value provided is valid (i.e.. not empty) or if resilient parsing is enabled.\nin which case it returns without displaying any output. Otherwise. it prints the version information\nto the console using `click.echo` and then exits the application with `ctx.exit()`.\n\nArgs:\n    ctx (click.Context): The Click context object.\n    param (click.Parameter): The parameter being processed.\n    value (t.Any): The value provided by the user.\n\nReturns:\n    None\n""""""'
True, '""""""\nLoads a Flask application instance.\n\nThis method attempts to load an existing Flask application from the `self._loaded_app` attribute.\nor creates a new one if none exists. It also sets the debug flag of the loaded application\nif `self.set_debug_flag` is True.\n\nIf no application can be found. it raises a `NoAppException`.\n\nReturns:\n    Flask: The loaded or created Flask application instance.\n""""""'
True, '""""""\nDecorates a function to run with the application context.\n\nThis decorator is used to ensure that functions decorated with it are executed within\nthe application\'s context. This can be useful for tasks such as database operations.\nfile I/O. or any other operation that requires access to the current application state.\n\nThe `with_appcontext` function takes a function `f` as an argument and returns the result of\ninvoking `f` with the application context. If the application context is not already set.\nit will load the application from the `ScriptInfo` object associated with the click context.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function. wrapped in a decorator that runs it with the application context.\n""""""'
True, '""""""\nDecorates a function with the necessary context.\n\nThis decorator loads the application context and ensures that it is available for the decorated function.\nIf the current application context is not set. it loads the script info from the click context and switches to its app context.\n\nArgs:\n    ctx (click.Context): The click context object.\n    /: Ignored positional argument.\n    *args (t.Any): Variable number of non-keyword arguments.\n    **kwargs (t.Any): Variable number of keyword arguments.\n\nReturns:\n    t.Any: The result of the decorated function invocation.\n""""""'
False, '""""""\nDecorates a function to create a Click command.\n\nThis decorator wraps the provided function in a Click command. It allows for optional wrapping of the function with an application context.\n\nArgs:\n    f (callable): The function to be decorated as a Click command.\n\nReturns:\n    click.Command: A Click command instance wrapped around the provided function.\n""""""\ndef command(*args: t.Any. **kwargs: t.Any) -> t.Callable[[t.Callable[.... t.Any]]. click.Command]:\n    wrap_for_ctx = kwargs.pop(""with_appcontext"". True)\n\n    def decorator(f: t.Callable[.... t.Any]) -> click.Command:\n        if wrap_for_ctx:\n            f = with_appcontext(f)\n        return super(AppGroup. self).command(*args. **kwargs)(f)  # type: ignore[no-any-return]\n\n    return decorator'
True, '""""""\nDecorates a function to create a Click command.\n\nThis decorator wraps the provided function in an AppGroup context if `wrap_for_ctx` is True.\nIt then calls the `super()` method on the AppGroup class. passing the original function as an argument.\nand returns the result of this call. The `# type: ignore[no-any-return]` comment suppresses a type check warning.\n\nArgs:\n    f (t.Callable[.... t.Any]): The function to be decorated.\n\nReturns:\n    click.Command: The decorated Click command.\n""""""'
False, 'def group(\n    """"""\n    Creates a new instance of the `click.Group` class.\n\n    This method is overridden to set the default value for the \'cls\' keyword argument\n    to `AppGroup`. which is assumed to be a subclass of `click.Group`.\n\n    Args:\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Returns:\n        A new instance of the `click.Group` class. or a callable that returns one.\n    """"""\n) -> t.Callable[[t.Callable[.... t.Any]]. click.Group]:\n    kwargs.setdefault(""cls"". AppGroup)\n    return super().group(*args. **kwargs)  # type: ignore[no-any-return]'
True, '""""""\nLoads plugin commands from the `importlib.metadata` module.\n\nThis method checks if plugin commands have already been loaded and returns early.\nIf the Python version is 3.10 or higher. it uses the `metadata` function from `importlib`.\nOtherwise. it uses a backport of `importlib_metadata` for consistency with earlier versions.\nIt then iterates over the entry points in the ""flask.commands"" group and adds each command to the instance\'s commands.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the specified command from the application\'s CLI.\n\nIf the command is found in the built-in commands or plugin commands.\nit returns that command. Otherwise. it attempts to load the\napplication and retrieve the command from its CLI.\n\nIf the application fails to load. an error message is displayed\nand `None` is returned.\n\nArgs:\n    ctx (click.Context): The context of the current command.\n    name (str): The name of the command to retrieve.\n\nReturns:\n    click.Command | None: The specified command or `None` if not found.\n""""""'
True, '""""""\nLists all available commands for a given context.\n\nThis function extends the base command listing functionality by also including\ncommands provided by plugins and apps. If an app couldn\'t be loaded. it will\ndisplay an error message without the traceback. Any other errors during loading\nwill display the full traceback.\n\nArgs:\n    ctx (click.Context): The context in which to list commands.\n\nReturns:\n    list[str]: A sorted list of all available commands.\n""""""'
False, '""""""\nReturns True if `other` is an ancestor of `path`. False otherwise.\n\nThis function checks if the path `other` is a prefix of `path`. It does this by joining `path` and `other` with the appropriate separator. then comparing the result to `other`.\n\nArgs:\n    path (str): The base path.\n    other (str): The potential ancestor path.\n\nReturns:\n    bool: True if `other` is an ancestor of `path`. False otherwise.'
True, '""""""\nLoads environment variables from a .env or .flaskenv file.\n\nIf no specific path is provided. it will attempt to load the default files\nin the current working directory. If neither a specific path nor default\nfiles are found. it will print a tip message suggesting installing python-dotenv.\n\nArgs:\n    path (str | os.PathLike[str] | None): The path to the .env or .flaskenv file.\n        If None. it will attempt to load the default files in the current working directory.\n\nReturns:\n    bool: True if at least one file was located and loaded. False otherwise.\n""""""'
True, '""""""\nShow server banner based on debug mode and application import path.\n\nThis function displays a banner indicating whether the application is being served\nand. if so. its import path. It also indicates whether debug mode is enabled.\n\nArgs:\n    - debug (bool): Whether to display debug mode information.\n    - app_import_path (str | None): The path to the imported Flask application.\n\nReturns:\n    None\n""""""'
True, '""""""\nInitialize a new instance of the class.\n\nThis method initializes an empty instance with a path type attribute.\nThe path type is set to require an existing file path that cannot be a directory.\nand will attempt to resolve the path if possible.\n\nAttributes:\n    path_type (click.Path): The path type attribute of this instance.\n""""""'
True, '""""""\nConverts a given value to its corresponding type.\n\nThis function attempts to convert the provided `value` into its respective type.\nIf the conversion fails. it tries to parse the `value` as a string and then checks if it\'s an ad-hoc certificate or an SSL context.\n\nArgs:\n    self: The instance of the class that this method belongs to.\n    value (t.Any): The value to be converted.\n    param (click.Parameter | None): The parameter associated with the conversion.\n    ctx (click.Context | None): The context in which the conversion is taking place.\n\nReturns:\n    t.Any: The converted value.\n\nRaises:\n    click.BadParameter: If the conversion fails or if a required library is not installed.\n""""""'
True, '""""""\nValidate the key for a given certificate.\n\nThis function checks if the provided key is valid based on the type of certificate used.\nIt raises an error if the key is not required or if it\'s used with an invalid certificate type.\n\nArgs:\n    ctx (click.Context): The context object containing the command-line arguments.\n    param (click.Parameter): The parameter being validated.\n    value: The value to be validated.\n\nReturns:\n    value: The validated key value.\n\nRaises:\n    click.BadParameter: If the key is not required or if it\'s used with an invalid certificate type.\n""""""'
False, 'def convert(self. value: t.Any. param: click.Parameter | None. ctx: click.Context | None) -> t.Any:\n    """"""\n    Converts a given environment variable value into a list of converted values.\n\n    This method splits the input value by the environment variable separator and then\n    converts each resulting item using the parent class\'s convert method.\n\n    Args:\n        value (t.Any): The environment variable value to be converted.\n        param (click.Parameter | None): The parameter object associated with this command.\n        ctx (click.Context | None): The context object for this command invocation.\n\n    Returns:\n        t.Any: A list of converted values.\n    """"""'
False, 'def run_command(\n    """"""\n    Runs a command with the specified configuration.\n\n    Parameters:\n    - info (ScriptInfo): Information about the script to be executed.\n    - host (str): The hostname or IP address of the server.\n    - port (int): The port number of the server.\n    - reload (bool): Whether to enable reloading. If None. uses the debug flag.\n    - debugger (bool): Whether to enable debugging. If None. uses the debug flag.\n    - with_threads (bool): Whether to run in threaded mode.\n    - cert (ssl.SSLContext | tuple[str. str | None] | t.Literal[""adhoc""] | None): The SSL context or certificate information.\n    - extra_files (list[str] | None): A list of additional files to include.\n    - exclude_patterns (list[str] | None): A list of patterns to exclude.\n\n    Returns:\n    None\n    """"""\n    try:\n        app: WSGIApplication = info.load_app()\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading. print out the error immediately. but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(\n                environ: WSGIEnvironment. start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None\n\n        else:\n            # When not reloading. raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug. info.app_import_path)\n\n    run_simple(\n        host.\n        port.\n        app.\n        use_reloader=reload.\n        use_debugger=debugger.\n        threaded=with_threads.\n        ssl_context=cert.\n        extra_files=extra_files.\n        exclude_patterns=exclude_patterns.\n    )'
True, '""""""\nWSGI Application Function.\n\nThis function serves as the entry point for a web application. It takes in an environment object and a response object.\nand returns an iterable of bytes.\n\nRaises:\n    err: An exception to be raised when the application is unable to handle the request.\n""""""'
True, '""""""\nRun a Python shell with customized banner and interactive hook.\n\nThis function sets up a Python shell with a custom banner displaying the\nPython version. platform. application name. and instance path. It also\nsupports setting an interactive hook to customize the readline experience.\nsuch as tab completion.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nInitialize a new instance of the class.\n\nArgs:\n    - **name (str)**: The name of the converter.\n    - **get_converter (t.Callable[[t.Any]. T] | None. optional)**: A function that converts any type to the target type. Defaults to None.\n\nReturns:\n    None\n""""""'
False, '""""""\nGets an attribute from the instance.\n\nThis method is a special method in Python classes that allows you to define getter methods for attributes. It takes three parameters:\n\n- `self`: The instance of the class.\n- `obj`: The object being accessed (usually the instance itself).\n- `owner`: The owner of the attribute (not used in this implementation).\n\nReturns an instance of `te.Self` representing the attribute value.\n\nNote:\n    This method is typically used as a property decorator to define getter methods for attributes.'
True, '""""""\nGets an attribute from an instance of the class.\n\nThis method is used to implement property access in Python. It allows you to define a getter function for a property and use it with the `@property` decorator.\n\nArgs:\n    self (object): The instance of the class.\n    obj (App. optional): The object that owns this attribute. Defaults to None.\n    owner (type[App]. optional): The type of the App class. Defaults to None.\n\nReturns:\n    T: The value of the attribute.\n""""""'
True, '""""""\nGets the configuration value for this descriptor.\n\nIf `obj` is provided. it must be an instance of `App`. The method returns\nthe configuration value associated with the name of this descriptor. If a\nconverter function is set on this descriptor. it will be applied to the\nconfiguration value before being returned.\n\nArgs:\n    obj: An instance of App (optional)\n    owner: The type of the App instance (optional)\n\nReturns:\n    T | te.Self: The configuration value or self if no object was provided.\n""""""'
True, '""""""\nSets a configuration attribute on an object.\n\nThis method is used to set a configuration attribute on an object. The attribute name is determined by the `__name__` attribute of the current instance. and its value is stored in the `config` dictionary of the object\'s parent class (`App`). \n\nArgs:\n    obj (App): The object that owns this configuration attribute.\n    value (t.Any): The new value for the configuration attribute.\n\nReturns:\n    None\n""""""'
True, '""""""\nInitialize the documentation assistant.\n\n### Parameters\n\n- **root_path**: The root path of the documentation. Can be a string or an os.PathLike object.\n- **defaults**: An optional dictionary of default values to use for initialization. Defaults to None.\n\n### Returns\n\nNone\n""""""'
True, '""""""\nLoads a configuration from a Python file.\n\nThis function reads the contents of a specified Python file. executes it as a module.\nand then calls `from_object` on the resulting object. If the file does not exist or\ncannot be executed for some reason. an error is raised.\n\nArgs:\n    filename (str | os.PathLike[str]): The path to the configuration file.\n    silent (bool): If True returns False if the file cannot be loaded without raising an exception. Defaults to False.\n\nReturns:\n    bool: Whether the configuration was successfully loaded.\n""""""'
True, '""""""\nLoads a configuration file from disk.\n\nThis method attempts to open the specified file and load its contents using the provided\n`load` function. If successful. it returns `True`. Otherwise. it raises an exception with a\ncustomized error message if silent mode is enabled or returns `False`.\n\nArgs:\n    filename (str | os.PathLike[str]): The path to the configuration file.\n    load (t.Callable[[t.IO[t.Any]]. t.Mapping[str. t.Any]]): A function that takes an IO object and returns a mapping of key-value pairs.\n    silent (bool. optional): If True exceptions are caught silently. Defaults to False.\n    text (bool. optional): Specifies whether the file should be opened in text mode True) or binary mode (False). Defaults to True.\n\nReturns:\n    bool: Whether the configuration was loaded successfully.\nRaises:\n    OSError: If an error occurs while loading the configuration file.\n""""""'
True, '""""""\nReturns a decorator that appends the provided callable to the list of functions \nto be executed after the current request has been completed.\n\nArgs:\n    f (ft.AfterRequestCallable[t.Any]): The callable to be appended to the list.\n\nReturns:\n    ft.AfterRequestCallable[t.Any]: The decorated function.\nRaises:\n    RuntimeError: If no request context is active. indicating that \'after_this_request\' \n                  can only be used when a request context is active. such as in a view function.\n""""""'
False, 'def copy_current_request_context(f: F) -> F:\n    """"""\n    Copies the current request context to a new context.\n\n    This function is used in view functions to ensure that the request context\n    is preserved across multiple calls. It raises an error if no request context\n    is active. as required by the WSGI specification.\n\n    Args:\n        f: The function to decorate with the copied request context.\n\n    Returns:\n        A new version of the input function with the copied request context.\n    """"""'
False, '""""""\nWrapper function to ensure synchronous execution of the application.\n\nThis function takes in variable arguments and keyword arguments. \nand returns the result of the application\'s `ensure_sync` method.\n\nArgs:\n    *args (t.Any): Variable positional arguments.\n    **kwargs (t.Any): Variable keyword arguments.\n\nReturns:\n    t.Any: The result of the application\'s `ensure_sync` method.\n""""""\ndef wrapper(*args: t.Any. **kwargs: t.Any) -> t.Any:\n    with ctx:  # type: ignore[union-attr]\n        return ctx.app.ensure_sync(f)(*args. **kwargs)  # type: ignore[union-attr]'
True, '""""""\nInitializes the documentation assistant with a Flask application instance.\n\nArgs:\n    app (Flask): The Flask application instance to be used for URL adaptation and context management.\n\nReturns:\n    None\n""""""'
True, '""""""\nInitialize a new instance of the class.\n\nThis method is called when an object of this class is instantiated. It takes in several parameters:\n\n- `app`: The Flask application instance.\n- `environ`: The WSGI environment.\n- `request`: An optional request object. defaults to None.\n- `session`: An optional session mixin object. defaults to None.\n\nThe method initializes the internal state of the class by setting up the request object and creating a URL adapter if possible. It also sets up the flash messages and session objects.\n\nAfter initialization. any functions that should be executed after the request on the response object can be added to the `_after_request_functions` list.\n\nParameters:\napp (Flask): The Flask application instance.\nenviron (WSGIEnvironment): The WSGI environment.\nrequest (Request | None): An optional request object. Defaults to None.\nsession (SessionMixin | None): An optional session mixin object. Defaults to None.\n\nReturns:\nNone\n""""""'
False, '""""""\nInitialize the documentation assistant.\n\nThis function is called when an instance of the class is created.\nIt takes in a request object and a key as parameters. \nand sets up the necessary data for the class to function correctly.\n\nParameters:\n    request (Request): The HTTP request object containing information about the incoming request.\n    key (str): The key associated with the file being accessed.\n\nReturns:\n    None\n""""""\ndef __init__(self. request: Request. key: str) -> None:'
False, '""""""\nReturns a string representation of the object.\n\nThis method is used to provide a human-readable representation of the object.\nIt should be overridden by subclasses to provide a meaningful string value.\n\nArgs:\n    None\n\nReturns:\n    str: A string representation of the object\'s message.'
True, '""""""\nRaises a custom exception when a request is redirected by the router.\n\nThis exception is raised when a request is sent to a URL that is\nredirected by the router. but the redirect was not properly configured.\nThe exception provides information about the original and canonical URLs.\nas well as guidance on how to configure routing redirects correctly.\n\nIn debug mode only. In production mode. this exception will be caught\nand handled by Flask\'s default error handling mechanism.\n\nParameters:\n    request (Request): The original request that caused the redirect.\n\nReturns:\n    None\n\nRaises:\n    RequestRedirect: A custom exception with information about the redirect.\n""""""'
True, '""""""\nReplaces the default behavior of Django\'s `request.files` with a multidict-based implementation.\n\nWhen an error occurs while accessing a file. it will be raised as a `DebugFilesKeyError` instead of raising a `KeyError`. This allows for additional debugging information to be provided.\n\nThis function is intended to be used in conjunction with the `django.http.HttpRequest` class. It should not be called directly by external code.\n\nArgs:\n    request (HttpRequest): The HTTP request object.\n\nReturns:\n    None\n""""""'
True, '""""""\nRaises a `DebugFilesKeyError` exception when the provided key is not found in the request form.\nIf the key is present but raises a KeyError. it will be re-raised with additional context.\n\nArgs:\n    key (str): The key to look up in the request form.\n\nReturns:\n    t.Any: The value associated with the key if found. otherwise raises an exception.\n\nRaises:\n    DebugFilesKeyError: If the key is not found in the request form.\n    KeyError: If the key is present but raises a KeyError.\n""""""'
True, '""""""\nYields a formatted string representation of the loader\'s class and attributes.\n\nThis function takes a `BaseLoader` object as input and returns an iterator over strings.\nEach string represents either a class or attribute of the loader. with indentation used to denote nested values.\n\nThe yielded strings are formatted according to the following rules:\n- Class information is represented as ""class: <module>.<class_name>"".\n- Attribute values that are tuples or lists are indented and separated by hyphens (e.g. ""key: value1 - value2"").\n- Attribute values that are not strings. integers. floats. or booleans are skipped.\n\nArgs:\n    loader (BaseLoader): The loader object to generate documentation for.\n\nYields:\n    str: A formatted string representation of the loader\'s class and attributes.\n""""""'
False, 'def explain_template_loading_attempts(\n    app: App.\n    template: str.\n    attempts: list[\n        tuple[\n            BaseLoader.\n            Scaffold.\n            tuple[str. str | None. t.Callable[[]. bool] | None] | None.\n        ]\n    ].\n) -> None:\n    """"""\n    Logs the process of loading a template in an application.\n\n    This function takes an application object. a template name. and a list of\n    attempts to load the template. It logs each attempt\'s details. including any\n    matches found or errors encountered.\n\n    Args:\n        app: The application object.\n        template: The name of the template to be loaded.\n        attempts: A list of tuples containing the loader. source object. and triple\n            (match detail) for each attempt.\n\n    Returns:\n        None\n    """"""\n    info = [f""Locating template {template!r}:""]\n    total_found = 0\n    blueprint = None\n\n    if request_ctx and request_ctx.request.blueprint is not None:\n        blueprint = request_ctx.request.blueprint\n\n    for idx. (loader. srcobj. triple) in enumerate(attempts):\n        if isinstance(srcobj. App):\n            src_info = f""application {srcobj.import_name!r}""\n        elif isinstance(srcobj. Blueprint):\n            src_info = f""blueprint {srcobj.name!r} ({srcobj.import_name})""\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f""{idx + 1:5}: trying loader of {src_info}"")\n\n        for line in _dump_loader_info(loader):\n            info.append(f""       {line}"")\n\n        if triple is None:\n            detail = ""no match""\n        else:\n            detail = f""found ({triple[1] or \'<string>\'!r})""\n            total_found += 1\n        info.append(f""       -> {detail}"")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(""Error: the template could not be found."")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(""Warning: multiple loaders returned a match for the template."")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            ""  The template was looked up from an endpoint that belongs""\n            f"" to the blueprint {blueprint!r}.""\n        )\n        info.append(""  Maybe you did not place a template in the right folder?"")\n        info.append(""  See https://flask.palletsprojects.com/blueprints/#templates"")\n\n    app.logger.info(""\\n"".join(info))'
False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[.... t.Iterator[t.AnyStr]]\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator. and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started.\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator. but rather a callable that returns an iterator.\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context. and pushes it onto the stack when the generator is started.\n    When the iteration completes. the context is popped off the stack.\n\n    This function can only be used when a request context is active. such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n    """"""'
True, '""""""\nDecorates a function or generator with the `stream_with_context` function from the `itertools` module.\n\nArgs:\n    *args (t.Any): Variable number of positional arguments to be passed to the decorated function or generator.\n    **kwargs (t.Any): Variable number of keyword arguments to be passed to the decorated function or generator.\n\nReturns:\n    t.Any: The result of applying the `stream_with_context` function to the provided function or generator.\n\nNote:\n    This decorator is used to convert a function or generator into an iterator that can be used with the `stream_with_context` function.\n""""""'
False, '""""""\nGenerates a generator iterator with a dummy sentinel and cleanup logic.\n\nRaises a RuntimeError if \'stream_with_context\' is used without an active request context.\n\nYields:\n    t.AnyStr | None: A dummy sentinel value or None.\n""""""\ndef generator() -> t.Iterator[t.AnyStr | None]:'
False, 'def send_from_directory(\n    """"""\n    Sends a file from the specified directory.\n\n    Args:\n        directory (os.PathLike[str] | str): The path to the directory containing the file.\n        path (os.PathLike[str] | str): The path to the file within the directory.\n        **kwargs: Additional keyword arguments to be passed to werkzeug.utils.send_from_directory.\n\n    Returns:\n        Response: A response object containing the sent file.\n\n    Raises:\n        ValueError: If the provided directory or path is invalid.\n    """"""\n    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n        directory. path. **_prepare_send_file_kwargs(**kwargs)\n    )'
True, '""""""\nReturns the root path of the given imported module.\n\nIf the module has already been imported and its file attribute is available.\nits directory path is returned. Otherwise. it attempts to find the loader\nassociated with the import specification and uses it to determine the root\npath. If this fails. it falls back to using the current working directory.\n\nArgs:\n    import_name (str): The name of the module for which to retrieve the root path.\n\nReturns:\n    str: The root path of the given imported module.\nRaises:\n    ValueError: If the loader is not found or if the module specification is None.\n    RuntimeError: If no root path can be found for a namespace package.\n""""""'
True, '""""""\nReturns a JSON response.\n\nThis function takes in any number of positional arguments and keyword arguments.\nwhich are then passed to the `json` method of the current application instance.\nThe result is a JSON response object.\n\nArgs:\n    *args (t.Any): Any positional arguments to be included in the response.\n    **kwargs (t.Any): Any keyword arguments to be included in the response.\n\nReturns:\n    Response: A JSON response object.\n""""""'
False, '""""""\nInitializes the object with a reference to an application instance.\n\nArgs:\n    app (App): The application instance to be referenced.\n\nReturns:\n    None\n""""""\ndef __init__(self. app: App) -> None:\n    """"""\n    Initializes the object with a weak reference to the provided application instance.\n    \n    This allows for efficient garbage collection of the original application instance.\n    while still maintaining access to its attributes through this proxy object.\n    """"""\n    self._app: App = weakref.proxy(app)'
True, '""""""\nConverts a given value to JSON format and returns it as a dictionary.\n\nArgs:\n    value (t.Any): The value to be converted to JSON format.\n\nReturns:\n    dict[str. t.Any]: A dictionary containing the key-value pair where the key is \'tag\' and the value is the JSON representation of the input value.\n""""""'
True, '""""""\nRegisters a new JSON tag or inserts an existing one at the specified position in the order list.\n\nArgs:\n    - `tag_class`: The class of the JSON tag to be registered.\n    - `force` (optional): If True forces registration even if the key already exists. Defaults to False.\n    - `index` (optional): The index at which to insert the tag. If None. appends to the end of the order list.\n\nRaises:\n    KeyError: If the key is already registered and force is False.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the first matching tag from the order list.\n\nIf a match is found. it returns the corresponding tag\'s value. Otherwise. it returns the original input value.\n\nArgs:\n    value (t.Any): The input value to be checked against the tags.\n\nReturns:\n    t.Any: The matched tag\'s value or the original input value.\n""""""'
False, '""""""\nReturns a TextIO object that can be used to stream WSGI error messages.\n\nIf the `request` object is available. it returns the `wsgi.errors` attribute of the request environment.\nOtherwise. it falls back to printing to the standard error stream (`sys.stderr`). \n\nThis function is intended for use in web frameworks that support WSGI. such as Django or Pyramid.'
False, '""""""\nInitializes a new Flask application instance.\n\nThis function is used to create a new Flask application. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.8\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration.\n\nThis function is used to create a new Flask application with custom configuration. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 2.2\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration and blueprint registration.\n\nThis function is used to create a new Flask application with custom configuration and blueprint registration. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration and blueprint registration. and sets up extensions.\n\nThis function is used to create a new Flask application with custom configuration and blueprint registration. and sets up extensions. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. and extension setup.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. and extension setup. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. and Click group name.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. and Click group name. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.7\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. and shell context processor functions.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. and shell context processor functions. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. and teardown appcontext functions.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. and teardown appcontext functions. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. and URL map.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. and URL map. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. and extensions.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. and extensions. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. and JSON provider.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. and JSON provider. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. and aborter.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. and aborter. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. and Click group name.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. and Click group name. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. and template folder path.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. and template folder path. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. and static folder path.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. and static folder path. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. static folder path. and import name.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. static folder path. and import name. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. static folder path. import name. and config.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. static folder path. import name. and config. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'s not absolute.\n\nIt also initializes several attributes. including:\n\n- `instance_path`: The path to the instance folder.\n- `config`: A configuration dictionary that can be used to load a config from files.\n- `aborter`: An aborter object that is called by `flask.abort` to raise HTTP errors.\n- `json`: A JSON provider object that provides access to JSON methods.\n- `url_build_error_handlers`: A list of functions that are called when the application context is destroyed.\n- `teardown_appcontext_funcs`: A list of shell context processor functions that should be run when a shell context is created.\n- `shell_context_processors`: A list of blueprint names mapped to blueprint objects.\n- `blueprints`: A dictionary that maps registered blueprint names to blueprint objects.\n- `extensions`: A dictionary where extensions can store application-specific state.\n- `url_map`: The URL map for this instance.\n\nThe default provider class is the `DefaultJSONProvider` which uses Python\'s built-in JSON library. The default aborter class is the `Aborter` class which raises HTTP errors.\n\n.. versionadded:: 0.9\n""""""\n\n""""""\nInitializes a new Flask application instance with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. static folder path. import name. config. and config_overrides.\n\nThis function is used to create a new Flask application with custom configuration. blueprint registration. extension setup. Click group name. shell context processor functions. teardown appcontext functions. URL map. extensions. JSON provider. aborter. Click group name. template folder path. static folder path. import name. config. and config_overrides. It takes several keyword arguments that define various aspects of the application. such as its import name. static folder path. and template folder path.\n\nThe `__init__` method initializes the Flask application by calling the parent class\'s `__init__` method with some default values. Then it checks if an instance path is provided and sets it to a default value or raises an error if it\'t'
True, '""""""\nReturns the name of the current module or \'main\' if running directly.\n\nIf running directly. attempts to retrieve the filename from sys.modules[\'__main__\'].\nIf not found. returns \'__main__\'. Otherwise. returns the base filename without extension.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the current module or \'main\'.\n""""""'
True, '""""""\nReturns whether the debug mode is enabled based on the configuration.\n\nArgs:\n    None\n\nReturns:\n    bool: True if debug mode is enabled. False otherwise\n""""""'
False, 'def add_url_rule(\n    rule: str.\n    endpoint: str | None = None.\n    view_func: ft.RouteCallable | None = None.\n    provide_automatic_options: bool | None = None.\n    **options: t.Any.\n) -> None:\n    """"""\n    Adds a URL rule to the application\'s URL map.\n\n    This function is used to register routes for an application. It takes\n    several parameters. including the route rule. endpoint. view function.\n    and options. The endpoint and view function are optional and can be\n    specified if they are already defined elsewhere in the code.\n\n    Args:\n        rule (str): The URL rule to add.\n        endpoint (str | None): The endpoint for this rule. Defaults to None.\n        view_func (ft.RouteCallable | None): The view function for this rule. Defaults to None.\n        provide_automatic_options (bool | None): Whether to automatically\n            include OPTIONS in the route. Defaults to None.\n        **options: t.Any: Additional options for the route.\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: If the methods are not a list of strings.\n        AssertionError: If the view function mapping is overwriting an existing endpoint function.\n    """"""'
True, '""""""\nInjects URL defaults into the provided endpoint.\n\nThis function is used to inject default values from a dictionary into an endpoint.\nIt can be called outside of a request context and will parse the passed endpoint\nto determine which blueprint it belongs to. It then calls the specified functions\nfor each name in the parsed path. passing the endpoint and values as arguments.\n\nArgs:\n    endpoint (str): The URL endpoint to inject defaults into.\n    values (dict[str. t.Any]): A dictionary of default values to inject.\n\nReturns:\n    None\n\nRaises:\n    ValueError: If the endpoint is not a valid URL.\n""""""'
True, '""""""\nAdds a URL rule to the application.\n\nParameters:\n    rule (str): The URL pattern.\n    endpoint (str | None. optional): The endpoint name. Defaults to None.\n    view_func (ft.RouteCallable | None. optional): The view function. Defaults to None.\n    **options (t.Any): Additional options for the URL rule.\n\nReturns:\n    None\n""""""'
True, '""""""\nInitialize a new instance of the class.\n\nParameters:\n    name (str): The name of the application or module.\n    import_name (str): The import name of the application or module.\n    static_folder (str | os.PathLike[str] | None. optional): The path to the static folder. Defaults to None.\n    static_url_path (str | None. optional): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike[str] | None. optional): The path to the template folder. Defaults to None.\n    url_prefix (str | None. optional): The prefix for URLs. Defaults to None.\n    subdomain (str | None. optional): The subdomain for URLs. Defaults to None.\n    url_defaults (dict[str. t.Any] | None. optional): Default values for URL parameters. Defaults to None.\n    root_path (str | None. optional): The path of the application or module. Defaults to None.\n    cli_group (str | None. optional): The CLI group name. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the application or module.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for URLs.\n    deferred_functions (list[DeferredSetupFunction]): A list of deferred functions.\n    url_values_defaults (dict[str. t.Any]): Default values for URL parameters.\n    cli_group (str): The CLI group name.\n    _blueprints (list[tuple[Blueprint. dict[str. t.Any]]]): A list of blueprints and their configurations.\n\n""""""'
False, '""""""\nRecords a deferred setup function.\n\nArgs:\n    func (DeferredSetupFunction): The deferred setup function to be recorded.\n\nReturns:\n    None\n""""""\ndef record(self. func: DeferredSetupFunction) -> None:\n    """"""\n    Records a deferred setup function.\n\n    Args:\n        func (DeferredSetupFunction): The deferred setup function to be recorded.\n    """"""\n    self.deferred_functions.append(func)'
True, '""""""\nRecords a function to be executed once during the setup process.\n\nThis method is used to register a function that should only be executed once.\nduring the initial setup of the application. The function is wrapped in a\ndecorator to ensure it\'s only called once. even if the blueprint is reloaded.\n\nArgs:\n    func (DeferredSetupFunction): The function to be recorded and executed.\n    \nReturns:\n    None\n""""""'
False, 'def make_setup_state(app: App. options: dict[str. t.Any]. first_registration: bool = False) -> BlueprintSetupState:\n    """"""\n    Creates a new setup state for the given application.\n\n    Args:\n    - app (App): The application instance.\n    - options (dict[str. t.Any]): A dictionary of options to be used in the setup state.\n    - first_registration (bool. optional): Whether this is the first registration. Defaults to False.\n\n    Returns:\n    - BlueprintSetupState: The newly created setup state.\n    """"""'
False, ""```\n## register\n\nRegisters the current object as a blueprint in the provided application.\n\n### Parameters:\n\n- `app`: The Flask application instance to register with.\n- `options`: A dictionary of options for the registration process. Can include:\n  - `name_prefix`: An optional prefix for the blueprint name (default: empty string).\n  - `name`: An optional override for the blueprint name. which takes precedence over `name_prefix` (default: current object's name).\n\n### Returns:\n\nNone\n\n### Raises:\n\n- `ValueError`: If a blueprint with the same name already exists in the application.\n\n### Notes:\n\nThis method registers the current object as a blueprint in the provided Flask application. It checks for existing blueprints with the same name and raises an error if one is found. The registration process also updates the application's state and adds any necessary URL rules or commands to the CLI.""
True, '""""""\nMerges blueprint functions into the application\'s configuration.\n\nThis function merges the provided blueprint functions (`bp_dict`) into the\napplication\'s configuration. It updates the `error_handler_spec`. `view_functions`.\n`before_request_funcs`. `after_request_funcs`. `teardown_request_funcs`. `url_default_functions`.\n`url_value_preprocessors`. and `template_context_processors` dictionaries with the merged values.\n\nArgs:\n    app (App): The application instance.\n    name (str): The blueprint name to merge functions under.\n\nReturns:\n    None\n""""""'
True, '""""""\nExtends the `parent_dict` with the items from `bp_dict`. \noverwriting any existing keys.\n\nArgs:\n    - **bp_dict**: A dictionary mapping blueprint or app keys to lists of values.\n    - **parent_dict**: The dictionary to extend. also mapping blueprint or app keys to lists of values.\n\nReturns:\n    None\n""""""'
False, '""""""\nApplies an error handler to a blueprint.\n\nThis function returns a decorator that can be used to apply an error handler to a blueprint.\nThe error handler is specified by the `code` parameter. which can be either an exception type or an integer code.\n\nArgs:\n    self: The instance of the class this method belongs to.\n    code (type[Exception] | int): The code for the error handler. Can be either an exception type or an integer code.\n\nReturns:\n    T_error_handler: A decorator that applies the specified error handler to a blueprint.\n\nYields:\n    None\n""""""\ndef app_errorhandler(\n        self. code: type[Exception] | int\n    ) -> t.Callable[[T_error_handler]. T_error_handler]:\n\n        def decorator(f: T_error_handler) -> T_error_handler:\n            def from_blueprint(state: BlueprintSetupState) -> None:\n                state.app.errorhandler(code)(f)\n\n            self.record_once(from_blueprint)\n            return f\n\n        return decorator'
True, '""""""\nDecorates an error handler function with the ability to be registered once in a Blueprint\'s setup.\n\nArgs:\n    f (T_error_handler): The error handler function to decorate.\n\nReturns:\n    T_error_handler: The decorated error handler function.\n""""""'
True, '""""""\nHandles error handling for an application using a blueprint setup state.\n\nArgs:\n    state (BlueprintSetupState): The current state of the blueprint setup.\nReturns:\n    None\nRaises:\n    Exception: If an error occurs during error handling.\n""""""'
True, '""""""\nDecorates a method with setup functionality.\n\nThis function takes a method `f` as input and returns a wrapper function that checks if the setup process is finished before calling the original method. The wrapper function also updates the `__name__` attribute of the original method to include the name of the decorated method.\n\nArgs:\n    f (F): The method to be decorated.\n\nReturns:\n    F: The decorated method.\n""""""'
True, '""""""\nWrapper function for a scaffold object.\n\nThis function acts as a proxy to the underlying `f` method of the scaffold object.\nIt checks if the setup is finished before calling the original method and returns\nthe result.\n\nArgs:\n    self (Scaffold): The scaffold object instance.\n    *args: Variable number of positional arguments passed to the original method.\n    **kwargs: Variable number of keyword arguments passed to the original method.\n\nReturns:\n    Any: The result of the original method call.\n\nRaises:\n    None\n\nNote:\nThis function is a wrapper and does not modify the behavior of the underlying `f` method.\nIt is intended to provide additional functionality or error checking before calling the original method.\n""""""'
True, '""""""\nInitialize a Flask application.\n\nThis function initializes a new instance of the Flask class. It takes several\nparameters that define the configuration and behavior of the application.\n\nParameters:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike[str] | None. optional): The path to the static folder.\n    static_url_path (str | None. optional): The URL path for static files.\n    template_folder (str | os.PathLike[str] | None. optional): The path to the templates folder.\n    root_path (str | None. optional): The absolute path to the package on the filesystem.\n\nAttributes:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike[str] | None): The path to the static folder.\n    static_url_path (str | None): The URL path for static files.\n    template_folder (str | os.PathLike[str] | None): The path to the templates folder.\n    root_path (str | None): The absolute path to the package on the filesystem.\n    cli (click.Group): The Click command group for registering CLI commands.\n    view_functions (dict[str. ft.RouteCallable]): A dictionary mapping endpoint names to view functions.\n    error_handler_spec (dict[ft.AppOrBlueprintKey. dict[int | None. dict[type[Exception]. ft.ErrorHandlerCallable]]]): A data structure of registered error handlers.\n    before_request_funcs (dict[ft.AppOrBlueprintKey. list[ft.BeforeRequestCallable]]): A data structure of functions to call at the beginning of each request.\n    after_request_funcs (dict[ft.AppOrBlueprintKey. list[ft.AfterRequestCallable[t.Any]]]): A data structure of functions to call at the end of each request.\n    teardown_request_funcs (dict[ft.AppOrBlueprintKey. list[ft.TeardownCallable]]): A data structure of functions to call at the end of each request even if an exception is raised.\n    template_context_processors (dict[ft.AppOrBlueprintKey. list[ft.TemplateContextProcessorCallable]]): A data structure of functions to call to pass extra context values when rendering templates.\n    url_value_preprocessors (dict[ft.AppOrBlueprintKey. list[ft.URLValuePreprocessorCallable]]): A data structure of functions to call to modify the keyword arguments passed to the view function.\n    url_default_functions (dict[ft.AppOrBlueprintKey. list[ft.URLDefaultCallable]]): A data structure of functions to call to modify the keyword arguments when generating URLs.\n\nRaises:\n    TypeError: If any parameter is not of the correct type.\n""""""'
True, '""""""\nSets the static folder path.\n\nThis method sets the path to the static folder. If a path is provided. it will be normalized and stripped of trailing slashes.\n\nArgs:\n    value (str | os.PathLike[str] | None): The path to the static folder. Can be an absolute or relative path. or `None` for no static folder.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns a method route for the given rule and options.\n\nThis function is used to create a method-specific route for a given rule.\nIt takes in the method name. rule string. and options dictionary as parameters.\nThe returned callable can be used to decorate a class or function with the specified method.\n\nArgs:\n    self: The instance of the class that contains this method.\n    method (str): The name of the method to route.\n    rule (str): The rule for which the method will be applied.\n    options (dict[str. t.Any]): Additional keyword arguments to pass to the `route` method.\n\nReturns:\n    t.Callable[[T_route]. T_route]: A callable that can be used to decorate a class or function with the specified method.\n\nRaises:\n    TypeError: If the \'methods\' argument is provided in the options dictionary.\n""""""'
False, 'def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:\n    """"""\n    Extracts the endpoint name from a view function.\n\n    Args:\n        view_func (ft.RouteCallable): The view function to extract the endpoint from.\n    \n    Returns:\n        str: The endpoint name of the provided view function.\n\n    Raises:\n        AssertionError: If the view function is None. indicating that an endpoint was not provided.\n    """"""'
False, '""""""\nFind the path to a Python package or module.\n\nThis function takes an import name as input and returns the path to the corresponding package or module.\nIf the package or module is not found. it raises a ValueError. If the import fails due to invalid module name.\nit falls back to the current working directory.\n\nArgs:\n    import_name (str): The name of the package or module to find.\n\nReturns:\n    str: The path to the package or module.\n\nRaises:\n    ValueError: If the package or module is not found.\n""""""\n\ndef _find_package_path(import_name: str) -> str:'
False, 'def find_package(import_name: str) -> tuple[str | None. str]:\n    """"""\n    Finds the path to a Python package.\n\n    Args:\n    import_name (str): The name of the package to find.\n\n    Returns:\n    A tuple containing the prefix and path to the package. If the package is not installed.\n    returns (None. package_path).\n\n    Note:\n    This function uses internal implementation details and should not be used directly.\n    It\'s intended for use by other parts of the Python interpreter or tools that need to\n    find packages.\n\n    Raises:\n    None\n\n    Examples:\n    >>> find_package(""numpy"")\n    (\'/usr/lib/python3.9/site-packages\'. \'/usr/lib/python3.9/site-packages/numpy\')\n    """"""\n\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if _path_is_relative_to(pathlib.PurePath(package_path). py_prefix):\n        return py_prefix. package_path\n\n    site_parent. site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == ""site-packages"":\n        parent. folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == ""lib"":\n            return parent. package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == ""lib"":\n            return os.path.dirname(parent). package_path\n\n        # something else (prefix/site-packages)\n        return site_parent. package_path\n\n    # not installed\n    return None. package_path'
False, '""""""\n    Initializes the object with an optional initial value.\n\n    Args:\n        initial (t.Any): The initial value of the object. Defaults to None.\n\n    Returns:\n        None\n""""""\n\n""""""\n    Updates the object\'s state by marking it as modified and accessed.\n\n    This method is called automatically when the object is updated.\n""""""'
True, '""""""\nUpdates the object\'s state after a modification.\n\nThis method is called when an update operation is performed on the object.\nIt sets `self.modified` and `self.accessed` to indicate that the object has been modified and accessed. respectively.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the name of the cookie used by the given Flask application for session management.\n\nArgs:\n    app (Flask): The Flask application instance.\n\nReturns:\n    str: The name of the session cookie.\n""""""'
True, '""""""\nReturns the domain of the session cookie.\n\nThis method retrieves the value of the `SESSION_COOKIE_DOMAIN` configuration\nvariable from the provided Flask application instance. If no such variable is set.\nthe function returns `None`.\n\nArgs:\n    app (Flask): The Flask application instance to retrieve the cookie domain from.\n\nReturns:\n    str | None: The domain of the session cookie. or `None` if not set.\n""""""'
True, '""""""\nReturns the path of the cookie for a given Flask application.\n\nThe function checks if `SESSION_COOKIE_PATH` is set in the application\'s configuration.\nIf it is. that value is returned. Otherwise. it falls back to using `APPLICATION_ROOT`.\n\nArgs:\n    app (Flask): The Flask application instance.\n\nReturns:\n    str: The path of the cookie for the given application.\n""""""'
True, '""""""\nReturns whether the session cookie is set to be HTTP-only.\n\nArgs:\n    app (Flask): The application instance.\n\nReturns:\n    bool: True if the session cookie is HTTP-only. False otherwise.\n""""""'
True, '""""""\nReturns whether the session cookie is secure.\n\nThis method checks if the `SESSION_COOKIE_SECURE` configuration variable\nis set to True in the provided Flask application. If it is. the function\nreturns True; otherwise. it returns False.\n\nArgs:\n    app (Flask): The Flask application instance to check.\n\nReturns:\n    bool: Whether the session cookie is secure.\n""""""'
True, '""""""\nReturns the value of the \'SESSION_COOKIE_SAMESITE\' configuration option from the provided Flask application.\n\nArgs:\n    app (Flask): The Flask application instance to retrieve the configuration from.\n\nReturns:\n    str | None: The value of the \'SESSION_COOKIE_SAMESITE\' configuration option. or None if it is not set.\n""""""'
True, '""""""\nReturns the source code for a given template in an environment.\n\nArgs:\n    - `environment`: The BaseEnvironment instance to retrieve the source from.\n    - `template`: The name of the template to get the source for.\n\nReturns:\n    A tuple containing:\n        1. The source code as a string.\n        2. An optional error message as a string. or None if no error occurred.\n        3. An optional callable function that can be used to check if the source is valid. or None if not needed.\n\nIf `EXPLAIN_TEMPLATE_LOADING` is enabled in the application configuration. this function will return an explained source code. Otherwise. it will use a faster method to retrieve the source code.\n""""""'
True, '""""""\nReturns the source explanation for a given template in the specified environment.\n\nThis function iterates over all loaders for the provided template and attempts to retrieve the source explanation.\nIf successful. it returns a tuple containing the source code. error message (if any). and a callable that can be used to check if the source is valid.\nIf no loader is able to retrieve the source. it raises a TemplateNotFound exception.\n\nArgs:\n    environment (BaseEnvironment): The environment in which to retrieve the source explanation.\n    template (str): The template for which to retrieve the source explanation.\n\nReturns:\n    tuple[str. str | None. t.Callable[[]. bool] | None]: A tuple containing the source code. error message (if any). and a callable that can be used to check if the source is valid.\nRaises:\n    TemplateNotFound: If no loader is able to retrieve the source explanation for the provided template.\n\nNote:\n    This function uses a debug helper to log the loading attempts for the given template.\n""""""'
True, '""""""\nReturns the source code of a given template in the specified environment.\n\nArgs:\n    - `environment`: The base environment to use for loading templates.\n    - `template`: The name of the template to retrieve the source code for.\n\nReturns:\n    A tuple containing the source code as a string. and an optional loader function that can be used to load the template. If no loader is found. returns None.\n\nRaises:\n    TemplateNotFound: If the specified template cannot be found.\n""""""'
True, '""""""\nYields tuples of scaffold and base loader instances.\n\nThis function iterates over the available loaders in the application\'s Jinja template engine.\nyielding a tuple containing each scaffold and its corresponding base loader. If no loaders are found.\nit returns an empty iterator.\n\nArgs:\n    template (str): The current template being processed.\n\nReturns:\n    t.Iterator[tuple[Scaffold. BaseLoader]]: An iterator yielding tuples of scaffold and base loader instances.\n""""""'
True, '""""""\nYield a session object for the current test request context.\n\nThis function is used to create and manage sessions for testing purposes.\nIt checks if cookies are enabled. sets them up. opens a new session.\nand saves it after use. If the session backend fails to open a session.\nit raises a RuntimeError.\n\nArgs:\n    *args: Variable arguments passed to the test request context.\n    **kwargs: Keyword arguments passed to the test request context.\n\nReturns:\n    An iterator yielding SessionMixin objects for each session opened.\n""""""'
True, '""""""\nCopies the environment of another WSGIEnvironment instance.\n\nThis method creates a new dictionary containing all key-value pairs from both `self` and `other`. If `preserve_context` is True it also adds the `_new_contexts` attribute to the resulting dictionary.\n\nArgs:\n    other (WSGIEnvironment): The environment to copy from.\n\nReturns:\n    WSGIEnvironment: A new WSGIEnvironment instance with the copied environment.\n""""""'
True, '""""""\nReturns a BaseRequest object created from the provided arguments and keyword arguments.\n\nArgs:\n    - args (tuple[t.Any. ...]): A tuple of positional arguments.\n    - kwargs (dict[str. t.Any]): A dictionary of keyword arguments.\n\nReturns:\n    BaseRequest: The created BaseRequest object.\n\nRaises:\n    None\n\nNote:\n    This function creates an EnvironBuilder instance and uses it to get a request. It ensures the builder is properly closed after use.\n""""""'
True, '""""""\nOpens a new test session.\n\nThis method is used to create a new test environment. It takes in various arguments and keyword arguments that can be used to customize the behavior of the test session.\n\nArgs:\n    *args: A variable number of positional arguments. If provided. they are used to initialize the request object.\n    buffered (bool): Whether to buffer the response. Defaults to False.\n    follow_redirects (bool): Whether to follow redirects. Defaults to False.\n    **kwargs: A dictionary of keyword arguments.\n\nReturns:\n    TestResponse: The test response object.\n\nRaises:\n    ValueError: If the provided arguments are invalid.\n""""""'
True, '""""""\nInvokes the parent class\'s invoke method with optional CLI and arguments.\n\nThis function is used to initialize the script info object and pass it to the parent class\'s invoke method.\nIf no \'obj\' key is provided in kwargs. a ScriptInfo object is created with a create_app lambda that returns the app instance.\n\nArgs:\n    cli (t.Any): The command line interface. Defaults to self.app.cli if None.\n    args (t.Any): Any additional arguments. Defaults to None.\n    **kwargs (t.Any): Additional keyword arguments. Must include \'obj\' key.\n\nReturns:\n    t.Any: The result of the parent class\'s invoke method.\n""""""'
False, '""""""\nConverts a class-based view to a function-based view.\n\nThis function takes a class. name. and optional arguments and keyword arguments.\nand returns a function that can be used as a view in the application.\n\nIf `cls.init_every_request` is True the returned function will initialize\nthe class instance before each request. Otherwise. it will simply create an\ninstance of the class.\n\nThe returned function also has its name. module. and docstring set to those\nof the original class. and any decorators from the class are applied to the\nfunction.\n\nThis allows for easy testing and debugging by replacing the view with a\ndifferent class or function.\n""""""\ndef as_view(\n    cls: type.\n    name: str.\n    *class_args: Any.\n    **class_kwargs: Any\n) -> RouteCallable:\n    ...\n'
True, '""""""\nView a request.\n\nThis function is used to handle HTTP requests. It takes in any number of keyword arguments.\nwhich are then passed to the `dispatch_request` method of the view class instance.\nThe result of this method call is returned as an HTTP response.\n\nArgs:\n    **kwargs: Any additional keyword arguments to be passed to the view class.\n\nReturns:\n    ft.ResponseReturnValue: The result of the `dispatch_request` method call.\n\nRaises:\n    None\n""""""'
True, '""""""\nView a request.\n\nDispatches the given request to the appropriate handler and returns the response.\n\nArgs:\n    **kwargs (t.Any): Keyword arguments to be passed to the dispatch_request method.\n\nReturns:\n    ft.ResponseReturnValue: The response returned by the dispatched request.\n""""""'
False, 'def dispatch_request(self. **kwargs: t.Any) -> ft.ResponseReturnValue:\n    """"""\n    Dispatches a request to the appropriate handler.\n\n    If the request method is HEAD and no handler is found for it.\n    this function will retry with GET. It asserts that a handler\n    exists for the requested method. raising an error if not.\n    \n    Args:\n        **kwargs: Keyword arguments to be passed to the handler.\n        \n    Returns:\n        The response returned by the handler.\n    """"""\n    meth = getattr(self. request.method.lower(). None)\n\n    # If the request method is HEAD and we don\'t have a handler for it\n    # retry with GET.\n    if meth is None and request.method == ""HEAD"":\n        meth = getattr(self. ""get"". None)\n\n    assert meth is not None. f""Unimplemented method {request.method!r}""\n    return current_app.ensure_sync(meth)(**kwargs)  # type: ignore[no-any-return]'
True, '""""""\nReturns the maximum allowed content length for the application.\n\nIf `current_app` is available. it returns the value from `current_app.config[""MAX_CONTENT_LENGTH""]`.\nOtherwise. it returns `None`.\n\nArgs:\n    None\n\nReturns:\n    int | None: The maximum allowed content length or None if not configured.\n""""""'
False, '""""""\nReturns the maximum cookie size.\n\nIf running within an application context. returns the value from `current_app.config[""MAX_COOKIE_SIZE""]`.\nOtherwise. falls back to Werkzeug\'s default.'
True, '""""""\nDecorates a function to run with the application context.\n\nThis decorator is used to ensure that functions decorated with it are executed within\nthe application\'s context. This can be useful for tasks such as database operations.\nfile I/O. or any other operation that requires access to the current application state.\n\nThe `with_appcontext` function takes a function `f` as an argument and returns the result of\ninvoking `f` with the application context. If the application context is not already set.\nit will load the application from the `ScriptInfo` object associated with the click context.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function. wrapped in a decorator that runs it with the application context.\n""""""'
False, '""""""\nReturns a decorator that appends the provided callable to the list of functions \nto be executed after the current request has been completed.\n\nArgs:\n    f (ft.AfterRequestCallable[t.Any]): The callable to be appended to the list.\n\nReturns:\n    ft.AfterRequestCallable[t.Any]: The decorated function.\nRaises:\n    RuntimeError: If no request context is active. indicating that \'after_this_request\' \n                  can only be used when a request context is active. such as in a view function.'
False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[.... t.Iterator[t.AnyStr]].\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator. and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started.\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator. but rather a callable that returns an iterator.\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context. and pushes it onto the stack when the generator is started.\n    When the iteration completes. the context is popped off the stack.\n\n    This function can only be used when a request context is active. such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n""""""\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any. **kwargs: t.Any) -> t.Any:\n            """"""\n            Decorates a function or generator with the `stream_with_context` function from the `itertools` module.\n\n            Args:\n                *args (t.Any): Variable number of positional arguments to be passed to the decorated function or generator.\n                **kwargs (t.Any): Variable number of keyword arguments to be passed to the decorated function or generator.\n\n            Returns:\n                t.Any: The result of applying the `stream_with_context` function to the provided function or generator.\n\n            Note:\n                This decorator is used to convert a function or generator into an iterator that can be used with the `stream_with_context` function.\n            """"""\n            gen = generator_or_function(*args. **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator. generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                ""\'stream_with_context\' can only be used when a request""\n                "" context is active. such as in a view function.""\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we\'re\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we\'re still running the cleanup logic.  Generators\n            # don\'t need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen. ""close""):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]'
False, 'def jsonify(*args: t.Any. **kwargs: t.Any) -> Response:\n    """"""\n    Returns a JSON response.\n\n    This function takes in any number of positional arguments and keyword arguments.\n    which are then passed to the `json` method of the current application instance.\n    The result is a JSON response object.\n\n    Args:\n        *args (t.Any): Any positional arguments to be included in the response.\n        **kwargs (t.Any): Any keyword arguments to be included in the response.\n\n    Returns:\n        Response: A JSON response object.'
False, ""```\nRecords a function to be executed once during the setup process.\n\nThis method is used to register a function that should only be executed once.\nduring the initial setup of the application. The function is wrapped in a\ndecorator to ensure it's only called once. even if the blueprint is reloaded.\n\nArgs:\n    func (DeferredSetupFunction): The function to be recorded and executed.\n    \nReturns:\n    None\n```""
True, '""""""\nWrapper function to handle first registration of users.\n\nThis function checks if the user has registered for the first time and calls the `func` function with the provided `state` object if so.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application setup.\n\nReturns:\n    None\n""""""'
True, '""""""\nLoads a Jinja template loader based on the presence of a template folder.\n\nReturns:\n    BaseLoader | None: A Jinja template loader instance if a template folder is present. otherwise None.\n""""""'
False, 'def convert(\n    """"""\n    Converts the given environment variable value into a list of converted values.\n\n    Args:\n        value (t.Any): The environment variable value to be converted.\n        param (click.Parameter | None): The parameter object associated with the conversion.\n        ctx (click.Context | None): The context object containing additional information about the conversion.\n\n    Returns:\n        t.Any: A list of converted values.\n\n    Raises:\n        Exception: If an error occurs during the conversion process.\n    """"""\n    items = self.split_envvar_value(value)\n    # can\'t call no-arg super() inside list comprehension until Python 3.12\n    super_convert = super().convert\n    return [super_convert(item. param. ctx) for item in items]'
True, '""""""\nReturns a context for the `run` command with the current file\'s path as an exclude pattern.\n\nThis function creates a context for the `run` command. passing the current file\'s path as an exclude pattern.\nThe resulting context is then asserted to have the expected exclude patterns.\n\nArgs:\n    None\n\nReturns:\n    A context object containing the `run` command parameters\n""""""'
True, '""""""\nLocate an application within a given Flask module.\n\nThis function takes in the name of the module and the name of the application to locate.\nIt also accepts an optional parameter `raise_if_not_found` which defaults to `True`.\nIf `raise_if_not_found` is `False`. the function will return `None` instead of raising an exception if the application cannot be found.\n\nArgs:\n    module_name (str): The name of the Flask module to search in.\n    app_name (str | None): The name of the application to locate. If `None`. all applications in the module are returned.\n    raise_if_not_found (bool. optional): Whether to raise an exception if the application cannot be found. Defaults to `True`.\n\nReturns:\n    Flask: The located Flask application object.\n\nRaises:\n    ValueError: If `raise_if_not_found` is `False`.\n""""""'
True, '""""""\nLocate an application within a given module.\n\nThis function searches for an application with the specified name within a given module.\nIt returns the found application or `None` if not found. If `raise_if_not_found` is set to `True`. it raises a `ValueError` if the application is not found.\n\nArgs:\n    - **module_name** (str): The name of the module to search in.\n    - **app_name** (str | None): The name of the application to locate. If `None`. all applications will be returned.\n    - **raise_if_not_found** (t.Literal[False] = ...): Whether to raise an error if the application is not found.\n\nReturns:\n    - Flask | None: The located application or `None` if not found.\n""""""'
True, '""""""\nGets the instance of this descriptor.\n\nArgs:\n    obj (None): The object that owns this descriptor. If not provided. returns self.\n    owner (None): The class or type that defines this descriptor. If not provided. returns self.\n\nReturns:\n    te.Self: The instance of this descriptor.\n""""""'
True, '""""""\nGets an attribute from an object.\n\nThis method is used to implement property access in Python. It allows you to define a getter function for a property of a class.\n\nArgs:\n    self (object): The instance of the class.\n    obj (App. optional): The object that owns this property. Defaults to None.\n    owner (type[App]. optional): The type of the App class. Defaults to None.\n\nReturns:\n    T: The value of the attribute.\n""""""'
True, '""""""\nTests the JSONification of UUID types.\n\nThis function tests that a UUID object can be successfully serialized to JSON and deserialized back into a UUID object.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Flask client): The Flask client instance.\n\nReturns:\nNone\n""""""'
True, '""""""\nSynchronizes data before any operations.\n\nThis function is intended to be called before any data synchronization or update operations.\nIt may include tasks such as cleaning up temporary files. resetting session variables. or performing other necessary steps to ensure a consistent state.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nAsync Function to be Executed Before Asynchronous Operations\n\nThis function is designed to be executed before any asynchronous operations. It serves as a placeholder or initialization point for tasks that need to be completed before proceeding with asynchronous code.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nTeardowns synchronization operations after an exception occurs.\n\nThis function is designed to be used as part of a larger error handling mechanism.\nIt takes an exception object as input and performs any necessary cleanup or rollback\nof the synchronization operation before continuing execution. If no exception occurred.\nit does nothing.\n\nParameters:\nexc (BaseException | None): The exception that occurred. or None if no exception occurred.\n\nReturns:\nNone: This function does not return a value.\n""""""'
True, '""""""\nTeardowns an asynchronous operation.\n\nThis function is used to handle exceptions that occur during an asynchronous operation.\nIt provides a way to clean up resources and restore the original state of the system\nafter an exception has occurred.\n\nArgs:\n    exc (BaseException | None): The exception that occurred during the operation. Can be None if no exception occurred.\n\nReturns:\n    None\n\nRaises:\n    BaseException: If an error occurs while cleaning up resources.\n""""""'
True, '""""""\nTests the JSONification of UUID types.\n\nThis function tests that a UUID object can be successfully serialized to JSON and deserialized back into a UUID object.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Flask client): The Flask client instance.\n\nReturns:\nNone\n""""""'
True, '""""""\nCalculates the SHA-1 hash of a given string.\n\nArgs:\n    string (bytes. optional): The input string to be hashed. Defaults to an empty byte string.\n\nReturns:\n    Any: The calculated SHA-1 hash as a bytes object.\n""""""'
True, '""""""\nAdds a static route to the application using the provided `static_url_path`. \n`static_host`. and `static_folder`. This is done without checking if \n`static_folder` exists. as it might be created while the server is running. \n\nThis method uses a weakref to avoid creating a reference cycle between the app \nand the view function.\n\nArgs:\n    import_name (str): The name of the module being imported.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike[str] | None): The folder where static files are stored. Defaults to ""static"".\n    static_host (str | None): The host on which the static route is served. Defaults to None.\n    host_matching (bool): Whether the host should be matched. Defaults to False.\n    subdomain_matching (bool): Whether the subdomain should be matched. Defaults to False.\n    template_folder (str | os.PathLike[str] | None): The folder where templates are stored. Defaults to ""templates"".\n    instance_path (str | None): The path of the instance. Defaults to None.\n    instance_relative_config (bool): Whether the configuration is relative to the instance. Defaults to False.\n    root_path (str | None): The root path of the application. Defaults to None.\n\nRaises:\n    AssertionError: If `static_host` and `host_matching` do not match. or if \n        `static_folder` exists but `static_url_path` is not provided.\n""""""'
True, '""""""\nInitialize a Flask application.\n\nThis function initializes a new instance of the Flask class. setting up various configuration options and command groups for the application.\n\nParameters:\n    name (str): The name of the application.\n    import_name (str): The import name of the application.\n    static_folder (str | os.PathLike[str] | None): The path to the static folder. Defaults to None.\n    static_url_path (str | None): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike[str] | None): The path to the template folder. Defaults to None.\n    url_prefix (str | None): The prefix for URLs. Defaults to None.\n    subdomain (str | None): The subdomain for the application. Defaults to None.\n    url_defaults (dict[str. t.Any] | None): A dictionary of URL defaults. Defaults to None.\n    root_path (str | None): The root path for the application. Defaults to None.\n    cli_group (str | None): The Click command group for registering CLI commands. Defaults to _sentinel.\n\nReturns:\n    None\n""""""'
True, '""""""\nSaves a session cookie to the client\'s browser.\n\nThis method sets a session cookie based on the provided `app`. `session`. and `response` objects.\nIt determines the necessary cookie attributes (name. domain. path. secure. samesite. httponly) using\nthe `get_cookie_name`. `get_cookie_domain`. `get_cookie_path`. `get_cookie_secure`. \n`get_cookie_samesite`. and `get_cookie_httponly` methods.\n\nIf the session was accessed at all. a ""Vary: Cookie"" header is added to the response.\nIf the session is modified or empty. the cookie is removed or not set respectively.\nOtherwise. if the session should be set as a cookie according to the `should_set_cookie` method.\nthe necessary attributes are determined and the cookie is set.\n\nParameters:\napp (Flask): The Flask application instance.\nsession (SessionMixin): The session object.\nresponse (Response): The response object.\n\nReturns:\nNone\n""""""'
True, '""""""\nSaves a session cookie to the client\'s browser.\n\nThis method sets a session cookie based on the provided `app`. `session`. and `response` objects.\nIt determines the necessary cookie attributes (name. domain. path. secure. samesite. httponly) using\nthe `get_cookie_name`. `get_cookie_domain`. `get_cookie_path`. `get_cookie_secure`. \n`get_cookie_samesite`. and `get_cookie_httponly` methods.\n\nIf the session was accessed at all. a ""Vary: Cookie"" header is added to the response.\nIf the session is modified or empty. the cookie is removed or not set respectively.\nOtherwise. if the session should be set as a cookie according to the `should_set_cookie` method.\nthe necessary attributes are determined and the cookie is set.\n\nParameters:\napp (Flask): The Flask application instance.\nsession (SessionMixin): The session object.\nresponse (Response): The response object.\n\nReturns:\nNone\n""""""' 
True, '""""""\nReturns the URL rule\'s endpoint if available. otherwise returns None.\n\nArgs:\n    None\n\nReturns:\n    str | None: The URL rule\'s endpoint or None if not set.\n""""""'
True, '""""""\nSaves a session cookie to the client\'s browser.\n\nThis method sets a session cookie based on the provided `app`. `session`. and `response` objects.\nIt determines the necessary cookie attributes (name. domain. path. secure. samesite. httponly) using\nthe `get_cookie_name`. `get_cookie_domain`. `get_cookie_path`. `get_cookie_secure`. \n`get_cookie_samesite`. and `get_cookie_httponly` methods.\n\nIf the session was accessed at all. a ""Vary: Cookie"" header is added to the response.\nIf the session is modified or empty. the cookie is removed or not set respectively.\nOtherwise. if the session should be set as a cookie according to the `should_set_cookie` method.\nthe necessary attributes are determined and the cookie is set.\n\nParameters:\napp (Flask): The Flask application instance.\nsession (SessionMixin): The session object.\nresponse (Response): The response object.\n\nReturns:\nNone\n""""""'
False, 'def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[.... t.Iterator[t.AnyStr]].\n) -> t.Iterator[t.AnyStr]:\n    """"""\n    Stream a generator or function with context.\n\n    This function takes an iterator or callable that returns an iterator. and wraps it in a context manager.\n    The context manager pushes the current request context onto the stack when the generator is started.\n    and pops it off when the iteration completes.\n\n    If the input is not an iterator. but rather a callable that returns an iterator.\n    this function will wrap the callable in a decorator to create a new function that takes any arguments\n    and returns an iterator. This allows the original function to be used as if it were an iterator.\n\n    The context manager uses the `_cv_request` object to get the current request context. and pushes it onto the stack when the generator is started.\n    When the iteration completes. the context is popped off the stack.\n\n    This function can only be used when a request context is active. such as in a view function.\n\n    Args:\n        generator_or_function: An iterator or callable that returns an iterator.\n\n    Returns:\n        An iterator over the results of the input generator or function.\n""""""\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any. **kwargs: t.Any) -> t.Any:\n            """"""\n            Decorates a function or generator with the `stream_with_context` function from the `itertools` module.\n\n            Args:\n                *args (t.Any): Variable number of positional arguments to be passed to the decorated function or generator.\n                **kwargs (t.Any): Variable number of keyword arguments to be passed to the decorated function or generator.\n\n            Returns:\n                t.Any: The result of applying the `stream_with_context` function to the provided function or generator.\n\n            Note:\n                This decorator is used to convert a function or generator into an iterator that can be used with the `stream_with_context` function.\n            """"""\n            gen = generator_or_function(*args. **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator. generator_or_function)  # type: ignore[arg-type. return-value]\n\n    def generator() -> t.Iterator[t.AnyStr | None]:\n        ctx = _cv_request.get(None)\n        if ctx is None:\n            raise RuntimeError(\n                ""\'stream_with_context\' can only be used when a request""\n                "" context is active. such as in a view function.""\n            )\n        with ctx:\n            # Dummy sentinel.  Has to be inside the context block or we\'re\n            # not actually keeping the context around.\n            yield None\n\n            # The try/finally is here so that if someone passes a WSGI level\n            # iterator in we\'re still running the cleanup logic.  Generators\n            # don\'t need that because they are closed on their destruction\n            # automatically.\n            try:\n                yield from gen\n            finally:\n                if hasattr(gen. ""close""):\n                    gen.close()\n\n    # The trick is to start the generator.  Then the code execution runs until\n    # the first dummy None is yielded at which point the context was already\n    # pushed.  This item is discarded.  Then when the iteration continues the\n    # real generator is executed.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g  # type: ignore[return-value]'
True, '""""""\nLoads a Flask application instance.\n\nThis method attempts to load an existing Flask application from the `self._loaded_app` attribute,\nor creates a new one if none exists. It also sets the debug flag of the loaded application\nif `self.set_debug_flag` is True.\n\nIf no application can be found, it raises a `NoAppException`.\n\nReturns:\n    The loaded Flask application instance.\n""""""'
True, '""""""\nTest session special types.\n\nThis function tests the behavior of Flask\'s session object when storing\nspecial types such as bytes, Markup objects, and UUIDs. It verifies that\nthese types are stored correctly and can be retrieved from the session.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Client): The client instance used for testing.\n\nReturns:\nNone\n""""""'
True, '""""""\nTest teardown request handler error functionality.\n\nThis test verifies that all teardown requests are passed the same original exception.\nIt also checks that a request with a division by zero error is handled correctly,\nand that an internal server error response is returned to the client.\n\nParameters:\napp (Flask application): The Flask application instance being tested.\nclient (requests session): The HTTP client used to make requests to the application.\n\nReturns:\nNone\n""""""'
False, '""""""\nRaises a new `TypeError` exception to test that all teardown requests are passed the same original exception.\n\nThis function is designed to be used in conjunction with the `teardown_requests` context manager, which ensures that all teardown requests are executed regardless of whether an exception was raised or not. By raising a new exception and then catching it, this function verifies that the original exception is still available for teardown requests to access.\n\nArgs:\n    exc (Exception): The original exception that was raised during the request.\n\nReturns:\n    None\n""""""\ndef teardown_request1(exc):\n    assert type(exc) is ZeroDivisionError\n    called.append(True)\n    try:\n        raise TypeError()\n    except Exception:\n        pass'
True, '""""""\nRaises a new `TypeError` exception to test that all teardown requests are passed the same original exception.\n\nThis function is designed to be used in conjunction with other teardown functions. It raises a new error and blows away sys.exc_info(), \nso we can test that all teardown_requests get passed the same original exception.\n\nArgs:\n    exc (Exception): The exception to be raised.\n\nReturns:\n    None\n\nRaises:\n    TypeError: A new `TypeError` exception is raised.\n""""""'
False, '""""""\nConverts a given value to a timedelta object.\n\nIf the input is already a timedelta object, it returns the original object.\nOtherwise, it converts an integer or None value to a timedelta object representing the specified number of seconds.\n\nArgs:\n    value (timedelta | int | None): The value to be converted to a timedelta object.\n\nReturns:\n    timedelta | None: The converted timedelta object or None if the input is invalid.'
False, '""""""\nInitialize a new Flask application instance.\n\nThis function initializes a new Flask application instance with the provided parameters. It sets up various attributes and methods that can be used throughout the application lifecycle.\n\nParameters:\n    import_name (str): The name of the module where this application is defined.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike | None): The folder containing static files. Defaults to ""static"".\n    static_host (str | None): The host for serving static files. Defaults to None.\n    host_matching (bool): Whether the application should match hosts in URLs. Defaults to False.\n    subdomain_matching (bool): Whether the application should match subdomains in URLs. Defaults to False.\n    template_folder (str | os.PathLike | None): The folder containing templates. Defaults to ""templates"".\n    instance_path (str | None): The path to the instance folder. If not provided, it will be automatically determined.\n    instance_relative_config (bool): Whether the configuration should be relative to the instance folder. Defaults to False.\n    root_path (str | None): The root path for the application. Defaults to None.\n\nAttributes:\n    instance_path (str): The path to the instance folder.\n    config (Config): The configuration dictionary as a Config object.\n    aborter (Aborter): An instance of Aborter created by make_aborter.\n    json (JSONProvider): A provider for JSON methods.\n    url_build_error_handlers (list[Callable[[Exception, str, dict[str, Any]], str]]): A list of functions that handle URL build errors.\n    teardown_appcontext_funcs (list[TeardownCallable]): A list of functions to run when the application context is destroyed.\n    shell_context_processors (list[ShellContextProcessorCallable]): A list of shell context processor functions.\n    blueprints (dict[str, Blueprint]): A dictionary mapping registered blueprint names to blueprint objects.\n    extensions (dict): A dictionary for storing application-specific state.\n    url_map (Map): The URL map for this instance.\n""""""\n\ndef __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike | None = ""static"",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike | None = ""templates"",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                ""If an instance path is provided it must be absolute.""\n                "" A relative path was given instead.""\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        """"""Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python\'s built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        """"""\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a ""Flask-Foo"" extension in `flask_foo`, the key would be\n        #: ``\'foo\'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(\',\')\n        #:        def to_url(self, values):\n        #:            return \',\'.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters[\'list\'] = ListConverter\n        self.url_map = self.url_map_class()\n\n        self.url_map.host_matching = host_matching\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n        # Add a static route using the provided static_url_path, static_host,\n        # and static_folder if there is a configured static_folder.\n        # Note we do this without checking if static_folder exists.\n        # For one, it might be created while the server is running (e.g. during\n        # development). Also, Google App Engine stores static files somewhere\n        if self.has_static_folder:\n            assert (\n                bool(static_host) == host_matching\n            ), ""Invalid static_host/host_matching combination""\n            # Use a weakref to avoid creating a reference cycle between the app\n            # and the view function (see #3761).\n            self_ref = weakref.ref(self)\n            self.add_url_rule(\n                f""{self.static_url_path}/<path:filename>"",\n                endpoint=""static"",\n                host=static_host,\n                view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n            )\n\n        # Set the name of the Click group in case someone wants to add\n        # the app\'s commands to another CLI tool.\n        self.cli.name = self.name'
True, '""""""\nRaises an AssertionError if the setup method has already been called on the application.\n\nThis check is performed after the first request has been handled by the application.\nIf the setup method is called again, any changes made will not be applied consistently.\n\nParameters:\n    f_name (str): The name of the setup method being checked.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the setup method has already been called on the application.\n""""""'
True, '""""""\nReturns the name of the current module or the main module name if running directly.\n\nIf running directly, it attempts to retrieve the filename from the `__file__` attribute of the main module.\nIf successful, it returns the base filename without extension. Otherwise, it returns the main module name.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the current module or the main module name if running directly.\n""""""'
True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""'
True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""'
True, '""""""\nCreates a configuration object based on the provided parameters.\n\nArgs:\n    instance_relative (bool): If True, uses the instance\'s path instead of the root path. Defaults to False.\n\nReturns:\n    Config: A configuration object with the specified settings.\n""""""'
True, '""""""\nCreates an instance of the Aborter class.\n\nReturns:\n    Aborter: An instance of the Aborter class.\n""""""'
False, 'def auto_find_instance_path(self) -> str:\n    """"""\n    Returns the path to the instance directory based on the package and import name.\n\n    If the package is not found, it defaults to the \'instance\' directory in the package path.\n    Otherwise, it returns a subdirectory named after the class name with \'-instance\' appended.\n\n    Args:\n        self: The object instance containing the import_name attribute.\n\n    Returns:\n        str: The full path to the instance directory.\n    """"""'
True, '""""""\nOpens an instance resource file.\n\nArgs:\n    - `resource` (str): The path to the resource file.\n    - `mode` (str, optional): The mode in which to open the file. Defaults to ""rb"".\n\nReturns:\n    A file object opened at the specified location with the given mode.\n\nRaises:\n    FileNotFoundError: If the instance_path does not exist or the resource is not found.\n""""""'
True, '""""""\nCreates a Jinja environment with custom options and updates its globals.\n\nThis method creates a new Jinja environment based on the provided options.\nIt also updates the environment\'s globals dictionary to include necessary functions\nand variables for use in templates.\n\nArgs:\n    self: The object instance that owns this method.\n\nReturns:\n    Environment: A newly created Jinja environment with custom options and updated globals.\n""""""'
True, '""""""\nCreates and returns a global Jinja loader instance.\n\nThis method is used to initialize the global Jinja loader, which is then used throughout the application.\nIt takes no arguments and returns an instance of `DispatchingJinjaLoader`, which is responsible for dispatching template rendering tasks.\n\nReturns:\n    DispatchingJinjaLoader: A global Jinja loader instance.\n""""""'
True, '""""""\nSelects whether a Jinja autoescape should be applied to a given file.\n\nArgs:\n    filename (str): The name of the file to check.\n\nReturns:\n    bool: True if the file should have autoescape applied, False otherwise.\n""""""'
True, '""""""\nUpdates the template context with additional information.\n\nThis function is used to extend the context passed to a template, allowing\nfor dynamic rendering of templates outside of a request context. It first\nchecks if a request object is available and adds any blueprint names from\nit to the list of names to process. Then it iterates over this list,\napplying any context processors that have been registered for each name.\n\nThe original context is preserved and updated with the new values after all\ncontext processors have been applied.\n\nArgs:\n    context (dict): The initial template context.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns a dictionary representing the shell context.\n\nThis function combines the application object (`self`) with the global object (`g`), \nand then updates it with the results of each processor function in `self.shell_context_processors`.\n\nArgs:\n    None\n\nReturns:\n    dict: The constructed shell context.\n""""""'
True, '""""""\nReturns whether the debug mode is enabled based on the configuration.\n\nArgs:\n    None\n\nReturns:\n    bool: True if debug mode is enabled, False otherwise\n""""""'
True, '""""""\n    Sets the debug mode for the application.\n\n    Args:\n        value (bool): A boolean indicating whether to enable or disable debug mode.\n    \n    Returns:\n        None\n    \n    Note:\n        This function modifies the configuration of the application. It also affects the behavior of the Jinja templating engine if TEMPLATES_AUTO_RELOAD is not set.\n""""""'
False, '```python\ndef run(\n    host: str | None = None,\n    port: int | None = None,\n    debug: bool | None = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This function is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If `load_dotenv`\n    is set to True, it loads environment variables from a .env file. The `debug`\n    parameter can be set to override the default debug mode.\n\n    Args:\n        host (str | None): The hostname or IP address to bind to.\n        port (int | None): The port number to use.\n        debug (bool | None): Whether to enable debug mode.\n        load_dotenv (bool, optional): Whether to load environment variables from a .env file. Defaults to True.\n        **options: t.Any: Additional options for the server.\n\n    Returns:\n        None\n    """"""\n```'
True, '""""""\nReturns a test client instance for the application.\n\nArgs:\n    use_cookies (bool): Whether to include cookies in the request. Defaults to True.\n    **kwargs: Additional keyword arguments to pass to the FlaskClient constructor.\n\nReturns:\n    FlaskClient: A test client instance for the application.\n""""""'
True, '""""""\nReturns an instance of `FlaskCliRunner` initialized with the provided keyword arguments.\n\nArgs:\n    **kwargs (t.Any): Keyword arguments to be passed to the `FlaskCliRunner` constructor.\n\nReturns:\n    FlaskCliRunner: An instance of `FlaskCliRunner`.\n\nRaises:\n    None\n""""""'
True, '""""""\nRegisters a blueprint with the current application.\n\nArgs:\n    - blueprint (Blueprint): The blueprint to be registered.\n    - **options (t.Any): Optional keyword arguments to be passed to the `register` method of the blueprint.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns an iterator over the blueprint values.\n\nThis method provides a view of all blueprints in the system, allowing for efficient iteration and access to their attributes. The returned iterator is a `ValuesView` object, which supports various methods for filtering and manipulating the results.\n\nArgs:\n    None\n\nReturns:\n    t.ValuesView[Blueprint]: An iterator over the blueprint values.\n""""""'
False, 'def add_url_rule(\n    """"""\n    Adds a new URL rule to the application\'s URL map.\n\n    This method allows you to define a route for a specific endpoint, \n    which can be used to handle HTTP requests. The endpoint is optional, \n    and if not provided, it will be inferred from the view function.\n\n    Args:\n        rule (str): The URL pattern for the new route.\n        endpoint (str | None): The endpoint for the new route. Defaults to None.\n        view_func (ft.RouteCallable | None): The view function for the new route. Defaults to None.\n        provide_automatic_options (bool | None): Whether to automatically add OPTIONS and other methods to the route. Defaults to None.\n        **options: t.Any: Additional options for the URL rule.\n\n    Returns:\n        None\n    """"""\n    if endpoint is None:\n        endpoint = _endpoint_from_view_func(view_func)  # type: ignore\n    options[""endpoint""] = endpoint\n    methods = options.pop(""methods"", None)\n\n    # if the methods are not given and the view_func object knows its\n    # methods we can use that instead.  If neither exists, we go with\n    # a tuple of only ``GET`` as default.\n    if methods is None:\n        methods = getattr(view_func, ""methods"", None) or (""GET"",)\n    if isinstance(methods, str):\n        raise TypeError(\n            ""Allowed methods must be a list of strings, for""\n            \' example: @app.route(..., methods=[""POST""])\'\n        )\n    methods = {item.upper() for item in methods}\n\n    # Methods that should always be added\n    required_methods = set(getattr(view_func, ""required_methods"", ()))\n\n    # starting with Flask 0.8 the view_func object can disable and\n    # force-enable the automatic options handling.\n    if provide_automatic_options is None:\n        provide_automatic_options = getattr(\n            view_func, ""provide_automatic_options"", None\n        )\n\n    if provide_automatic_options is None:\n        if ""OPTIONS"" not in methods:\n            provide_automatic_options = True\n            required_methods.add(""OPTIONS"")\n        else:\n            provide_automatic_options = False\n\n    # Add the required methods now.\n    methods |= required_methods\n\n    rule = self.url_rule_class(rule, methods=methods, **options)\n    rule.provide_automatic_options = provide_automatic_options  # type: ignore\n\n    self.url_map.add(rule)\n    if view_func is not None:\n        old_func = self.view_functions.get(endpoint)\n        if old_func is not None and old_func != view_func:\n            raise AssertionError(\n                ""View function mapping is overwriting an existing""\n                f"" endpoint function: {endpoint}""\n            )\n        self.view_functions[endpoint] = view_func'
False, '""""""\nTemplate Filter Decorator\n\nThis function is a decorator factory that creates a template filter with the given name.\n\nArgs:\n    name (str | None): The name of the template filter. If None, no name will be assigned.\n\nReturns:\n    T_template_filter: A callable that returns the decorated template filter.\n""""""\n\ndef template_filter(\n        self, name: str | None = None\n) -> t.Callable[[T_template_filter], T_template_filter]:\n\n    def decorator(f: T_template_filter) -> T_template_filter:\n        """"""\n        Decorator function to add a template filter.\n\n        Args:\n            f (T_template_filter): The template filter to be decorated.\n\n        Returns:\n            T_template_filter: The decorated template filter.\n        """"""\n        self.add_template_filter(f, name=name)\n        return f\n\n    return decorator'
True, '""""""\nAdds a template filter to the current context.\n\nThis function is a decorator that takes a template filter as an argument and adds it to the current context.\nThe added filter will be accessible under the specified `name` parameter.\n\nArgs:\n    f (T_template_filter): The template filter to add to the context.\n\nReturns:\n    T_template_filter: The original filter, now decorated with the added functionality.\n\nRaises:\n    ValueError: If the name is not a valid identifier.\n""""""'
True, '""""""\nAdds a template filter to the Jinja environment.\n\nArgs:\n    f (ft.TemplateFilterCallable): The filter function to add.\n    name (str, optional): The name of the filter. If None, uses the function\'s __name__. Defaults to None.\n\nReturns:\n    None\n""""""'
True, '""""""\nTemplate Test Decorator.\n\nThis function returns a decorator that can be used to wrap a template test function.\nThe wrapped function will have its `name` attribute set by the `template_test` function.\n\nArgs:\n    f (Callable[[T_template_test], T_template_test]): The function to be decorated.\n    name (str | None, optional): The name of the template test. Defaults to None.\n\nReturns:\n    Callable[[T_template_test], T_template_test]: The decorated function.\n""""""'
False, '""""""\nDecorates a test function with template testing.\n\nThis function takes a test function `f` as input and adds it to the template tests.\nThe decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n\nRaises:\n    None\n""""""\ndef decorator(f: T_template_test) -> T_template_test:\n    self.add_template_test(f, name=name)\n    return f'
True, '""""""\nAdds a template test to the Jinja environment.\n\nArgs:\n    - `f`: A callable representing the template test.\n    - `name` (optional): The name of the test. If not provided, it defaults to the function\'s name.\n\nReturns:\n    None\n""""""'
True, '""""""\nTemplate Global Decorator\n\nThis function is used to create a template global decorator. It takes a function `f` as an argument and returns the same function wrapped with the `add_template_global` method.\n\nThe `name` parameter can be provided to specify the name of the template global. If not specified, it defaults to None.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n    name (str | None, optional): The name of the template global. Defaults to None.\n\nReturns:\n    T_template_global: The decorated function.\n""""""'
True, '""""""\nDecorates a function to add it as a template global.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n\nReturns:\n    T_template_global: The decorated function.\n""""""'
True, '""""""\nAdds a template global to the Jinja environment.\n\nThis method allows you to add a callable as a global variable in the Jinja environment.\nThe callable can be used in templates using the `{{ }}` syntax, and its name will be used as the key for the global variable.\n\nArgs:\n    f (ft.TemplateGlobalCallable): The callable to add as a global variable.\n    name (str | None, optional): The name of the global variable. If not provided, the name of the callable will be used. Defaults to None.\n\nReturns:\n    None\n""""""'
True, '""""""\nAdds a teardown function to the list of teardown functions and returns the original function.\n\nArgs:\n    f (T_teardown): The teardown function to be added.\n\nReturns:\n    T_teardown: The original teardown function.\n""""""'
True, '""""""\nProcessors for shell context.\n\nThis function is used to register a shell context processor. The processor will be executed when the shell context is processed.\n\nArgs:\n    f (T_shell_context_processor): The processor to be registered.\n\nReturns:\n    T_shell_context_processor: The original processor, which has been appended to the list of shell context processors.\n""""""'
True, '""""""\nFinds the error handler for a given exception.\n\nThis function iterates through the blueprint handlers and class-specific handlers to find a matching error handler.\nIf no match is found, it returns `None`.\n\nArgs:\n    e (Exception): The exception for which to find an error handler.\n\nReturns:\n    ft.ErrorHandlerCallable | None: The error handler for the given exception, or `None` if no match is found.\n""""""'
False, '""""""\nHandles HTTP exceptions by checking their type and returning them accordingly.\n\nIf the exception has no error code, it is returned unchanged as an error.\nIf the exception is a RoutingException, it is also returned unchanged.\nOtherwise, an error handler is found using `_find_error_handler` and the result of calling `ensure_sync` on this handler is returned.'
True, '""""""\nTraps HTTP exceptions based on configuration settings.\n\nThis function determines whether to trap an HTTP exception or not. It checks the `TRAP_HTTP_EXCEPTIONS` setting in the application\'s configuration.\nIf this setting is enabled, the function returns True, indicating that the exception should be trapped.\n\nAdditionally, if `TRAP_BAD_REQUEST_ERRORS` is set to None and the application is in debug mode, key errors are also trapped.\n\nFinally, if `TRAP_BAD_REQUEST_ERRORS` is enabled, only bad request exceptions are trapped. Otherwise, no exceptions are trapped.\n\nArgs:\n    e (Exception): The exception to check.\n\nReturns:\n    bool: True if the exception should be trapped, False otherwise.\n""""""'
False, '""""""\nHandles exceptions raised by the user.\n\nThis function checks for specific exception types and decides how to handle them.\nIf a `BadRequestKeyError` occurs and debug mode or the trap bad request errors config flag are set, it sets the `show_exception` attribute of the error object.\nIt then checks if an HTTPException occurred and is not being trapped. If so, it calls the `handle_http_exception` method to handle the exception.\nIf no error handler can be found for the given exception, it raises the exception again.\nOtherwise, it calls the error handler function with the exception as an argument.\n\nArgs:\n    e (Exception): The exception that was raised by the user.\n\nReturns:\n    HTTPException | ft.ResponseReturnValue: The handled exception or response value.'
True, '""""""\nHandles exceptions raised during request processing.\n\nRaises an exception if propagation is enabled and the current exception\nis different from the one passed in. Otherwise, re-raises the original\nexception. If no error handler is found, logs the exception and returns a\nserver error response.\n\nArgs:\n    e (Exception): The exception to be handled.\n\nReturns:\n    Response: A server error response.\n""""""'
True, '""""""\nLogs an exception with the provided error information.\n\nArgs:\n    - `self`: The instance of the class that this method belongs to.\n    - `exc_info`: A tuple containing the type, value, and traceback of the exception. Can be a single value if only one is available (e.g., for sys.exc_info()).\n\nReturns:\n    None\n""""""'
False, '""""""\nRaises a routing exception if the request is not debuggable, \nor if it\'s a redirect with an invalid status code or method.\n\nArgs:\n    request (Request): The incoming HTTP request.\n\nReturns:\n    None\n""""""\ndef raise_routing_exception(self, request: Request) -> t.NoReturn:\n    ...\n'
False, 'def dispatch_request(self) -> ft.ResponseReturnValue:\n    """"""\n    Dispatches a request to the corresponding endpoint.\n\n    If automatic options are provided for the URL and the request is an OPTIONS method,\n    it returns a default options response. Otherwise, it calls the view function with\n    the provided view arguments.\n\n    :return: The response from the dispatched view function.\n    """"""'
True, '""""""\nDispatches the full request and handles any exceptions that may occur.\n\nThis method initiates the request dispatching process, ensuring that all necessary steps are taken to fulfill the user\'s request.\nIt also catches any exceptions that may be raised during this process and handles them accordingly.\n\nReturns:\n    Response: The response object after successful request dispatching or exception handling.\n\nRaises:\n    Exception: If an error occurs during request dispatching or exception handling.\n""""""'
True, '""""""\nFinalizes a request by processing the response and sending a signal to indicate that the request has finished.\n\nArgs:\n    rv (ft.ResponseReturnValue | HTTPException): The response value or exception to be finalized.\n    from_error_handler (bool, optional): Whether this is being called from an error handler. Defaults to False.\n\nReturns:\n    Response: The finalized response object.\n\nRaises:\n    Exception: If the request finalizing fails and `from_error_handler` is False.\n""""""'
True, '""""""\nReturns a default options response for the current request.\n\nThis method creates a new response object with the allowed HTTP methods from the URL adapter.\nThe `allow` attribute of the response is updated to include these methods, allowing the client to specify which methods are supported by the server.\n\nArgs:\n    None\n\nReturns:\n    Response: A new response object with the default options configuration.\n""""""'
True, '""""""\nDetermines whether an exception should be ignored.\n\nArgs:\n    error (BaseException | None): The exception to check. Can be None for no exception.\nReturns:\n    bool: True if the exception should be ignored, False otherwise.\n""""""'
True, '""""""\nEnsures that a provided function is synchronous by converting it to a synchronous function if it\'s a coroutine.\n\nArgs:\n    func (t.Callable): The function to be ensured as synchronous.\n\nReturns:\n    t.Callable: The synchronous version of the input function, or the original function if it\'s already synchronous.\n""""""'
True, '""""""\nConverts an asynchronous function to a synchronous one.\n\nThis function takes an asynchronous callable and returns a new function that can be called synchronously.\nIt uses the `asgiref.sync.async_to_sync` function from Flask, which is only available when Flask is installed with the \'async\' extra.\n\nIf the required import fails, it raises a RuntimeError indicating that Flask needs to be installed with the \'async\' extra.\n\nArgs:\n    func: The asynchronous function to convert.\n\nReturns:\n    A new synchronous function wrapping the original asynchronous one.\n""""""'
False, 'def url_for(\n    """"""\n    Generates a URL for the given endpoint.\n\n    This function is used to generate URLs for endpoints in a Flask application.\n    It takes into account various parameters such as scheme, domain, and anchor,\n    and returns a fully qualified URL.\n\n    Args:\n        endpoint (str): The endpoint for which to generate the URL.\n        _anchor (str | None): An optional anchor for the URL. Defaults to None.\n        _method (str | None): The HTTP method for the URL. Defaults to None.\n        _scheme (str | None): The scheme for the URL. Defaults to None.\n        _external (bool | None): Whether the URL is external or not. Defaults to None.\n        **values: t.Any**: Additional values to include in the URL.\n\n    Returns:\n        str: The generated URL.\n\n    Raises:\n        RuntimeError: If unable to build URLs outside an active request without \'SERVER_NAME\' configured.\n        ValueError: If \'_scheme\' is specified when \'_external\' is False.\n    """"""\n) -> str:\n    req_ctx = _cv_request.get(None)\n\n    if req_ctx is not None:\n        url_adapter = req_ctx.url_adapter\n        blueprint_name = req_ctx.request.blueprint\n\n        # If the endpoint starts with ""."" and the request matches a\n        # blueprint, the endpoint is relative to the blueprint.\n        if endpoint[:1] == ""."":\n            if blueprint_name is not None:\n                endpoint = f""{blueprint_name}{endpoint}""\n            else:\n                endpoint = endpoint[1:]\n\n        # When in a request, generate a URL without scheme and\n        # domain by default, unless a scheme is given.\n        if _external is None:\n            _external = _scheme is not None\n    else:\n        app_ctx = _cv_app.get(None)\n\n        # If called by helpers.url_for, an app context is active,\n        # use its url_adapter. Otherwise, app.url_for was called\n        # directly, build an adapter.\n        if app_ctx is not None:\n            url_adapter = app_ctx.url_adapter\n        else:\n            url_adapter = self.create_url_adapter(None)\n\n        if url_adapter is None:\n            raise RuntimeError(\n                ""Unable to build URLs outside an active request""\n                "" without \'SERVER_NAME\' configured. Also configure""\n                "" \'APPLICATION_ROOT\' and \'PREFERRED_URL_SCHEME\' as""\n                "" needed.""\n            )\n\n        # When outside a request, generate a URL with scheme and\n        # domain by default.\n        if _external is None:\n            _external = True\n\n    # It is an error to set _scheme when _external=False, in order\n    # to avoid accidental insecure URLs.\n    if _scheme is not None and not _external:\n        raise ValueError(""When specifying \'_scheme\', \'_external\' must be True."")\n\n    self.inject_url_defaults(endpoint, values)\n\n    try:\n        rv = url_adapter.build(  # type: ignore[union-attr]\n            endpoint,\n            values,\n            method=_method,\n            url_scheme=_scheme,\n            force_external=_external,\n        )\n    except BuildError as error:\n        values.update(\n            _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n        )\n        return self.handle_url_build_error(error, endpoint, values)\n\n    if _anchor is not None:\n        _anchor = _url_quote(_anchor, safe=""%!#$&\'()*+,/:;=?@"")\n        rv = f""{rv}#{_anchor}""\n\n    return rv'
True, '""""""\nRedirects to a specified URL with an optional HTTP status code.\n\nArgs:\n    location (str): The URL to redirect to.\n    code (int, optional): The HTTP status code. Defaults to 302.\n\nReturns:\n    BaseResponse: A response object containing the redirect URL and status code.\n""""""'
False, 'def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response object is created based on the type of the view function result.\n    If the result is a tuple, it is unpacked into body, status, and headers.\n    If the result is None, a TypeError is raised.\n    If the result is not an instance of the response class, it is converted to\n    the correct type.\n\n    Args:\n        rv: The view function result.\n\n    Returns:\n        A Response object.\n\n    Raises:\n        TypeError: If the view function did not return a valid response tuple,\n            or if the result is None.\n    """"""'
True, '""""""\nCreates a URL adapter for the current request.\n\nIf `subdomain_matching` is disabled, uses the default subdomain in all cases.\nOtherwise, does not use a subdomain. The adapter binds to the environment,\nserver name, and other configuration settings from the application\'s config.\n\nReturns:\n    MapAdapter | None: A bound URL map adapter or None if no adapter can be created.\n""""""'
False, 'def inject_url_defaults(self, endpoint: str, values: dict) -> None:\n    """"""\n    Injects URL defaults into the given endpoint.\n\n    This function is used to populate URL parameters with default values.\n    It can be called outside of a request context and will parse the\n    passed endpoint accordingly. The function iterates over the names\n    in the `self.url_default_functions` dictionary, calling each function\n    for the corresponding name with the given endpoint and values.\n\n    Args:\n        endpoint (str): The URL endpoint to inject defaults into.\n        values (dict): A dictionary of values to be injected into the endpoint.\n\n    Returns:\n        None\n    """"""'
False, '""""""\nHandles URL build errors by iterating over a list of handlers and attempting to resolve the issue.\n\nArgs:\n    - self: The instance of the class that contains this method.\n    - error (BuildError): The error encountered during URL building.\n    - endpoint (str): The endpoint being built.\n    - values (dict[str, t.Any]): A dictionary of values used in the URL build process.\n\nReturns:\n    str: The resolved URL or None if no handler could resolve it.\n\nRaises:\n    BuildError: If an active exception is encountered and cannot be re-raised.\n""""""\ndef handle_url_build_error(\n        self, error: BuildError, endpoint: str, values: dict[str, t.Any]\n    ) -> str:\n        for handler in self.url_build_error_handlers:\n            try:\n                rv = handler(error, endpoint, values)\n            except BuildError as e:\n                # make error available outside except block\n                error = e\n            else:\n                if rv is not None:\n                    return rv\n\n        # Re-raise if called with an active exception, otherwise raise\n        # the passed in exception.\n        if error is sys.exc_info()[1]:\n            raise\n\n        raise error'
True, '""""""\nPreprocesses the request by applying URL value preprocessors and before request functions.\n\nThis method iterates over the blueprint names in reverse order, applying any URL value preprocessors to each endpoint.\nIt then checks for any before request functions associated with the current blueprint and executes them if present.\n\nIf a before request function returns a non-None response, it is returned immediately. Otherwise, the method proceeds to check the next blueprint.\n\nReturns:\n    ft.ResponseReturnValue | None: The result of the last executed before request function, or None if no such function was found.\n""""""'
True, '""""""\nProcesses the given response by executing any after-request functions and saving the session.\n\nArgs:\n    response (Response): The response to be processed.\n\nReturns:\n    Response: The processed response.\n""""""'
False, '""""""\n    Performs teardown operations for the current request.\n\n    This function is responsible for executing any necessary cleanup or rollback\n    actions after a request has been completed. It iterates through the available\n    teardown functions and executes them in reverse order to ensure that resources\n    are properly cleaned up before moving on to the next one.\n\n    Args:\n        exc (BaseException | None): The exception being handled, if any.\n            Defaults to `_sentinel` to avoid raising an exception during initialization.\n    """"""\ndef do_teardown_request(\n    self, \n    exc: BaseException | None = _sentinel  # type: ignore\n) -> None:\n    ...\n'
True, '""""""\nTear down the application context.\n\nThis function is called after the application context has been torn down. It ensures that any teardown functions are executed in a synchronous manner and sends an event to notify other parts of the application that the context is being torn down.\n\nArgs:\n    exc (BaseException | None): The exception that caused the tear down, or None if no exception was raised.\n        Defaults to `_sentinel` which will be replaced with the actual exception if present.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns an instance of `AppContext` initialized with the current object.\n\nArgs:\n    None\n\nReturns:\n    AppContext: An instance of `AppContext` initialized with the current object.\n""""""'
True, '""""""\nReturns a new instance of RequestContext with the given environment.\n\nArgs:\n    environ (dict): The current HTTP environment.\n\nReturns:\n    RequestContext: A new instance of RequestContext.\n""""""'
True, '""""""\nTests the creation of a request context using an `EnvironBuilder`.\n\nThis function creates an instance of `EnvironBuilder` with the provided arguments,\nuses it to create an environment, and then attempts to create a request context\nusing that environment. The `finally` block ensures the `EnvironBuilder` is properly\nclosed after use.\n\nArgs:\n    *args: Variable number of positional arguments to pass to the `EnvironBuilder`.\n    **kwargs: Keyword arguments to pass to the `EnvironBuilder`.\n\nReturns:\n    A `RequestContext` object representing the created request context.\nRaises:\n    Exception: If an error occurs while creating the request context.\n""""""'
True, '""""""\nWSGI Application Function\n\nThis function serves as the entry point for the WSGI application. It takes in an environment dictionary and a start response callable, \nand returns any response object generated by the application.\n\nThe function first creates a request context using `self.request_context(environ)`. It then attempts to execute the full dispatch of the request,\nhandling any exceptions that may occur during this process. If an exception is caught, it will be handled and propagated up the call stack.\nFinally, the response object is returned to the caller.\n\nNote: This function should not be called directly by users of the application. Instead, it should be used as part of a larger WSGI server or framework.\n""""""'
True, '""""""\n    Calls the WSGI application with the provided environment and response callback.\n\n    Args:\n        environ (dict): The HTTP request environment.\n        start_response (t.Callable): A callable that takes a status code and headers as arguments.\n\n    Returns:\n        t.Any: The result of calling the WSGI application.\n\n    Note:\n        This method is part of the WSGI protocol and is used to call the WSGI application with the provided environment and response callback.\n""""""'
False, 'def __init__(\n    """"""\n    Initializes a new instance of the BlueprintSetupState class.\n\n    This method is called when an application is created and it\'s necessary to\n    set up the blueprint state. It takes in several parameters, including the\n    Flask app, the Blueprint object, options for the blueprint, and a boolean\n    indicating whether this is the first registration of the blueprint.\n\n    Args:\n        blueprint (Blueprint): A reference to the blueprint that created this setup state.\n        app (Flask): A reference to the current application.\n        options (t.Any): A dictionary with all options that were passed to the register_blueprint method.\n        first_registration (bool): As blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.\n\n    Returns:\n        None\n    """"""\n    self.app = app\n    self.blueprint = blueprint\n    self.options = options\n    self.first_registration = first_registration\n\n    subdomain = self.options.get(""subdomain"")\n    if subdomain is None:\n        subdomain = self.blueprint.subdomain\n\n    self.subdomain = subdomain\n\n    url_prefix = self.options.get(""url_prefix"")\n    if url_prefix is None:\n        url_prefix = self.blueprint.url_prefix\n    self.url_prefix = url_prefix\n\n    self.name = self.options.get(""name"", blueprint.name)\n    self.name_prefix = self.options.get(""name_prefix"", """")\n\n    self.url_defaults = dict(self.blueprint.url_values_defaults)\n    self.url_defaults.update(self.options.get(""url_defaults"", ()))'
True, '""""""\nAdds a URL rule to the application.\n\nParameters:\n    rule (str): The URL pattern.\n    endpoint (str | None, optional): The endpoint name. Defaults to None.\n    view_func (t.Callable | None, optional): The view function. Defaults to None.\n    **options (t.Any): Additional options for the URL rule.\n\nReturns:\n    None\n""""""'
True, '""""""\nInitialize a Flask Blueprint.\n\nThis function initializes a new Flask Blueprint with the given parameters. It sets up the blueprint\'s metadata and configuration options.\n\nParameters:\n    name (str): The name of the blueprint.\n    import_name (str): The import name of the blueprint.\n    static_folder (str | os.PathLike | None, optional): The folder containing static files. Defaults to None.\n    static_url_path (str | None, optional): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike | None, optional): The folder containing templates. Defaults to None.\n    url_prefix (str | None, optional): The prefix for URLs. Defaults to None.\n    subdomain (str | None, optional): The subdomain for the blueprint. Defaults to None.\n    url_defaults (dict | None, optional): Default values for URL parameters. Defaults to None.\n    root_path (str | None, optional): The root path of the blueprint. Defaults to None.\n    cli_group (str | None, optional): The CLI group for the blueprint. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the blueprint.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for the blueprint.\n    deferred_functions (list[DeferredSetupFunction]): A list of deferred setup functions.\n    url_values_defaults (dict): Default values for URL parameters.\n    cli_group (str): The CLI group for the blueprint.\n    _blueprints (list[tuple[Blueprint, dict]]): A list of blueprints and their configurations.\n\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
False, '""""""\nRecords a callable function to be executed later.\n\nArgs:\n    func (t.Callable): The function to be recorded.\n\nReturns:\n    None\n""""""\ndef record(self, func: t.Callable) -> None:\n    """"""\n    Records a callable function to be executed later.\n\n    Args:\n        func (t.Callable): The function to be recorded.\n    """"""\n    self.deferred_functions.append(func)'
True, '""""""\nRecords a function to be executed once during the first registration of a blueprint.\n\nThis method is used to register a function that should only be executed during the initial setup of a blueprint.\nThe function will be called when the blueprint\'s first registration occurs.\n\nArgs:\n    func (t.Callable): The function to be recorded and executed.\n\nReturns:\n    None\n""""""'
True, '""""""\nWrapper function to handle first registration of users.\n\nThis function checks if the user has registered for the first time and calls the `func` function with the provided `state` object if so.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application setup.\n\nReturns:\n    None\n""""""'
True, '""""""\nCreates a new setup state for the given application.\n\nArgs:\n    - `app`: The Flask application instance.\n    - `options`: A dictionary of configuration options.\n    - `first_registration` (optional): Whether this is the first registration. Defaults to False.\n\nReturns:\n    A BlueprintSetupState object representing the created setup state.\n\nRaises:\n    None\n""""""'
True, '""""""\nRegisters a blueprint with the current instance.\n\nArgs:\n    - blueprint (Blueprint): The blueprint to be registered.\n    - **options (t.Any): Optional keyword arguments for the blueprint registration.\n\nRaises:\n    ValueError: If the provided blueprint is the same as the current instance.\n\nReturns:\n    None\n""""""'
False, 'def register(self, app: Flask, options: dict) -> None:\n    """"""\n    Registers the current Blueprint with the given Flask application.\n\n    This method checks for duplicate names and merges the Blueprint\'s data into the parent Blueprint.\n    It also sets up static file serving, error handling, view functions, and other settings as needed.\n\n    Args:\n        app (Flask): The Flask application to register the Blueprint with.\n        options (dict): A dictionary of options to pass to the Blueprint.\n\n    Raises:\n        ValueError: If a duplicate name is found for the current Blueprint.\n\n    Returns:\n        None\n    """"""'
True, '""""""\nExtends a dictionary with another dictionary\'s values.\n\nThis function takes two dictionaries as input: `bp_dict` and `parent_dict`. It iterates over the items in `bp_dict`, \nconstructs new keys by appending the current key to the parent dictionary\'s name if it exists, and extends the \nvalues of the corresponding item in `parent_dict`.\n\nArgs:\n    bp_dict (dict): The dictionary containing values to be extended.\n    parent_dict (dict): The dictionary whose values will be extended.\n\nReturns:\n    None\n""""""'
True, '""""""\nAdds a URL rule to the application.\n\nThis method is used to register a new route for the application. It takes in several parameters:\n\n- `rule`: The path of the URL rule.\n- `endpoint`: The name of the endpoint associated with this URL rule (optional).\n- `view_func`: The view function that will handle requests to this URL rule (optional).\n- `provide_automatic_options`: A boolean indicating whether to provide automatic options for this URL rule (optional).\n- `**options`: Any additional keyword arguments to pass to the `add_url_rule` method of the view function.\n\nIf either the `endpoint` or `view_func.__name__` contains a dot (\'.\'), a ValueError is raised. The `record` method is then called with a closure that adds this URL rule to the application.\n\nReturns:\n    None\n""""""'
False, 'def app_template_filter(\n    """"""\n    A function that returns a decorator to add an application template filter.\n\n    Args:\n        name (str | None): The name of the template filter. Defaults to None.\n\n    Returns:\n        T.Callable[[T_template_filter], T_template_filter]: A decorator function.\n    """""")'
False, '""""""\nAdds a template filter to the application.\n\nThis function takes a template filter as input and adds it to the application.\nThe added filter is then returned by this function.\n\nArgs:\n    f (T_template_filter): The template filter to be added.\n\nReturns:\n    T_template_filter: The original template filter with the added functionality.\n\nRaises:\n    None\n""""""\ndef decorator(f: T_template_filter) -> T_template_filter:\n    self.add_app_template_filter(f, name=name)\n    return f'
True, '""""""\nAdds a template filter to the application\'s Jinja environment.\n\nThis function registers a new template filter with the given name, which can be used in templates to perform custom operations. If no name is provided, the filter will be registered under its original name (i.e., the name of the `f` function).\n\nArgs:\n    f: A callable that implements the template filter functionality.\n    name: The name under which the filter should be registered (optional). Defaults to None.\n\nReturns:\n    None\n""""""'
True, '""""""\nRegisters a Jinja2 filter with the given application state.\n\nArgs:\n    state (BlueprintSetupState): The application state to modify.\n\nReturns:\n    None\n""""""'
True, '""""""\nDecorates a function with the `app_template_test` metadata.\n\nThis decorator adds an application template test to the decorated function.\nIt takes an optional `name` parameter to specify the test name.\n\nArgs:\n    f (Callable): The function to be decorated.\n    name (str, optional): The name of the test. Defaults to None.\n\nReturns:\n    Callable: The decorated function with added metadata.\n""""""'
True, '""""""\nDecorates a test function with an application template test.\n\nThis function takes a test function `f` as input and adds it to the list of \napplication template tests. The decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n""""""'
True, '""""""\nAdds a template test to the application\'s Jinja environment.\n\nThis function registers a template test with the given name (defaulting to the test function\'s name if not provided).\n\nArgs:\n    f (ft.TemplateTestCallable): The test function to register.\n    name (str | None, optional): The name of the test. Defaults to None.\n\nReturns:\n    None\n""""""'
True, '""""""\nRegisters a Jinja template test in the application\'s setup state.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application\'s setup.\n\nReturns:\n    None\n""""""'
True, '""""""\nDecorates a function to make it available as an application template global.\n\nThis decorator adds the decorated function to the list of application template globals.\nIt is typically used in conjunction with the `add_app_template_global` method.\n\nArgs:\n    name (str | None): The name under which the decorated function should be added. If None, no name will be specified.\n\nReturns:\n    T_template_global: A decorator function that adds the decorated function to the list of application template globals.\n""""""'
True, '""""""\nDecorates a function to add it as an app template global.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n\nReturns:\n    T_template_global: The decorated function.\n""""""'
True, '""""""\nAdds a template global to the application.\n\nThis function registers a template global with the given name. If no name is provided, it defaults to the name of the provided callable.\n\nArgs:\n    f (ft.TemplateGlobalCallable): The callable to register as a template global.\n    name (str | None, optional): The name of the template global. Defaults to None.\n\nReturns:\n    None\n""""""'
True, '""""""\nRegisters a template as a global variable in the Jinja environment.\n\nArgs:\n    state (BlueprintSetupState): The current setup state of the application.\n    \nReturns:\n    None\n    \nRaises:\n    TypeError: If `state` is not an instance of BlueprintSetupState.\n""""""'
True, '""""""\nRecords a function to be executed before the application request.\n\nArgs:\n    f (T_before_request): The function to be recorded.\n\nReturns:\n    T_before_request: The input function with the record added.\n""""""'
True, '""""""\nRecords a function as an \'after-app-request\' hook.\n\nArgs:\n    f (T_after_request): The function to be recorded.\n\nReturns:\n    T_after_request: The input function.\n""""""'
True, '""""""\nRecords a teardown request function for the current application context.\n\nArgs:\n    f (T_teardown): The teardown request function to be recorded.\n\nReturns:\n    T_teardown: The original teardown request function.\n""""""'
True, '""""""\nProcesses the template context for an application.\n\nThis function is used to add a new template context processor to the existing list.\nIt ensures that the processor is added only once by using the `record_once` method.\n\nArgs:\n    f (T_template_context_processor): The template context processor to be added.\n\nReturns:\n    T_template_context_processor: The original template context processor, which has been modified in-place.\n""""""'
True, '""""""\nApp Error Handler Decorator.\n\nThis function returns a decorator that can be used to handle application errors.\nThe decorator takes an error handling function as input and wraps it with the provided app error handler.\n\nArgs:\n    code (type[Exception] | int): The type of exception or error code to use for error handling.\n    f (T_error_handler): The error handling function to wrap.\n\nReturns:\n    T_error_handler: The wrapped error handling function.\n\nExample:\n    @app_errorhandler(404)\n    def handle_404(f):\n        # Handle 404 errors\n        pass\n\n    @app_errorhandler(Exception)\n    def handle_all_errors(f):\n        # Handle all exceptions\n        pass\n""""""'
True, '""""""\nDecorates a function with error handling.\n\nThis decorator records the first occurrence of an exception and uses it to update the application\'s error handler.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The decorated function.\n""""""'
True, '""""""\nPreprocesses the given URL value preprocessor and records it in the application\'s internal state.\n\nArgs:\n    f (T_url_value_preprocessor): The URL value preprocessor to be recorded.\n\nReturns:\n    T_url_value_preprocessor: The original preprocessor, which has been marked as recorded.\n""""""'
True, '""""""\nReturns a URL default function and records it in the `url_default_functions` set.\n\nArgs:\n    f (T_url_defaults): The URL default function to be returned.\n\nReturns:\n    T_url_defaults: The provided URL default function.\n""""""'
True, '""""""\nDecorates a method with setup functionality.\n\nThis decorator sets up the method by checking if the setup process is finished\nand updating the wrapper function to include the original method\'s metadata.\n\nArgs:\n    f (function): The method to be decorated.\n\nReturns:\n    function: The decorated method.\n""""""'
True, '""""""\nWrapper function for a specific class method.\n\nThis function checks if the setup is finished before calling the original method.\nIt then calls the original method with the provided arguments and returns its result.\n\nArgs:\n    self: The instance of the class that owns this method.\n    *args: Variable number of positional arguments to be passed to the original method.\n    **kwargs: Variable number of keyword arguments to be passed to the original method.\n\nReturns:\n    The result of the original method call.\n\nRaises:\n    None\n""""""'
True, '""""""\nInitialize a Flask application.\n\nThis function initializes a new instance of the Flask class. It takes several\nparameters that define the configuration and behavior of the application.\n\nParameters:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike | None, optional): The path to the static folder. Defaults to None.\n    static_url_path (str | None, optional): The URL path for static files. Defaults to None.\n    template_folder (str | os.PathLike | None, optional): The path to the templates folder. Defaults to None.\n    root_path (str | None, optional): The absolute path to the package on the filesystem. Defaults to None.\n\nAttributes:\n    import_name (str): The name of the package or module that this object belongs to.\n    static_folder (str | os.PathLike | None): The path to the static folder.\n    static_url_path (str | None): The URL path for static files.\n    template_folder (str | os.PathLike | None): The path to the templates folder.\n    root_path (str | None): The absolute path to the package on the filesystem.\n    cli (AppGroup): The Click command group for registering CLI commands.\n    view_functions (dict[str, t.Callable]): A dictionary mapping endpoint names to view functions.\n    error_handler_spec (dict[ft.AppOrBlueprintKey, dict[int | None, dict[type[Exception], ft.ErrorHandlerCallable]]]): A data structure of registered error handlers.\n    before_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.BeforeRequestCallable]]): A data structure of functions to call at the beginning of each request.\n    after_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.AfterRequestCallable]]): A data structure of functions to call at the end of each request.\n    teardown_request_funcs (dict[ft.AppOrBlueprintKey, list[ft.TeardownCallable]]): A data structure of functions to call to pass extra context values when rendering templates.\n    template_context_processors (dict[ft.AppOrBlueprintKey, list[ft.TemplateContextProcessorCallable]]): A data structure of functions to call to modify the keyword arguments passed to the view function.\n    url_value_preprocessors (dict[ft.AppOrBlueprintKey, list[ft.URLValuePreprocessorCallable]]): A data structure of functions to call to modify the keyword arguments when generating URLs.\n    url_default_functions (dict[ft.AppOrBlueprintKey, list[ft.URLDefaultCallable]]): A data structure of functions to call to modify the keyword arguments when generating URLs.\n\nRaises:\n    TypeError: If any parameter is not of the correct type.\n""""""'
True, '""""""\nReturns a string representation of the object.\n\nThis method is used to provide a human-readable representation of the object, \nincluding its type and name. It is typically used for debugging purposes or \nwhen displaying objects in a user interface.\n\nArgs:\n    None\n\nReturns:\n    str: A string representation of the object.\n""""""'
True, '""""""\nRaises a NotImplementedError when setup is not finished.\n\nThis method should be implemented by subclasses to check if the setup process is complete.\nIf the setup is not finished, it raises a NotImplementedError with an appropriate message.\n\nArgs:\n    f_name (str): The name of the file being checked.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the path to the static folder. If no static folder has been set, returns None.\n\nArgs:\n    None\n\nReturns:\n    str | None: The path to the static folder or None if not set.\n""""""'
True, '""""""\nSets the path to a static folder.\n\nThis method takes a string or Path-like object representing the path to a static folder.\nIf the provided path is absolute, it will be normalized and any trailing slash removed.\nThe resulting path is then stored in the `_static_folder` attribute of the instance.\n\nArgs:\n    value (str | os.PathLike | None): The path to the static folder.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns whether the object has a static folder.\n\nThis method checks if the `static_folder` attribute of the object is not None.\nIt can be used to determine if the object has a static folder available for serving files. \n\nArgs:\n    None\n\nReturns:\n    bool: True if the object has a static folder, False otherwise\n""""""'
True, '""""""\nReturns the static URL path for this object.\n\nIf a precomputed URL path exists, it returns that. Otherwise, it constructs a URL path from the `static_folder` attribute by taking the basename of the folder and appending it to the root URL.\n\nReturns:\n    str | None: The static URL path or None if no valid path can be constructed.\n""""""'
True, '""""""\nReturns a static URL path.\n\nThis method takes a string or None as input and returns the URL path after removing any trailing slashes. If the input is None, it sets the internal `_static_url_path` attribute to None.\n\nArgs:\n    value (str | None): The URL path to be processed.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to use for retrieving the default send file max age. Defaults to None.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default is set.\n""""""'
True, '""""""\nSends a static file from the configured static folder.\n\nThis method is used to serve static files. It checks if the `static_folder` attribute has been set and raises a RuntimeError if not.\nIt then calls `get_send_file_max_age` to determine the maximum age for the file, which is necessary for blueprints to work correctly.\nFinally, it uses `send_from_directory` to send the file from the static folder.\n\nArgs:\n    filename (str): The name of the file to be sent.\n\nReturns:\n    Response: A response object containing the sent file.\n\nRaises:\n    RuntimeError: If \'static_folder\' is not set.\n""""""'
True, '""""""\nLoads a Jinja template loader based on the presence of a template folder.\n\nReturns:\n    FileSystemLoader: A Jinja template loader instance if a template folder is found.\n    None: No template folder found, returns None.\n""""""'
True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str, optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"", ""rt"", and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""'
True, '""""""\nDetermine and apply a route method.\n\nThis function is used internally by the class to determine and apply a specific route method.\nIt takes in the method name, rule, and options as parameters. If the \'methods\' key exists in the options dictionary,\nit raises a TypeError indicating that the \'route\' decorator should be used instead.\n\nArgs:\n    self: The instance of the class.\n    method (str): The name of the route method to apply.\n    rule (str): The rule for which the method is applied.\n    options (dict): A dictionary containing additional options for the route.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that applies the specified route method to a given route object.\n\nRaises:\n    TypeError: If the \'methods\' key exists in the options dictionary, indicating that the \'route\' decorator should be used.\n""""""'
True, '""""""\nReturns a callable function for handling HTTP GET requests.\n\nArgs:\n    rule (str): The route to be handled.\n    **options (t.Any): Additional keyword arguments to be passed to the method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that handles HTTP GET requests.\n""""""'
False, '""""""\nPost a route to the server.\n\nThis function is used to create or update a route on the server. It takes in a rule and optional parameters, then returns a callable that can be used to post data to the specified route.\n\nArgs:\n    rule (str): The rule for the route.\n    **options: t.Any: Optional parameters for the route.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable that can be used to post data to the specified route.'
True, '""""""\nReturns a callable function for handling HTTP PUT requests.\n\nArgs:\n    rule (str): The route to be handled.\n    **options (t.Any): Additional keyword arguments to be passed to the underlying method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that handles HTTP PUT requests for the given rule.\n""""""'
True, '""""""\nDeletes a route.\n\nArgs:\n    rule (str): The path of the route to be deleted.\n    **options (t.Any): Additional keyword arguments for the method.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable function that deletes the specified route.\n\nRaises:\n    ValueError: If the rule is not a valid path.\n""""""'
True, '""""""\nPatches a route with the specified rule and options.\n\nArgs:\n    rule (str): The rule to patch.\n    **options (t.Any): Additional options for the route.\n\nReturns:\n    t.Callable[[T_route], T_route]: A callable that patches the route.\n\nRaises:\n    None\n""""""'
True, '""""""\nRoute a URL pattern to a view function.\n\nThis function is used to create a route for a given URL pattern. It takes in the rule of the URL and any additional options as keyword arguments. The `endpoint` option can be provided to specify an endpoint name, which will be used when adding the URL rule.\n\nThe returned decorator function can be applied to view functions to register them with this router.\n\nArgs:\n    rule (str): The URL pattern to route.\n    **options: t.Any: Additional options for the URL rule. Can include \'endpoint\' to specify an endpoint name.\n\nReturns:\n    T_route -> T_route: A decorator function that registers a view function with this router.\n""""""'
True, '""""""\nDecorates a function to register it as an endpoint.\n\nThis decorator takes a function `f` and registers it with the Flask application.\nIt also populates the ""endpoint"" key in the options dictionary if present,\nand passes the remaining options to the `add_url_rule` method.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function, now registered as an endpoint.\n""""""'
False, '""""""\nAdds a URL rule to the application.\n\nThis method is used to register a new route for the application. It takes in several parameters:\n\n- `rule`: The URL pattern that will be matched by this rule.\n- `endpoint`: The view function that will handle requests to this URL (optional).\n- `view_func`: An alternative way to specify the endpoint (ft.RouteCallable type).\n- `provide_automatic_options`: Whether or not to provide automatic options for this route (bool type, default is None).\n- `**options`: Any additional keyword arguments that can be passed to the view function.\n\nThis method raises a NotImplementedError as it is currently not implemented.'
True, '""""""\nEndpoint Decorator Function\n\nThis function is a decorator that registers an endpoint with the provided endpoint string.\nIt takes in a function `f` and returns a new function that wraps the original function, \nregistering it as a view function for the specified endpoint.\n\nArgs:\n    endpoint (str): The endpoint to register the function under.\n    f (Callable[[F], F]): The function to be registered as a view function.\n\nReturns:\n    Callable[[F], F]: A new function that wraps the original function and registers it as a view function.\n""""""'
True, '""""""\nDecorates a view function with endpoint information.\n\nThis function is used to register and decorate view functions for use in the application.\nIt takes a view function `f` as an argument, adds it to the `view_functions` dictionary \nwith the current endpoint, and then returns the original function. This allows for easy\nmanagement of view functions and their corresponding endpoints.\n\nArgs:\n    f (F): The view function to be decorated.\n\nReturns:\n    F: The decorated view function.\n""""""'
True, '""""""\nAdds a request handler function to the `before_request_funcs` set.\n\nArgs:\n    f (T_before_request): The request handler function to be added.\n\nReturns:\n    T_before_request: The original request handler function.\n""""""'
True, '""""""\nAdds a request handler function to the `after_request_funcs` set.\n\nArgs:\n    f (T_after_request): The request handler function to be added.\n\nReturns:\n    T_after_request: The original request handler function.\n""""""'
True, '""""""\nAdds a teardown request function to the internal list of teardown functions.\n\nArgs:\n    f (T_teardown): The teardown request function to be added.\n\nReturns:\n    T_teardown: The original teardown request function.\n""""""'
True, '""""""\nProcesses a template context processor.\n\nThis function is used to register and manage template context processors.\nIt takes in a `f` parameter, which is the template context processor to be added,\nand returns the same `f` after adding it to the list of registered processors.\n\nArgs:\n    f (T_template_context_processor): The template context processor to be added.\n\nReturns:\n    T_template_context_processor: The original template context processor.\n""""""'
True, '""""""\nPreprocesses a URL value by appending it to the list of preprocessed values.\n\nArgs:\n    f (T_url_value_preprocessor): The URL value to be preprocessed.\n\nReturns:\n    T_url_value_preprocessor: The preprocessed URL value.\n""""""'
True, '""""""\nAdds a URL defaults function to the `url_default_functions` dictionary.\n\nArgs:\n    f (T_url_defaults): The URL defaults function to be added.\n\nReturns:\n    T_url_defaults: The provided URL defaults function, which is then appended to the `url_default_functions` dictionary.\n""""""'
True, '""""""\nDecorates a function to handle specific exceptions.\n\nThis function returns a decorator that registers the provided function as an error handler for the specified exception type or code. The decorated function will be called when the registered exception is raised.\n\nArgs:\n    self: The instance of the class that this method belongs to.\n    code_or_exception (type[Exception] | int): The type of exception or code to register the decorator for.\n    f (T_error_handler): The function to decorate as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""'
True, '""""""\nDecorates a function to register it as an error handler.\n\nThis decorator takes a function `f` that handles errors and registers it with the \n`register_error_handler` method. The decorated function is then returned.\n\nArgs:\n    f (T_error_handler): The function to be registered as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""'
True, '""""""\nRegisters an error handler for a specific exception class or code.\n\nArgs:\n    - `self`: The instance of the class that this method belongs to.\n    - `code_or_exception`: A type hint indicating whether it\'s an exception class (type[Exception]) or an integer representing an HTTP status code. This parameter is used to determine which part of the error handler specification to update.\n    - `f`: An instance of ft.ErrorHandlerCallable, which represents a function that will be called when an error occurs.\n\nReturns:\n    None\n\nRaises:\n    None\n""""""'
True, '""""""\nReturns the exception class and its corresponding code (if applicable) from a given exception class or code.\n\nArgs:\n    exc_class_or_code: The exception class or code to retrieve. Can be an instance of Exception or an integer representing an HTTP error code.\n\nReturns:\n    A tuple containing the exception class and its code (or None if not applicable).\nRaises:\n    ValueError: If the provided code is not a recognized HTTP error code.\n    TypeError: If the provided value is not an instance of Exception or an integer representing an HTTP error code, or if it\'s an instance of Exception instead of a class.\n""""""'
False, 'def _endpoint_from_view_func(view_func: callable) -> str:\n    """"""\n    Extracts the endpoint name from a given view function.\n\n    Args:\n        view_func (callable): The view function to extract the endpoint from.\n\n    Returns:\n        str: The endpoint name of the provided view function.\n\n    Raises:\n        AssertionError: If no view function is provided.\n    """"""'
False, '""""""\nChecks if a given path is relative to another base path.\n\nArgs:\n    path (pathlib.PurePath): The path to check.\n    base (str): The base path to compare against.\n\nReturns:\n    bool: True if the path is relative to the base, False otherwise.'
False, '""""""\nFind the path to a Python package or module.\n\nThis function takes an import name as input and returns the path to the corresponding package or module.\nIf the package or module is not found, it raises a ValueError. If the import fails for any reason, it falls back to the current working directory.\n\nParameters:\n    import_name (str): The name of the package or module to find.\n\nReturns:\n    str: The path to the package or module.\n\nRaises:\n    ValueError: If the package or module is not found.\n""""""\n\ndef _find_package_path(import_name):\n    # ... (rest of the code remains the same)'
True, '""""""\nFind the path to a Python package.\n\nThis function takes an import name as input and returns the prefix and full path of the corresponding package.\nIf the package is installed system-wide, it returns the prefix and full path. If the package is installed in a virtual environment,\nit returns the parent directory and full path. If the package is not installed, it returns None for both values.\n\nParameters:\n    import_name (str): The name of the Python package to find.\n\nReturns:\n    tuple: A tuple containing the prefix and full path of the package, or None if the package is not installed.\n""""""'
True, '""""""\nAdds a static route to the application using the provided `static_url_path`, \n`static_host`, and `static_folder`. This is done without checking if \n`static_folder` exists, as it might be created while the server is running. \n\nThis method uses a weakref to avoid creating a reference cycle between the app \nand the view function.\n\nArgs:\n    - import_name (str): The name of the module being imported.\n    - static_url_path (str | None): The URL path for serving static files.\n    - static_folder (str | os.PathLike | None): The folder where static files are stored. Defaults to ""static"".\n    - static_host (str | None): The host for serving static files. Required if `host_matching` is False.\n    - host_matching (bool): Whether the host should be matched in the URL path. Defaults to False.\n    - subdomain_matching (bool): Whether the subdomain should be matched in the URL path. Defaults to False.\n    - template_folder (str | os.PathLike | None): The folder where templates are stored. Defaults to ""templates"".\n    - instance_path (str | None): The path for serving instance-specific files. Defaults to None.\n    - instance_relative_config (bool): Whether configuration should be relative to the instance. Defaults to False.\n    - root_path (str | None): The root path of the application. Defaults to None.\n\nRaises:\n    AssertionError: If `static_host` and `host_matching` do not match, or if `static_folder` exists but is not configured.\n""""""'
True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to use for retrieving the default send file max age. Defaults to None.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default is set.\n""""""'
True, '""""""\nSends a static file from the configured static folder.\n\nThis method is used to serve static files. It checks if the `static_folder` attribute has been set and raises a RuntimeError if not.\nIt then calls `get_send_file_max_age` to determine the maximum age for the file, which is necessary for blueprints to work correctly.\nFinally, it uses `send_from_directory` to send the file from the static folder.\n\nArgs:\n    filename (str): The name of the file to be sent.\n\nReturns:\n    Response: A response object containing the sent file.\n\nRaises:\n    RuntimeError: If \'static_folder\' is not set.\n""""""'
True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str, optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"", ""rt"", and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""'
True, '""""""\nCreates a URL adapter for the current request.\n\nIf `subdomain_matching` is disabled, it uses the default subdomain.\nOtherwise, it does not use a subdomain. The server name and subdomain are\nprinted to the console for debugging purposes.\n\nReturns:\n    A bound URL map or None if the server name is not set.\n""""""'
False, '""""""\nRaises a routing exception if the request is not debuggable, \nor if it\'s a redirect with an invalid status code or method.\n\nArgs:\n    request (Request): The incoming HTTP request.\n\nReturns:\n    None\n""""""\ndef raise_routing_exception(self, request: Request) -> t.NoReturn:\n    ...\n'
True, '""""""\nHandles HTTP exceptions by checking their type and returning them accordingly.\n\nIf the exception does not have an error code (i.e., it\'s a ProxyException), \nit will be returned unchanged as an error. If it\'s a RoutingException, \nit will also be returned without modification. Otherwise, it will be \npassed to the error handler function to determine its response.\n\nArgs:\n    e (HTTPException): The HTTP exception to handle.\nReturns:\n    HTTPException | ft.ResponseReturnValue: The handled exception or its response.\n""""""'
True, '""""""\nHandles exceptions raised by the application.\n\nThis function checks for specific exception types and decides how to handle them.\nIf a `BadRequestKeyError` occurs and debug mode or the trap bad request errors config flag are set, it sets the `show_exception` attribute of the error object to True.\nIf an `HTTPException` occurs but is not trapped by the application, it calls the `handle_http_exception` method to handle the exception.\nOtherwise, it finds an error handler for the exception using the `_find_error_handler` method and calls it with the exception as an argument.\n\nArgs:\n    e (Exception): The exception to be handled.\nReturns:\n    HTTPException | ft.ResponseReturnValue: The result of handling the exception or None if no handler is found.\n""""""'
True, '""""""\nHandles exceptions raised during the execution of a request.\n\nIf propagation is enabled, re-raises the exception. Otherwise, logs the exception and\ncontinues with the next error handler in the chain.\n\nArgs:\n    e (Exception): The exception to be handled.\n\nReturns:\n    Response: A response object containing the server error.\n""""""'
True, '""""""\nReturns the maximum age in seconds for sending files.\n\nIf `filename` is provided, it will be used to retrieve the default send file max age from the application configuration.\nOtherwise, the default value will be returned.\n\nArgs:\n    filename (str | None): The name of the file to use for retrieving the default send file max age. Defaults to None.\n\nReturns:\n    int | None: The maximum age in seconds for sending files, or None if no default is set.\n""""""'
True, '""""""\nSends a static file from the configured static folder.\n\nThis method is used to serve static files. It checks if the `static_folder` attribute has been set and raises a RuntimeError if not.\nIt then calls `get_send_file_max_age` to determine the maximum age for the file, which is necessary for blueprints to work correctly.\nFinally, it uses `send_from_directory` to send the file from the static folder.\n\nArgs:\n    filename (str): The name of the file to be sent.\n\nReturns:\n    Response: A response object containing the sent file.\n\nRaises:\n    RuntimeError: If \'static_folder\' is not set.\n""""""'
True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str, optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"", ""rt"", and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""'
False, 'def explain_template_loading_attempts(app: App, template, attempts) -> None:\n    """"""\n    Logs information about template loading attempts.\n\n    This function takes an application object, a template name, and a list of\n    loader attempts. It iterates over the loaders, logging information about each\n    attempt, including any matches found or errors encountered. If no matches are\n    found, it logs an error message. If multiple matches are found, it logs a\n    warning message.\n\n    Args:\n        app (App): The application object.\n        template (str): The name of the template to load.\n        attempts (list[tuple[loader, srcobj, triple]]): A list of loader attempts,\n            where each attempt is a tuple containing the loader, source object,\n            and any match found.\n\n    Returns:\n        None\n    """"""\n    info = [f""Locating template {template!r}:""]\n    total_found = 0\n    blueprint = None\n    if request_ctx and request_ctx.request.blueprint is not None:\n        blueprint = request_ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, App):\n            src_info = f""application {srcobj.import_name!r}""\n        elif isinstance(srcobj, Blueprint):\n            src_info = f""blueprint {srcobj.name!r} ({srcobj.import_name})""\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f""{idx + 1:5}: trying loader of {src_info}"")\n\n        for line in _dump_loader_info(loader):\n            info.append(f""       {line}"")\n\n        if triple is None:\n            detail = ""no match""\n        else:\n            detail = f""found ({triple[1] or \'<string>\'!r})""\n            total_found += 1\n        info.append(f""       -> {detail}"")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(""Error: the template could not be found."")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(""Warning: multiple loaders returned a match for the template."")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            ""  The template was looked up from an endpoint that belongs""\n            f"" to the blueprint {blueprint!r}.""\n        )\n        info.append(""  Maybe you did not place a template in the right folder?"")\n        info.append(""  See https://flask.palletsprojects.com/blueprints/#templates"")\n\n    app.logger.info(""\\n"".join(info))'
True, '""""""\nInitializes the object with the given application instance.\n\nArgs:\n    app (App): The application instance to be used by this object.\n\nReturns:\n    None\n""""""'
True, '""""""\nCreates a logger instance for the given application.\n\nArgs:\n    app (App): The application object containing the name of the logger.\n\nReturns:\n    logging.Logger: A configured logger instance.\n""""""'
False, '""""""\nInitialize a new Flask application instance.\n\nThis function is used to create a new Flask application. It takes several parameters that can be used to customize the behavior of the application.\n\nParameters:\n    import_name (str): The name of the module where the application\'s configuration and other settings are defined.\n    static_url_path (str | None): The URL path for serving static files. Defaults to None.\n    static_folder (str | os.PathLike | None): The folder where static files are stored. Defaults to ""static"".\n    static_host (str | None): The host on which static files will be served. Defaults to None.\n    host_matching (bool): Whether the application should match hosts in its routing. Defaults to False.\n    subdomain_matching (bool): Whether the application should match subdomains in its routing. Defaults to False.\n    template_folder (str | os.PathLike | None): The folder where templates are stored. Defaults to ""templates"".\n    instance_path (str | None): The path to the instance folder. If not provided, it will be automatically determined by the `auto_find_instance_path` method. Raises ValueError if a relative path is given.\n    instance_relative_config (bool): Whether the application\'s configuration should be loaded from files in the instance folder. Defaults to False.\n    root_path (str | None): The root path of the application. Defaults to None.\n\nReturns:\n    None\n""""""\ndef __init__(\n        self,\n        import_name: str,\n        static_url_path: str | None = None,\n        static_folder: str | os.PathLike | None = ""static"",\n        static_host: str | None = None,\n        host_matching: bool = False,\n        subdomain_matching: bool = False,\n        template_folder: str | os.PathLike | None = ""templates"",\n        instance_path: str | None = None,\n        instance_relative_config: bool = False,\n        root_path: str | None = None,\n    ):\n        super().__init__(\n            import_name=import_name,\n            static_folder=static_folder,\n            static_url_path=static_url_path,\n            template_folder=template_folder,\n            root_path=root_path,\n        )\n\n        if instance_path is None:\n            instance_path = self.auto_find_instance_path()\n        elif not os.path.isabs(instance_path):\n            raise ValueError(\n                ""If an instance path is provided it must be absolute.""\n                "" A relative path was given instead.""\n            )\n\n        #: Holds the path to the instance folder.\n        #:\n        #: .. versionadded:: 0.8\n        self.instance_path = instance_path\n\n        #: The configuration dictionary as :class:`Config`.  This behaves\n        #: exactly like a regular dictionary but supports additional methods\n        #: to load a config from files.\n        self.config = self.make_config(instance_relative_config)\n\n        #: An instance of :attr:`aborter_class` created by\n        #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n        #: to raise HTTP errors, and can be called directly as well.\n        #:\n        #: .. versionadded:: 2.2\n        #:     Moved from ``flask.abort``, which calls this object.\n        self.aborter = self.make_aborter()\n\n        self.json: JSONProvider = self.json_provider_class(self)\n        """"""Provides access to JSON methods. Functions in ``flask.json``\n        will call methods on this provider when the application context\n        is active. Used for handling JSON requests and responses.\n\n        An instance of :attr:`json_provider_class`. Can be customized by\n        changing that attribute on a subclass, or by assigning to this\n        attribute afterwards.\n\n        The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n        uses Python\'s built-in :mod:`json` library. A different provider\n        can use a different JSON library.\n\n        .. versionadded:: 2.2\n        """"""\n\n        #: A list of functions that are called by\n        #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n        #: :exc:`~werkzeug.routing.BuildError`. Each function is called\n        #: with ``error``, ``endpoint`` and ``values``. If a function\n        #: returns ``None`` or raises a ``BuildError``, it is skipped.\n        #: Otherwise, its return value is returned by ``url_for``.\n        #:\n        #: .. versionadded:: 0.9\n        self.url_build_error_handlers: list[\n            t.Callable[[Exception, str, dict[str, t.Any]], str]\n        ] = []\n\n        #: A list of functions that are called when the application context\n        #: is destroyed.  Since the application context is also torn down\n        #: if the request ends this is the place to store code that disconnects\n        #: from databases.\n        #:\n        #: .. versionadded:: 0.9\n        self.teardown_appcontext_funcs: list[ft.TeardownCallable] = []\n\n        #: A list of shell context processor functions that should be run\n        #: when a shell context is created.\n        #:\n        #: .. versionadded:: 0.11\n        self.shell_context_processors: list[ft.ShellContextProcessorCallable] = []\n\n        #: Maps registered blueprint names to blueprint objects. The\n        #: dict retains the order the blueprints were registered in.\n        #: Blueprints can be registered multiple times, this dict does\n        #: not track how often they were attached.\n        #:\n        #: .. versionadded:: 0.7\n        self.blueprints: dict[str, Blueprint] = {}\n\n        #: a place where extensions can store application specific state.  For\n        #: example this is where an extension could store database engines and\n        #: similar things.\n        #:\n        #: The key must match the name of the extension module. For example in\n        #: case of a ""Flask-Foo"" extension in `flask_foo`, the key would be\n        #: ``\'foo\'``.\n        #:\n        #: .. versionadded:: 0.7\n        self.extensions: dict = {}\n\n        #: The :class:`~werkzeug.routing.Map` for this instance.  You can use\n        #: this to change the routing converters after the class was created\n        #: but before any routes are connected.  Example::\n        #:\n        #:    from werkzeug.routing import BaseConverter\n        #:\n        #:    class ListConverter(BaseConverter):\n        #:        def to_python(self, value):\n        #:            return value.split(\',\')\n        #:        def to_url(self, values):\n        #:            return \',\'.join(super(ListConverter, self).to_url(value)\n        #:                            for value in values)\n        #:\n        #:    app = Flask(__name__)\n        #:    app.url_map.converters[\'list\'] = ListConverter\n        self.url_map = self.url_map_class(host_matching=host_matching)\n\n        self.subdomain_matching = subdomain_matching\n\n        # tracks internally if the application already handled at least one\n        # request.\n        self._got_first_request = False\n\n        # Set the name of the Click group in case someone wants to add\n        # the app\'s commands to another CLI tool.\n        self.cli.name = self.name'
True, '""""""\nRaises a NotImplementedError to be implemented by subclasses.\n\nSubclasses must provide an implementation of this method that returns a Jinja2 environment.\n""""""'
True, '""""""\nTemplate Test Decorator.\n\nThis function returns a decorator that can be used to wrap a template test function.\nThe wrapped function will have its `name` attribute set by the `template_test` function.\n\nArgs:\n    f (Callable[[T_template_test], T_template_test]): The function to be decorated.\n    name (str | None, optional): The name of the template test. Defaults to None.\n\nReturns:\n    Callable[[T_template_test], T_template_test]: The decorated function.\n""""""'
False, '""""""\nDecorates a test function with template testing.\n\nThis function takes a test function `f` as input and adds it to the template tests.\nThe decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n\nRaises:\n    None\n""""""\ndef decorator(f: T_template_test) -> T_template_test:\n    self.add_template_test(f, name=name)\n    return f'
False, '""""""\nTemplate Global Decorator\n\nThis function is used to create a template global decorator. It takes a function `f` as an argument and returns the same function wrapped with the `add_template_global` method.\n\nThe `name` parameter can be provided to specify the name of the template global. If not specified, it defaults to None.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n    name (str | None, optional): The name of the template global. Defaults to None.\n\nReturns:\n    T_template_global: The decorated function.\n""""""\ndef decorator(f: T_template_global) -> T_template_global:\n    """"""\nDecorates a function to add it as a template global.\n\nArgs:\n    f (T_template_global): The function to be decorated.\n\nReturns:\n    T_template_global: The decorated function.\n""""""\n    self.add_template_global(f, name=name)\n    return f'
True, '""""""\nAdds a function as a template global.\n\nDecorates a function to make it accessible as a template global variable.\n\nArgs:\n    f (T_template_global): The function to be decorated. This should be a callable object.\n\nReturns:\n    T_template_global: The decorated function, which is now accessible as a template global variable.\n""""""'
False, '""""""\nFinds the error handler for a given exception.\n\nThis function iterates through the blueprint handlers and class-specific handlers to find a matching error handler.\nIf no match is found, it returns `None`.\n\nArgs:\n    e (Exception): The exception for which to find an error handler.\n\nReturns:\n    ft.ErrorHandlerCallable | None: The error handler for the given exception, or `None` if no match is found.'
True, '""""""\nDetermines whether an exception should be ignored.\n\nArgs:\n    error (BaseException | None): The exception to check. Can be None for no exception.\nReturns:\n    bool: True if the exception should be ignored, False otherwise.\n""""""'
False, 'def redirect(self, location: str, code: int = 302) -> BaseResponse:\n    """"""\n    Redirects to a specified URL with an optional HTTP status code.\n\n    Args:\n        location (str): The URL to redirect to.\n        code (int, optional): The HTTP status code. Defaults to 302.\n\n    Returns:\n        BaseResponse: A response object containing the redirect URL and status code.\n    """"""\n    return _wz_redirect(\n        location, code=code, Response=self.response_class  # type: ignore[arg-type]\n    )'
False, 'def __init__(\n    """"""\n    Initializes a new instance of the BlueprintSetupState class.\n\n    Args:\n        blueprint: A reference to the blueprint that created this setup state.\n        app: A reference to the current application.\n        options: A dictionary with all options that were passed to the\n            :meth:`~flask.Flask.register_blueprint` method.\n        first_registration: As blueprints can be registered multiple times with\n            the application and not everything wants to be registered multiple\n            times on it, this attribute can be used to figure out if the blueprint\n            was registered in the past already.\n\n    Returns:\n        None\n    """"""\n    self.app = app\n    self.blueprint = blueprint\n    self.options = options\n    self.first_registration = first_registration\n\n    subdomain = self.options.get(""subdomain"")\n    if subdomain is None:\n        subdomain = self.blueprint.subdomain\n\n    self.subdomain = subdomain\n\n    url_prefix = self.options.get(""url_prefix"")\n    if url_prefix is None:\n        url_prefix = self.blueprint.url_prefix\n\n    self.url_prefix = url_prefix\n\n    self.name = self.options.get(""name"", blueprint.name)\n    self.name_prefix = self.options.get(""name_prefix"", """")\n\n    self.url_defaults = dict(self.blueprint.url_values_defaults)\n    self.url_defaults.update(self.options.get(""url_defaults"", ()))'
False, 'def record_once(func: t.Callable) -> None:\n    """"""\n    Records a function to be executed once during the first registration of a blueprint.\n\n    This method is used to register a function that should only be executed during the initial setup of a blueprint.\n    The function will be called when the blueprint\'s first registration occurs.\n\n    Args:\n        func (t.Callable): The function to be recorded and executed.\n\n    Returns:\n        None\n    """"""'
True, '""""""\nWrapper function to handle first registration of users.\n\nThis function checks if the user has registered for the first time and calls the `func` function with the provided `state` object if so.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application setup.\n\nReturns:\n    None\n""""""'
False, '""""""\nCreates a new setup state for the given application.\n\nArgs:\n    - `app`: The Flask application instance.\n    - `options`: A dictionary of configuration options.\n    - `first_registration` (optional): Whether this is the first registration. Defaults to False.\n\nReturns:\n    A BlueprintSetupState object representing the created setup state.\n\nRaises:\n    None\n""""""\ndef make_setup_state(self, app: App, options: dict, first_registration: bool = False) -> BlueprintSetupState:\n    """"""\n    Creates a new setup state for the given application.\n\n    Args:\n        - `app`: The Flask application instance.\n        - `options`: A dictionary of configuration options.\n        - `first_registration` (optional): Whether this is the first registration. Defaults to False.\n\n    Returns:\n        A BlueprintSetupState object representing the created setup state.\n\n    Raises:\n        None\n    """"""\n    return BlueprintSetupState(self, app, options, first_registration)'
False, '""""""\nRegisters the current class instance as a Blueprint in the provided Flask application.\n\nThis method checks for duplicate names and ensures that all necessary configuration is set up before registering the Blueprint.\nIt also merges the Blueprint\'s data with its parent\'s data if it\'s the first registration or has a unique name.\n\nArgs:\n    app (App): The Flask application to register the Blueprint in.\n    options (dict): A dictionary of options for the Blueprint, including \'name_prefix\' and \'name\'.\n\nReturns:\n    None\n""""""\ndef register(self, app: App, options: dict) -> None:'
False, ""```\n## add_app_template_filter\n\nAdds a template filter to the application's Jinja environment.\n\n### Parameters\n\n* `f`: A callable that implements the template filter functionality.\n* `name`: The name under which the filter should be registered (optional). Defaults to None.\n\n### Returns\n\nNone\n```"")
True, '""""""\nRegisters a Jinja2 filter with the given application state.\n\nArgs:\n    state (BlueprintSetupState): The application state to modify.\n\nReturns:\n    None\n""""""'
False, '""""""\nDecorates a function with the `app_template_test` metadata.\n\nThis decorator adds an application template test to the decorated function.\nIt takes an optional `name` parameter to specify the test name.\n\nArgs:\n    f (Callable): The function to be decorated.\n    name (str, optional): The name of the test. Defaults to None.\n\nReturns:\n    Callable: The decorated function with added metadata.\n""""""\ndef app_template_test(self, name: str | None = None) -> t.Callable[[T_template_test], T_template_test]:\n    """"""\n    Decorates a test function with an application template test.\n\n    This function takes a test function `f` as input and adds it to the list of \n    application template tests. The decorated function is then returned.\n\n    Args:\n        f (T_template_test): The test function to be decorated.\n    \n    Returns:\n        T_template_test: The decorated test function.\n    """"""\n    def decorator(f: T_template_test) -> T_template_test:\n        """"""\n        Adds an application template test to the decorated function.\n\n        Args:\n            f (T_template_test): The test function to be decorated.\n\n        Returns:\n            T_template_test: The decorated test function.\n        """"""\n        self.add_app_template_test(f, name=name)\n        return f\n\n    return decorator'
False, '""""""\nDecorates a test function with an application template test.\n\nThis function takes a test function `f` as input and adds it to the list of \napplication template tests. The decorated function is then returned.\n\nArgs:\n    f (T_template_test): The test function to be decorated.\n\nReturns:\n    T_template_test: The decorated test function.\n""""""\ndef decorator(f: T_template_test) -> T_template_test:\n    """"""\n    Adds a test function to the list of application template tests and returns the decorated function.\n\n    Args:\n        f (T_template_test): The test function to be added to the list of application template tests.\n\n    Returns:\n        T_template_test: The decorated test function.\n    """"""\n    self.add_app_template_test(f, name=name)\n    return f'
False, ""```\n## add_app_template_test\n\nAdds a template test to the application's Jinja environment.\n\n### Parameters\n\n*   `f`: The test function to register.\n*   `name` (optional): The name of the test. Defaults to None, which uses the test function's name if not provided.\n\n### Returns\n\nNone\n```"")
True, '""""""\nRegisters a Jinja template test in the application\'s setup state.\n\nArgs:\n    state (BlueprintSetupState): The current state of the application\'s setup.\n    \nReturns:\n    None: This function does not return any value. It modifies the provided BlueprintSetupState object directly.\n""""""'
False, 'def app_template_global(\n    """"""\n    Decorates a function to make it available as an application template global.\n\n    This decorator adds the decorated function to the list of application template globals.\n    It is typically used in conjunction with the `add_app_template_global` method.\n\n    Args:\n        name (str | None): The name under which the decorated function should be added. If None, no name will be specified.\n\n    Returns:\n        T_template_global: A decorator function that adds the decorated function to the list of application template globals.\n    """"""\n) -> t.Callable[[T_template_global], T_template_global]:\n\n    def decorator(\n        """"""\n        Decorates a function to add it as an app template global.\n\n        Args:\n            f (T_template_global): The function to be decorated.\n\n        Returns:\n            T_template_global: The decorated function.\n        """"""\n    ) -> T_template_global:\n        self.add_app_template_global(f, name=name)\n        return f\n\n    return decorator'
True, '""""""\nAdds the provided function as a template global for the application.\n\nArgs:\n    f (T_template_global): The function to be added as a template global.\n\nReturns:\n    T_template_global: The decorated function.\n""""""'
False, '```\n## add_app_template_global\nAdds a template global to the application.\n\n### Parameters\n\n*   `f`: The callable to register as a template global.\n*   `name` (optional): The name of the template global. Defaults to None.\n\n### Returns\n\nNone\n\n### Raises\n\nTypeError: If `state` is not an instance of BlueprintSetupState.\n```'
False, '""""""\nRegisters a template as a global variable in the Jinja environment.\n\nArgs:\n    state (BlueprintSetupState): The current setup state of the application.\n\nReturns:\n    None\n\nRaises:\n    TypeError: If `state` is not an instance of BlueprintSetupState.'
False, '""""""\nApp Error Handler Decorator.\n\nThis function returns a decorator that can be used to handle application errors.\nThe decorator takes an error handling function as input and wraps it with the provided app error handler.\n\nArgs:\n    code (type[Exception] | int): The type of exception or error code to use for error handling.\n    f (T_error_handler): The error handling function to wrap.\n\nReturns:\n    T_error_handler: The wrapped error handling function.\n\nExample:\n    @app_errorhandler(404)\n    def handle_404(f):\n        # Handle 404 errors\n        pass\n\n    @app_errorhandler(Exception)\n    def handle_all_errors(f):\n        # Handle all exceptions\n        pass\n""""""\n \ndef decorator(f: T_error_handler) -> T_error_handler:\n    """"""\nDecorates a function with error handling.\n\nThis decorator records the first occurrence of an exception and uses it to update the application\'s error handler.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The decorated function.\n""""""\n            self.record_once(lambda s: s.app.errorhandler(code)(f))\n            return f'
True, '""""""\nDecorates a function with error handling.\n\nThis decorator records the first occurrence of an exception and uses it to update the application\'s error handler.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The decorated function.\n""""""'
False, '""""""\nRoute a URL pattern to a view function.\n\nThis function is used to create a route for a given URL pattern. It takes in the rule of the URL and any additional options as keyword arguments. The `endpoint` option can be provided to specify an endpoint name, which will be used when adding the URL rule.\n\nThe returned decorator function can be applied to view functions to register them with this router.\n\nArgs:\n    rule (str): The URL pattern to route.\n    **options: t.Any: Additional options for the URL rule. Can include \'endpoint\' to specify an endpoint name.\n\nReturns:\n    T_route -> T_route: A decorator function that registers a view function with this router.\n""""""\ndef route(self, rule: str, **options: t.Any) -> t.Callable[[T_route], T_route]:\n    """"""\n    Decorates a function to register it as an endpoint.\n\n    This decorator takes a function `f` and registers it with the Flask application.\n    It also populates the ""endpoint"" key in the options dictionary if present,\n    and passes the remaining options to the `add_url_rule` method.\n\n    Args:\n        f (function): The function to be decorated.\n\n    Returns:\n        function: The original function, now registered as an endpoint.\n    """"""\n    def decorator(f: T_route) -> T_route:\n        endpoint = options.pop(""endpoint"", None)\n        self.add_url_rule(rule, endpoint, f, **options)\n        return f\n\n    return decorator'
False, '""""""\nDecorates a function to register it as an endpoint.\n\nThis decorator takes a function `f` and registers it with the Flask application.\nIt also populates the ""endpoint"" key in the options dictionary if present,\nand passes the remaining options to the `add_url_rule` method.\n\nArgs:\n    f (function): The function to be decorated.\n\nReturns:\n    function: The original function, now registered as an endpoint.'
False, '# Endpoint Decorator Function\n\n## Overview\n\nThis function is a decorator that registers an endpoint with the provided endpoint string.\nIt takes in a function `f` and returns a new function that wraps the original function, \nregistering it as a view function for the specified endpoint.\n\n## Parameters\n\n### endpoint (str)\n\nThe endpoint to register the function under.\n\n### f (Callable[[F], F])\n\nThe function to be registered as a view function.\n\n## Returns\n\nA new function that wraps the original function and registers it as a view function.'
True, '""""""\nDecorates a view function with endpoint information.\n\nThis function is used to register and decorate view functions for use in the application.\nIt takes a view function `f` as an argument, adds it to the `view_functions` dictionary \nwith the current endpoint, and then returns the original function. This allows for easy\nmanagement of view functions and their corresponding endpoints.\n\nArgs:\n    f (F): The view function to be decorated.\n\nReturns:\n    F: The decorated view function.\n""""""'
False, '""""""\nDecorates a function to handle specific exceptions.\n\nThis function returns a decorator that registers the provided function as an error handler for the specified exception type or code. The decorated function will be called when the registered exception is raised.\n\nArgs:\n    self: The instance of the class that this method belongs to.\n    code_or_exception (type[Exception] | int): The type of exception or code to register the decorator for.\n    f (T_error_handler): The function to decorate as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""\ndef errorhandler(\n        self, \n        code_or_exception: type[Exception] | int\n    ) -> t.Callable[[T_error_handler], T_error_handler]:\n    """"""\n    Decorates a function to register it as an error handler.\n\n    This decorator takes a function `f` that handles errors and registers it with the \n    `register_error_handler` method. The decorated function is then returned.\n\n    Args:\n        f (T_error_handler): The function to be registered as an error handler.\n\n    Returns:\n        T_error_handler: The decorated function.\n    """"""\n    def decorator(f: T_error_handler) -> T_error_handler:\n        self.register_error_handler(code_or_exception, f)\n        return f\n\n    return decorator'
False, '""""""\nDecorates a function to register it as an error handler.\n\nThis decorator takes a function `f` that handles errors and registers it with the \n`register_error_handler` method. The decorated function is then returned.\n\nArgs:\n    f (T_error_handler): The function to be registered as an error handler.\n\nReturns:\n    T_error_handler: The decorated function.\n""""""\ndef decorator(f: T_error_handler) -> T_error_handler:\n    """"""\n    Registers a function as an error handler and returns the decorated function.\n\n    Args:\n        f (T_error_handler): The function to be registered as an error handler.\n\n    Returns:\n        T_error_handler: The decorated function.\n    """"""\n    self.register_error_handler(code_or_exception, f)\n    return f'
False, '""""""\nInitialize a new Jinja2 environment.\n\nThis method is called when an instance of the class is created. It sets up the environment with the provided application and options.\n\nArgs:\n    app (App): The application instance.\n    **options (t.Any): Keyword arguments to customize the environment.\n\nReturns:\n    None\n""""""\n\ndef __init__(self, app: App, **options: t.Any) -> None:\nif ""loader"" not in options:\n    options[""loader""] = app.create_global_jinja_loader()\nBaseEnvironment.__init__(self, **options)\nself.app = app'
True, '""""""\nInitializes the object with an application instance.\n\nArgs:\n    app (App): The application instance to be associated with this object.\n\nReturns:\n    None\n""""""'
False, 'def register(self, app: App, options: dict) -> None:\n    """"""\n    Registers the current class instance with the given Flask application.\n\n    This method checks if a blueprint with the same name already exists and raises an error if it does.\n    It then sets up the necessary state for the instance and registers any deferred functions.\n    Finally, it adds the instance\'s commands to the application\'s CLI and registers any blueprints.\n\n    Args:\n        app (App): The Flask application to register the instance with.\n        options (dict): A dictionary of options to use when registering the instance.\n\n    Raises:\n        ValueError: If a blueprint with the same name already exists.\n\n    Returns:\n        None\n    """"""'
True, '""""""\nMerges blueprint functions into the application\'s configuration.\n\nThis function merges the provided blueprint functions (`bp_dict`) with the parent dictionary\n(`parent_dict`) in a way that preserves the namespace. It also updates the application\'s error\nhandler specification and view functions accordingly.\n\nParameters:\napp (App): The application instance to be updated.\nname (str): The name of the blueprint, used for namespace resolution.\n\nReturns:\nNone\n""""""'
True, '""""""\nExtends a dictionary with another dictionary\'s values.\n\nThis function takes two dictionaries as input: `bp_dict` and `parent_dict`. It iterates over the items in `bp_dict`, \nconstructs new keys by appending the current key to the parent dictionary\'s name if it exists, \nand extends the corresponding value in `parent_dict`.\n\nArgs:\n    bp_dict (dict): The dictionary containing values to be extended.\n    parent_dict (dict): The dictionary into which values will be extended.\n\nReturns:\n    None\n""""""'
True, '""""""\nUpdates the template context with additional information.\n\nThis function is used to extend the context passed to a template, allowing it\nto be rendered outside of a request context. It iterates over the list of\ntemplate context processors and applies their functions to the current\ncontext, updating it accordingly.\n\nArgs:\n    context (dict): The initial context to update.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the version information of Python, Flask, and Werkzeug.\n\nParameters:\n- ctx (object): The context object containing information about the current session.\n- param (object): An optional parameter to be used in the function. Currently unused.\n- value (str): The input string that triggers this function call.\n\nReturns:\nNone\n\nSide Effects:\n- Prints the version information of Python, Flask, and Werkzeug to the console.\n- Exits the current session using ctx.exit().\n""""""'
True, '""""""\nReturns the version of Werkzeug, a Python web framework.\n\nThis function uses the `importlib.metadata` module to retrieve the version from PyPI.\nIf the version is not already cached in `_werkzeug_version`, it will be retrieved and stored for future use.\n\nArgs:\n    None\n\nReturns:\n    str: The version of Werkzeug as a string\n""""""'
False, '""""""\nInitialize the documentation assistant.\n\nThis function initializes a new instance of the documentation assistant, \nsetting default values for its attributes and calling the parent class\'s constructor.\n\nArgs:\n    *args: Variable length argument list containing any additional arguments.\n    **kwargs: Keyworded arguments containing any additional keyword arguments.\n\nReturns:\n    None\n""""""\ndef __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n    super().__init__(*args, **kwargs)\n    self.preserve_context = False\n    self._new_contexts: list[t.ContextManager[t.Any]] = []\n    self._context_stack = ExitStack()\n    self.environ_base = {\n        ""REMOTE_ADDR"": ""127.0.0.1"",\n        ""HTTP_USER_AGENT"": f""Werkzeug/{_get_werkzeug_version()}"",\n    }'
False, '""""""\nTests the functionality of the `test_get_version` function.\n\nThis test verifies that the function correctly retrieves and prints the versions of Python, Flask, and Werkzeug when called with a mock context object.\n\nParameters:\n    test_apps (list): A list of application names to use for testing.\n    capsys (unittest.mock.Mock): A mock object used to capture the output of the `get_version` function.\n\nReturns:\n    None\n""""""\ndef test_get_version(test_apps, capsys):\n    class MockCtx:\n        """"""A mock context object used to simulate a Flask application.""""""\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, ""test"")\n    out, err = capsys.readouterr()\n    assert f""Python {platform.python_version()}"" in out\n    assert f""Flask {importlib.metadata.version(\'flask\')}"" in out\n    assert f""Werkzeug {importlib.metadata.version(\'werkzeug\')}"" in out'
False, '""""""\nTest the base environment for Flask application.\n\nThis function tests that the remote address and user agent are correctly set\nwhen making a GET request to the root URL of the Flask application. It uses\nthe Werkzeug library to get the user agent string, which is used in the test.\n""""""\n\ndef test_environ_base_default(app, client):'
False, '""""""\nFlask Request Data Retrieval Function\n\nThis function retrieves and stores relevant data from the Flask request object.\n\n### Parameters\n\nNone\n\n### Returns\n\nAn empty string, indicating successful retrieval of data.\n\n### Notes\n\n- This function sets two variables in the `g` object: `remote_addr` and `user_agent`, which contain the client\'s IP address and user agent string respectively.\n- The retrieved data is not stored anywhere; it is only temporarily set in the `g` object for potential future use.'
True, '""""""\nTest the base environment of a Flask application.\n\nThis function tests that the remote address and user agent are correctly\nmodified in the request context when using the `client` object to make a\nrequest to the root URL of the application. It verifies that these values\nare set in the `flask.g` dictionary, which is used by Flask to store\ncontext data.\n\nParameters:\napp (Flask): The Flask application instance.\nclient: An object providing a way to interact with the application\'s\n    request context.\n\nReturns:\nNone\n\nRaises:\nAssertionError: If any of the assertions fail.\n""""""'
False, '""""""\nFlask Request Data Retrieval Function\n\nThis function retrieves and stores relevant data from the Flask request object.\n\n### Parameters\n\nNone\n\n### Returns\n\nAn empty string, indicating successful retrieval of data.\n\n### Notes\n\n- This function sets two variables in the `g` object: `remote_addr` and `user_agent`, which contain the client\'s IP address and user agent string respectively.\n- The retrieved data is not stored anywhere; it is only temporarily set in the `g` object for potential future use.'
True, '""""""\nReturns the value of the requested attribute, or raises an AttributeError if it does not exist.\n\nThe function is used to handle special attributes that are deprecated and will be removed in future versions of Flask.\nIt provides a way to access these attributes while still raising a warning about their deprecation.\n\nAttributes:\n    - `_app_ctx_stack`: The application context stack. (Deprecated)\n    - `_request_ctx_stack`: The request context stack. (Deprecated)\n    - `escape`: A function for escaping HTML characters. (Deprecated, use markupsafe.escape instead)\n    - `Markup`: A class for representing unescaped HTML. (Deprecated, use markupsafe.Markup instead)\n    - `signals_available`: Always returns True, as signals are always available.\n\nRaises:\n    AttributeError: If the requested attribute does not exist.\n""""""'
True, '""""""\nReturns the version of Flask.\n\nThis function is deprecated and will be removed in Flask 3.1.\nInstead, use feature detection or \'importlib.metadata.version(""flask"")\'.\n\nArgs:\n    name (str): The attribute being accessed.\n\nReturns:\n    t.Any: The version of Flask as a string.\n\nRaises:\n    AttributeError: If the attribute does not exist.\n""""""'
False, 'def url_for(\n    """"""\n    Generates a URL for the given endpoint.\n\n    This function is used to generate URLs for routes in Flask applications.\n    It takes into account various parameters such as scheme, domain, and anchor,\n    and returns a fully qualified URL.\n\n    Args:\n        endpoint (str): The name of the route.\n        _anchor (str | None): An optional anchor for the URL. Defaults to None.\n        _method (str | None): The HTTP method for the URL. Defaults to None.\n        _scheme (str | None): The scheme for the URL. Defaults to None.\n        _external (bool | None): Whether the URL is external or not. Defaults to None.\n        **values: t.Any**: Additional values to be passed to the route.\n\n    Returns:\n        str: A fully qualified URL.\n\n    Raises:\n        RuntimeError: If unable to build URLs outside an active request without \'SERVER_NAME\' configured.\n        ValueError: If \'_scheme\' is specified when \'_external\' is False.\n    """"""\n) -> str:\n    req_ctx = _cv_request.get(None)\n\n    if req_ctx is not None:\n        url_adapter = req_ctx.url_adapter\n        blueprint_name = req_ctx.request.blueprint\n\n        # If the endpoint starts with ""."" and the request matches a\n        # blueprint, the endpoint is relative to the blueprint.\n        if endpoint[:1] == ""."":\n            if blueprint_name is not None:\n                endpoint = f""{blueprint_name}{endpoint}""\n            else:\n                endpoint = endpoint[1:]\n\n        # When in a request, generate a URL without scheme and\n        # domain by default, unless a scheme is given.\n        if _external is None:\n            _external = _scheme is not None\n    else:\n        app_ctx = _cv_app.get(None)\n\n        # If called by helpers.url_for, an app context is active,\n        # use its url_adapter. Otherwise, app.url_for was called\n        # directly, build an adapter.\n        if app_ctx is not None:\n            url_adapter = app_ctx.url_adapter\n        else:\n            url_adapter = self.create_url_adapter(None)\n\n        if url_adapter is None:\n            raise RuntimeError(\n                ""Unable to build URLs outside an active request""\n                "" without \'SERVER_NAME\' configured. Also configure""\n                "" \'APPLICATION_ROOT\' and \'PREFERRED_URL_SCHEME\' as""\n                "" needed.""\n            )\n\n        # When outside a request, generate a URL with scheme and\n        # domain by default.\n        if _external is None:\n            _external = True\n\n    # It is an error to set _scheme when _external=False, in order\n    # to avoid accidental insecure URLs.\n    if _scheme is not None and not _external:\n        raise ValueError(""When specifying \'_scheme\', \'_external\' must be True."")\n\n    self.inject_url_defaults(endpoint, values)\n\n    try:\n        rv = url_adapter.build(  # type: ignore[union-attr]\n            endpoint,\n            values,\n            method=_method,\n            url_scheme=_scheme,\n            force_external=_external,\n        )\n    except BuildError as error:\n        values.update(\n            _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n        )\n        return self.handle_url_build_error(error, endpoint, values)\n\n    if _anchor is not None:\n        _anchor = _url_quote(_anchor, safe=""%!#$&\'()*+,/:;=?@"")\n        rv = f""{rv}#{_anchor}""\n\n    return rv'
True, '""""""\nTests the `url_for` function with a route that includes a parameter.\n\nThis test case verifies that the `url_for` function correctly generates URLs\nfor routes that include parameters. In this specific case, it tests the\n`/self` route and ensures that the generated URL is correct when using\nthe `self` parameter.\n\nArgs:\n    app (Flask): The Flask application instance.\n    req_ctx: The request context object.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the generated URL does not match the expected result.\n""""""'
True, '""""""\nReturns the magic number \'42\' as per the problem\'s requirements.\n\nArgs:\n    None\n\nReturns:\n    str: The string representation of the magic number 42.\n""""""'
True, '""""""\nCreates a new Flask application instance.\n\nThis function initializes a new Flask application with default settings,\nand allows for optional configuration from a test environment or an instance\nconfiguration file. The application is then configured to use the database and\nregistered with blueprints.\n\nArgs:\n    test_config (dict): Optional test configuration dictionary.\n        If provided, this will override any instance configuration.\n\nReturns:\n    Flask application instance.\n""""""'
False, 'def make_response(self, rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response object is created based on the type of the view function result.\n    If the result is a tuple, it is unpacked into body, status, and headers.\n    If the result is None, a TypeError is raised.\n    If the result is not an instance of the response class, it is converted to\n    the correct type.\n\n    Args:\n        rv: The view function result.\n\n    Returns:\n        A Response object.\n\n    Raises:\n        TypeError: If the view function did not return a valid response tuple,\n            or if the result is None.\n    """"""'
False, '""""""\n    Performs teardown operations for the current request.\n\n    This function is responsible for executing any necessary cleanup or rollback\n    actions after a request has been completed. It iterates through the available\n    teardown functions and executes them in reverse order to ensure that resources\n    are properly cleaned up before moving on to the next one.\n\n    Args:\n        exc (BaseException | None): The exception being handled, if any.\n            Defaults to `_sentinel` to avoid assigning a value to this parameter.\n    Returns:\n        None\n\n    Raises:\n        None\n""""""\ndef do_teardown_request(\n    self,\n    exc: BaseException | None = _sentinel,  # type: ignore[assignment]\n) -> None:\n    if exc is _sententl:\n        exc = sys.exc_info()[1]\n\n    for name in chain(request.blueprints, (None,)):\n        if name in self.teardown_request_funcs:\n            for func in reversed(self.teardown_request_funcs[name]):\n                self.ensure_sync(func)(exc)\n\n    request_tearing_down.send(self, _async_wrapper=self.ensure_sync, exc=exc)'
True, '""""""\nTear down the application context.\n\nThis function is responsible for cleaning up resources and releasing locks when an exception occurs or when the application context is being torn down.\n\nArgs:\n    - self: The object instance that owns the teardown functions.\n    - exc (BaseException | None): The exception to be handled. If None, no action will be taken. Defaults to _sentinel.\n        - _sentinel: A sentinel value used to indicate that no exception is present.\n\nReturns:\n    None\n\nRaises:\n    None\n""""""'
True, '""""""\nStream a generator or function with context.\n\nThis function takes an iterator or callable that returns an iterator, and wraps it in a context manager. The context manager pushes the current request context onto the stack when the generator is started, and pops it off when the iteration completes.\n\nIf the input is not an iterator, but rather a callable that returns an iterator, this function will wrap the callable in a decorator to create a new function that takes any arguments and returns an iterator. This allows the original function to be used as if it were an iterator.\n\nThe context manager uses the `_cv_request` object to get the current request context, and pushes it onto the stack when the generator is started. When the iteration completes, the context is popped off the stack.\n\nThis function can only be used when a request context is active, such as in a view function.\n\nArgs:\n    generator_or_function: An iterator or callable that returns an iterator.\n\nReturns:\n    An iterator over the results of the input generator or function.\n""""""'
True, '""""""\nRedirects to a specified URL with an optional HTTP status code.\n\nArgs:\n    location (str): The URL to redirect to.\n    code (int, optional): The HTTP status code. Defaults to 302.\n\nReturns:\n    BaseResponse: A response object containing the redirect URL and status code.\n""""""'
True, '""""""\nTest the cleanup functionality of a Flask application.\n\nThis function tests that the `test_clean_pop` decorator correctly cleans up the \napplication context after each request, and also checks that the `app.testing`\nattribute is set to False. The test also verifies that the `called` list contains\nthe expected values.\n\nParameters:\n    app (Flask): The Flask application instance to be tested.\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If an error occurs during teardown.\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception if an error is provided. \n\nThis function is intended to be used as part of a testing or validation process, \nwhere it simulates an error condition that would otherwise cause a division by zero.\n\nArgs:\n    error (Exception): The error message to raise. Defaults to None.\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If no error message is provided.\n""""""'
False, '""""""\nTest Werkzeug Routing Functionality\n\nThis function tests the routing functionality of the Werkzeug library. It creates a URL map with a submount for the ""/foo"" path, \nwhich contains two routes: one for ""/bar"" and another for the root ""/"" path.\n\nParameters:\napp (object): The application object to be used for testing.\nclient (object): The client object used to send HTTP requests.\n\nReturns:\nNone\n""""""\ndef test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(""/foo"", [Rule(""/bar"", endpoint=""bar""), Rule(""/"", endpoint=""index"")])\n    )\n\n    def bar():\n        return ""bar""\n\n    def index():\n        return ""index""\n\n    app.view_functions[""bar""] = bar\n    app.view_functions[""index""] = index\n\n    assert client.get(""/foo/"").data == b""index""\n    assert client.get(""/foo/bar"").data == b""bar""'
True, '""""""\nDecorates a Flask application with a URL mount for the `/foo` path.\n\nThis function adds a submount to the Flask application\'s URL map, mapping the `/foo`\npath to two endpoints: `/foo/bar` and `/foo/`. The `client.get()` method is used\nto test that the correct endpoint is returned for each URL.\n\nParameters:\n    app (Flask): The Flask application instance.\n    client (Client): The HTTP client instance.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the expected data is not received from the server.\n""""""'
True, '""""""\nTest session special types.\n\nThis function tests the behavior of Flask\'s session object when storing\nspecial types such as bytes, Markup objects, and UUIDs. It verifies that\nthese types are stored correctly and can be retrieved from the session.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""'
True, '""""""\nTest teardown request handler error functionality.\n\nThis test verifies that all teardown requests are passed the same original exception.\nIt also checks that a request with a division by zero error is handled correctly,\nand that an internal server error response is returned to the client.\n\nParameters:\n    app (Flask application): The Flask application instance being tested.\n    client (requests session): The HTTP client used to make requests to the application.\n\nReturns:\n    None\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception when called. This function is intentionally designed to fail and should not be used in production code.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If the function is called without providing a valid divisor.\n""""""'
False, '""""""\nTest error handling functionality of the application.\n\nThis function tests the error handling capabilities of the Flask application.\nIt sets up routes for different error codes (404, 500, Forbidden) and checks\nthat the correct error messages are returned with the corresponding status codes.\n\nParameters:\napp (Flask): The Flask application instance to test.\nclient: A client object used to make HTTP requests to the application.\n\nReturns:\nNone\n""""""\ndef test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        """"""Return \'not found\' with status code 404 when a 404 error occurs.""""""\n        return ""not found"", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        """"""Return \'internal server error\' with status code 500 when a 500 error occurs.""""""\n        return ""internal server error"", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        """"""Return \'forbidden\' with status code 403 when a Forbidden error occurs.""""""\n        return ""forbidden"", 403\n\n    @app.route(""/"")\n    def index():\n        """"""Abort the request with a 404 status code and \'not found\' message.""""""\n        flask.abort(404)\n\n    @app.route(""/error"")\n    def error():\n        """"""Raise a ZeroDivisionError to test the 500 error handler.""""""\n        raise ZeroDivisionError\n\n    @app.route(""/forbidden"")\n    def error2():\n        """"""Abort the request with a 403 status code and \'forbidden\' message.""""""\n        flask.abort(403)\n\n    rv = client.get(""/"")\n    assert rv.status_code == 404\n    assert rv.data == b""not found""\n    rv = client.get(""/error"")\n    assert rv.status_code == 500\n    assert b""internal server error"" == rv.data\n    rv = client.get(""/forbidden"")\n    assert rv.status_code == 403\n    assert b""forbidden"" == rv.data'
True, '""""""\nRaises a ZeroDivisionError exception when called. This function is intended to be used as an example of how to raise a specific exception in Python.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If the function is called without any arguments.\n""""""'
False, '""""""\nTest error handling and processing for a Flask application.\n\nThis function tests the application\'s ability to handle internal server errors,\nraise exceptions, and modify response headers.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (Client): The client object used to make HTTP requests.\n\nReturns:\nNone\n""""""\n\ndef test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        """"""Handle internal server errors by returning a custom error message.""""""\n        return ""internal server error"", 500\n\n    @app.route(""/"")\n    def broken_func():\n        """"""Raise a ZeroDivisionError exception to test error handling.""""""\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        """"""Modify the response mimetype to \'text/x-special\'.""""""\n        resp.mimetype = ""text/x-special""\n        return resp\n\n    resp = client.get(""/"")\n    assert resp.mimetype == ""text/x-special""\n    assert resp.data == b""internal server error""'
True, '""""""\nRaises a ZeroDivisionError when called. This function is intentionally designed to fail and should not be used in production code.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If division by zero occurs.\n""""""'
True, '""""""\nTest error handler after processor error.\n\nThis function tests the behavior of an application\'s error handling mechanism when a request is made to a route that has already raised an exception. The test checks if the error handler correctly catches and returns the expected response code and data.\n\nParameters:\napp (Flask app): The Flask application instance.\nclient (requests Session): The requests session used for testing.\n\nReturns:\nNone\n""""""'
True, '""""""\nRaises a ZeroDivisionError when the request is triggered before its expected time.\n\nThis function should be used as a middleware in a web application to ensure that certain actions are performed at specific points during the request lifecycle. The `_trigger` variable is assumed to be set elsewhere in the codebase, and this function will raise an exception if it is not equal to ""before"".\n\nArgs:\n    None\n\nRaises:\n    ZeroDivisionError: If the request is triggered before its expected time.\n\nNote:\n    This function should be used with caution, as it can cause unexpected behavior if not implemented correctly. It is recommended to use a more robust solution for handling request timing.\n""""""'
True, '""""""\nRaises a ZeroDivisionError if the request is triggered \'after\' and returns the original response.\n\nArgs:\n    response: The HTTP response to be returned.\n\nReturns:\n    The original response.\n\nRaises:\n    ZeroDivisionError: If the request is triggered \'after\'.\n""""""'
True, '""""""\nPropagates an exception from the application to the client.\n\nThis function tests if the application correctly propagates exceptions to the client.\nIt sets up a Flask application, defines a route that raises a ZeroDivisionError,\nand then checks if the client receives this error when making a request to the route.\nIf `key` is provided, it configures the application with this key and verifies\nthat the client receives a 500 status code. If no `key` is provided, it tests that\nthe client receives a ZeroDivisionError.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (Client): The client instance to test against.\nkey (str): The configuration key to set in the application (optional).\n\nReturns:\nNone\n\nRaises:\nZeroDivisionError: If the application does not propagate this exception correctly.\n""""""'
True, '""""""\nRaises a ZeroDivisionError when attempting to divide by zero.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If division by zero is attempted.\n""""""'
True, '""""""\nTest the context processing of a Flask application.\n\nThis function tests the context processing of a Flask application by creating a blueprint with two context processors:\n- `not_answer_context_processor`: sets the global variable `notanswer` to 43.\n- `answer_context_processor`: sets the local variable `answer` to 42.\n\nThe function then creates endpoints for testing and uses a client to make requests to these endpoints. It asserts that the expected values are present in the response data.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (requests.Session): A session object used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nReturns a rendered Flask template string with conditional logic.\n\nThe function uses Flask\'s `render_template_string` method to render a template\nstring that includes conditional statements for displaying whether an input\nvalue (`notanswer`) or another value (`answer`) is the correct answer.\nIf `notanswer` is not provided, it displays a message indicating so. If\n`answer` is provided, it displays a message stating that it\'s the correct answer.\n\nReturns:\n    str: The rendered template string with conditional logic.\n""""""'
True, '""""""\nTest that a request exception signal is emitted when a ZeroDivisionError occurs.\n\nThis test creates a Flask application with a route that raises a ZeroDivisionError.\nIt then connects to the `got_request_exception` event and records any exceptions\nthat occur during the execution of this route. Finally, it asserts that the status code\nof the response is 500 (Internal Server Error) and that one exception was recorded.\n\nNote: This test relies on the fact that Flask emits a request exception signal when an\nexception occurs during the execution of a route. The `got_request_exception` event\nis used to catch this signal and record any exceptions that occur.\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception when called. This function is intentionally designed to fail and should not be used in production code.\n\nArgs:\n\nNone\n\nReturns:\n\nNone\n\nRaises:\n\nZeroDivisionError: If the function is called without sufficient arguments or under invalid conditions.\n""""""'
True, '""""""\nTear down signal handler for Flask application context.\n\nThis function tests the behavior of Flask\'s `appcontext_tearing_down` signal when a\nteardown function is registered. It sets up an application with a route that raises\na ZeroDivisionError, and then connects a teardown function to be called when the\napplication context is torn down. The teardown function records any exceptions raised.\nFinally, it makes a GET request to the index route and asserts that the response status\ncode is 500 (Internal Server Error) and that the recorded exception matches the one\nraised by the ZeroDivisionError.\n\nParameters:\n    app (Flask): The Flask application instance.\n    client (Client): The test client instance.\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If the index route raises a ZeroDivisionError.\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception when called. This function is intentionally designed to fail and should not be used in production code.\n\nArgs:\n\nNone\n\nReturns:\n\nNone\n\nRaises:\n\nZeroDivisionError: If the function is called without sufficient arguments or under invalid conditions.\n""""""'
True, '""""""\nTest client context binding.\n\nThis function tests the behavior of Flask\'s client context binding.\nIt creates a test application, sets up routes for testing,\nand then uses the client to make requests to these routes.\nThe function checks that the expected values are returned from\nthe routes and that any exceptions are raised as expected.\n\nParameters:\napp (Flask): The test application instance.\nclient (Client): The client instance used for making requests.\n\nReturns:\nNone\n\nRaises:\nRuntimeError: If an attempt is made to access `flask.g.value` outside of a context.\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception when attempting to divide by zero.\n\nThis function is intentionally designed to fail and should not be used in production code.\n""""""'
True, '""""""\nPatches the test view to raise a ZeroDivisionError on both GET and POST requests.\n\nThis function creates two classes, `Index` and `Other`, which inherit from \n`flask.views.MethodView`. The `Index` class raises a ZeroDivisionError when \nthe `get` or `post` methods are called. The `Other` class overrides the \n`get` method to return ""GET"" instead of raising an error.\n\nThe function then creates a view using the `as_view` method and assigns it to \nthe `view_class` attribute of the view. Finally, it adds a URL rule for the \nroot path (""/"") using this patched view and calls the `common_test` function.\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception when called. This method is intended to be overridden by subclasses.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If the operation would result in division by zero.\n""""""'
True, '""""""\nRaises a ZeroDivisionError exception when called. This method is intended to be overridden by subclasses.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    ZeroDivisionError: If this method is called.\n""""""'
True, '""""""\nTeardowns synchronization after an exception.\n\nThis function is called when an exception occurs during a sync operation. It ensures that any ongoing synchronization operations are properly cleaned up to prevent resource leaks or other issues.\n\nArgs:\n    exc (BaseException | None): The exception that occurred during the sync operation, or None if no exception occurred.\n""""""'
True, '""""""\nTeardowns an asynchronous operation.\n\nThis function is used to handle exceptions that occur during an asynchronous operation.\nIt provides a way to clean up resources and restore the original state of the system\nafter an exception has occurred.\n\nArgs:\n    exc (BaseException | None): The exception that occurred during the operation. Can be None if no exception occurred.\n\nReturns:\n    None: This function does not return any value, it only cleans up resources.\n""""""'
True, '""""""\nReturns a JSON dictionary with a greeting message.\n\nArgs:\n\nNone\n\nReturns:\n\nA dictionary containing a string response.\n\nExample:\n    >>> hello_json_dict()\n    {\'response\': \'Hello, World!\'}\n""""""'
False, '""""""\nReturns a JSON list containing two objects with \'message\' key.\n\nArgs:\n\nNone\n\nReturns:\n\nlist[t.Any]: A list of dictionaries, each containing a string message.\n\nExample:\nhello_json_list() -> [{""message"": ""Hello""}, {""message"": ""World""}]'
False, 'Teardowns an asynchronous operation.\n\nThis function is used to handle exceptions that occur during an asynchronous operation.\nIt provides a way to clean up resources and restore the original state of the system\nafter an exception has occurred.\n\nArgs:\n    exc (BaseException | None): The exception that occurred during the operation. Can be None if no exception occurred.\n\nReturns:\n    None: This function does not return any value, it only cleans up resources.'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current Blueprint with the Flask application.\n\n    This method checks if a Blueprint with the same name already exists and raises an error if it does.\n    It then adds the Blueprint to the application\'s blueprints dictionary and updates various internal state variables.\n\n    Args:\n        app (Flask): The Flask application instance.\n        options (dict): A dictionary of options for the Blueprint registration process.\n\n    Raises:\n        ValueError: If a Blueprint with the same name already exists in the application.\n    """"""'
True, '""""""\nTest the functionality of a Flask application with nested subdomains.\n\nThis function tests that a Flask application can be configured to use a parent and child Blueprint, \nwith the child Blueprint accessible at a subdomain. The test verifies that the client can successfully \naccess the child endpoint without encountering any redirects.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (Client): The client instance used for testing.\n\nReturns:\nNone\n""""""'
True, '""""""\nReturns the string \'child\'.\n\nThis function is likely part of a larger application or framework and serves as an index or entry point. The returned value suggests that it may be used to navigate to a child component or page.\n\nArgs:\n\nNone\n\nReturns:\nstr: The string \'child\'\n\nRaises:\nNo exceptions are expected to be raised by this function.\n""""""'
True, '""""""\nTest that a child Blueprint overrides the parent\'s subdomain.\n\nThis test ensures that when accessing the root URL of the application,\nthe child Blueprint is used instead of the parent, even if the request\nis made to the parent\'s subdomain. This is necessary because Flask does not\ndefault to using the child Blueprint when a request is made to the parent\'s\nsubdomain.\n\nThe test creates two Blueprints: one for the parent and one for the child.\nIt then registers the child Blueprint with the parent, but only after setting\nthe `client.allow_subdomain_redirects` flag to True. This allows the client\nto make requests to the parent\'s subdomain without being redirected to the root.\n\nFinally, the test makes two GET requests: one to the root URL of the application,\nand one to the parent\'s subdomain. The first request should return a 200 status\ncode, indicating that the child Blueprint was used. The second request should\nreturn a 404 status code, indicating that the parent Blueprint was not used.\n\nThis test ensures that the child Blueprint is correctly overridden by the parent\nwhen accessing the root URL of the application.\n""""""'
True, '""""""\nReturns the string \'child\'.\n\nThis function is likely part of a larger application or framework and serves as an index or entry point. The returned value suggests that it may be used to navigate to a child component or page.\n\nArgs:\n\nNone\n\nReturns:\nstr: The string \'child\'\n\nRaises:\nNo exceptions are expected to be raised by this function.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
True, '""""""\nTest that a child Blueprint overrides the parent\'s subdomain.\n\nThis test ensures that when accessing the root URL of the application,\nthe child Blueprint is used instead of the parent, even if the request\nis made to the parent\'s subdomain. This is necessary because Flask does not\ndefault to using the child Blueprint when a request is made to the parent\'s\nsubdomain.\n\nThe test creates two Blueprints: one for the parent and one for the child.\nIt then registers the child Blueprint with the parent, but only after setting\nthe `client.allow_subdomain_redirects` flag to True. This allows the client\nto make requests to the parent\'s subdomain without being redirected to the root.\n\nFinally, the test makes two GET requests: one to the root URL of the application,\nand one to the parent\'s subdomain. The first request should return a 200 status\ncode, indicating that the child Blueprint was used. The second request should\nreturn a 404 status code, indicating that the parent Blueprint was not used.\n\nThis test ensures that the child Blueprint is correctly overridden by the parent\nwhen accessing the root URL of the application.\n""""""'
True, '""""""\nTest application tearing down with unhandled exception.\n\nThis test case verifies that the application properly tears down when an unhandled exception is raised during request processing.\nIt sets up a Flask app, configures it to propagate exceptions, and then attempts to access a route that raises a ValueError.\nThe teardown_appcontext decorator is used to catch any exceptions that occur during request processing and store them in the cleanup_stuff list.\nFinally, the test asserts that one exception was caught and that its message matches the expected value.\n\nArgs:\n    app (Flask): The Flask application instance.\n    client (Client): The test client instance.\n\nRaises:\n    ValueError: If the test fails to catch an unhandled exception.\n""""""'
True, '""""""\nRaises a ValueError with a dummy message.\n \nParameters:\n None\n \n Returns:\n None\n \n Raises:\n ValueError: Dummy error message.\n """"""'
False, '""""""\nTest the functionality of Flask\'s static route with host matching.\n\nThis test case checks that a Flask application can serve static files from a URL\nthat matches the `static_host` configuration. It also tests error cases where\neither `host_matching` or `static_host` are not provided, and when `host_matching`\nis provided but `static_folder` is not.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If any of the test assertions fail.\n""""""\n\ndef _static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=""example.com"")\n    c = app.test_client()\n    rv = c.get(""http://example.com/static/index.html"")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(""static"", filename=""index.html"", _external=True)\n        assert rv == ""http://example.com/static/index.html""\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=""example.com"")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)'
True, '""""""\nCreates a new Flask application instance with Celery configuration and blueprint registration.\n\nReturns:\n    A fully configured Flask application instance.\n""""""'
True, '""""""\nReturns an HTML template rendered from \'index.html\' using the `render_template` function.\n\nArgs:\n    None\n\nReturns:\n    str: The rendered HTML content of the \'index.html\' template.\n""""""'
True, '""""""\nInitialize the Celery application for a Flask application.\n\nThis function sets up the Celery application with the provided Flask application.\nIt configures the Celery application from the Flask application\'s configuration,\nsets default settings, and registers the Celery application as an extension of the Flask application.\n\nArgs:\n    app (Flask): The Flask application to initialize the Celery application for.\n\nReturns:\n    Celery: The initialized Celery application.\n""""""'
True, '""""""\nCall the run method of the current instance within an application context.\n\nThis function is a special method that allows instances to be called like functions.\nIt sets up an application context and then calls the run method on the instance,\npassing any provided arguments and keyword arguments to it.\n\nArgs:\n    *args (object): Variable number of positional arguments to pass to the run method.\n    **kwargs (object): Variable number of keyword arguments to pass to the run method.\n\nReturns:\n    object: The result of calling the run method on the instance with the provided arguments and keyword arguments.\n""""""'
True, '""""""\nAdds two integers together.\n\nArgs:\n    a (int): The first integer to be added.\n    b (int): The second integer to be added.\n\nReturns:\n    int: The sum of the two input integers.\n\nRaises:\n    TypeError: If either \'a\' or \'b\' is not an integer.\n\nExample:\n    >>> add(3, 5)\n    8\n""""""'
True, '""""""\nBlocks the execution of the program for 5 seconds.\n\nThis function uses the `time` module\'s `sleep` function to pause the execution of the program for a specified amount of time. It does not return any value and is intended to be used as a blocking operation.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nProcess a task and update its state.\n\nThis function updates the state of a task to \'PROGRESS\' with metadata indicating the current progress.\nIt then waits for 1 second between each update before returning the final state.\n\nArgs:\n    self (Task): The task object being processed.\n    total (int): The total number of steps in the process.\n\nReturns:\n    dict: A dictionary containing the final state of the task, including \'current\' and \'total\' values.\n""""""'
True, '""""""\nReturns a dictionary containing the status and result of an asynchronous operation.\n\nArgs:\n    id (str): The ID of the asynchronous operation.\n\nReturns:\n    dict[str, object]: A dictionary with the following keys:\n        - ""ready"": A boolean indicating whether the operation is ready.\n        - ""successful"": A boolean indicating whether the operation was successful. If not ready, this will be None.\n        - ""value"": The result of the operation if it\'s ready; otherwise, the result itself.\n\nRaises:\n    TypeError: If the input ID is not a string.\n""""""'
False, '""""""\nAdds two numbers and returns the ID of the task that performs this operation.\n\nArgs:\n    a (int): The first number to add.\n    b (int): The second number to add.\n\nReturns:\n    dict[str, object]: A dictionary containing the ID of the task that performs the addition.\n\nNote: This function uses Celery\'s `delay` method to perform the addition in the background,\n      allowing for asynchronous processing and potentially improving performance.\n""""""\ndef add() -> dict[str, object]:\n    a = request.form.get(""a"", type=int)\n    b = request.form.get(""b"", type=int)\n    result = tasks.add.delay(a, b)\n    return {""result_id"": result.id}'
True, '""""""\nBlocks the execution of a task and returns its ID.\n\nThis function uses Celery\'s `delay` method to execute a task asynchronously.\nThe returned dictionary contains the ID of the executed task.\n\nArgs:\n    None\n\nReturns:\n    dict[str, object]: A dictionary containing the result ID of the blocked task.\n\nRaises:\n    None\n""""""'
True, '""""""\nProcesses a task and returns the ID of the delayed job.\n\nThis function takes no arguments and returns a dictionary containing the ID of the delayed job.\nThe delay is set to the total value provided in the request form, defaulting to 0 if not specified.\n\nReturns:\n    dict[str, object]: A dictionary containing the result_id of the delayed job.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, 'def render_template(\n    """"""\n    Renders a Jinja2 template with the given context.\n\n    Args:\n        template_name_or_list (t.Union[str, Template, t.List[t.Union[str, Template]]]): \n            The name or list of names of the templates to be rendered. Can also be a single\n            Template object.\n        **context (t.Any): \n            A dictionary-like object containing variables to be passed to the template.\n\n    Returns:\n        str: The rendered HTML content of the template.\n\n    Raises:\n        ValueError: If the provided template name or list is invalid.\n    """"""\n    app = current_app._get_current_object()  # type: ignore[attr-defined]\n    template = app.jinja_env.get_or_select_template(template_name_or_list)\n    return _render(app, template, context)'
False, 'def stream_template(\n    """"""\n    Streams a Jinja2 template to the output.\n\n    Args:\n        template_name_or_list (t.Union[str, Template, t.List[t.Union[str, Template]]]): \n            The name or list of names of the templates to be streamed. Can also be a single Template object.\n        **context (t.Any): \n            Keyword arguments to be passed to the Jinja2 template.\n\n    Returns:\n        t.Iterator[str]: An iterator over the rendered template as strings.\n    """"""\n    app = current_app._get_current_object()  # type: ignore[attr-defined]\n    template = app.jinja_env.get_or_select_template(template_name_or_list)\n    return _stream(app, template, context)'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
True, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.\n""""""'
False, '```python\ndef run(\n    host: t.Optional[str] = None,\n    port: t.Optional[int] = None,\n    debug: t.Optional[bool] = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This method is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If these\n    parameters are not provided, they will be set based on the configuration\n    of the application.\n\n    Args:\n        host: The hostname or IP address to bind to. Defaults to None.\n        port: The port number to use. Defaults to None.\n        debug: A boolean indicating whether to enable debug mode. Defaults to None.\n        load_dotenv: A boolean indicating whether to load environment variables\n            from a .env file. Defaults to True.\n        **options: Additional keyword arguments to pass to the `run_simple`\n            function.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid port number is provided.\n    """"""\n```'
False, 'def full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches a request and handles its outcome.\n\n    This method initiates the request processing pipeline, which includes\n    preprocessing, dispatching, handling exceptions, and finalizing the response.\n    \n    If an exception occurs during this process, it is caught and handled by \n    the `handle_user_exception` method. The response is then finalized using \n    the `finalize_request` method.\n\n    Returns:\n        Response: The processed response from the request dispatching pipeline.\n    """"""'
True, '""""""\nDeprecation Warning: `_{self.name}_ctx_stack` is deprecated and will be removed in Flask 2.4.\nUse \'g\' to store data, or \'{self.name}_ctx\' to access the current context.\n\nReturns:\n    t.Optional[t.Any]: The value stored in the context variable `None`, or `None` if not set.\n""""""'
False, '""""""\nReturns the value of a named attribute, raising an AttributeError if the attribute does not exist.\n\nIf the attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns the corresponding context object and issues a DeprecationWarning for future removal in Flask 2.4.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    t.Any: The value of the named attribute, or raises AttributeError if not found.\n""""""\ndef __getattr__(name: str) -> t.Any:'
True, '""""""\nReturns a boolean indicating whether debug mode is enabled.\n\nThe value of the `FLASK_DEBUG` environment variable is checked. If it exists, its value is converted to lowercase and compared with \'0\', \'false\', or \'no\'. If the value matches any of these strings, debug mode is disabled; otherwise, it\'s enabled.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether debug mode is enabled.\n""""""'
False, '""""""\nDumps an object to a JSON string.\n\nThis function takes an object and optional keyword arguments, and returns a JSON string representation of the object. If `current_app` is defined, it will use its `json.dumps()` method; otherwise, it will fall back to the `_json.dumps()` method with the provided keyword arguments.\n\nArgs:\n    obj: The object to be dumped to JSON.\n    **kwargs: Optional keyword arguments for customizing the dumping process.\n\nReturns:\n    A JSON string representation of the input object.'
True, '""""""\nDumps the provided object to a file stream.\n\nThis function is used to serialize and dump objects to a file. It supports both Flask\'s `current_app.json` and the standard `_json` library for dumping objects.\n\nArgs:\n    obj (t.Any): The object to be dumped.\n    fp (t.IO[str]): The file stream where the object will be written.\n    **kwargs (t.Any): Additional keyword arguments to be passed to the dump function. If `current_app` is not set, these arguments are used to configure the dumping process.\n\nReturns:\n    None\n""""""'
True, '""""""\nLoads JSON data from a string or bytes object.\n\nThis function is used to parse JSON data from various sources. It can handle both strings and bytes objects as input.\nThe `current_app` variable is used to determine the context in which this function is being called. If it exists, \nit will use its `json.loads` method to parse the data. Otherwise, it will fall back to a generic `_json.loads` method.\n\nArgs:\n    s (str | bytes): The JSON data to be loaded.\n    **kwargs: Additional keyword arguments to be passed to the parsing function.\n\nReturns:\n    t.Any: The parsed JSON data.\n\nRaises:\n    None\n""""""'
True, '""""""\nLoads JSON data from a file.\n\nThis function takes an open file object `fp` and optional keyword arguments `**kwargs`.\nIf the `current_app` context is available, it will use its `json.load()` method to load the data.\nOtherwise, it falls back to using `_json.load()`.\n\nArgs:\n    fp (IO[AnyStr]): The file object containing the JSON data.\n    **kwargs: Optional keyword arguments to pass to the loading function.\n\nReturns:\n    Any: The loaded JSON data.\n""""""'
False, 'def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n    """"""\n    Serializes an object into a JSON string.\n\n    Args:\n        obj (t.Any): The object to be serialized.\n        **kwargs (t.Any): Keyword arguments that override the default settings.\n            - ""default"" (optional): The value to use when a serializable object cannot be found. Defaults to self.default.\n            - ""ensure_ascii"" (optional): Whether to ensure all characters are ASCII. Defaults to self.ensure_ascii.\n            - ""sort_keys"" (optional): Whether to sort the keys in the JSON string. Defaults to self.sort_keys.\n\n    Returns:\n        str: The JSON string representation of the object.\n    """"""'
True, '""""""\nReturns a response object with the prepared data.\n\nThis method prepares an HTTP response based on the provided arguments and \nconfiguration. It uses the `_prepare_response_obj` method to prepare the \nresponse object and then formats it according to the specified dump_args.\n\nArgs:\n    *args: Variable length argument list containing any type of data.\n    **kwargs: Keyworded arguments containing any type of data.\n\nReturns:\n    Response: An HTTP response object with the prepared data.\n""""""'
False, '""""""\nProcesses an application request and tests the before, after, and teardown events.\n\nThis function creates a Flask Blueprint with three event handlers: `before_app`, \n`after_app`, and `teardown_app`. These handlers are used to track events in the \nrequest processing pipeline. The function then tests these events by sending two \nrequests to the application endpoint.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (Client): A client object for making HTTP requests.\n\nReturns:\nNone\n""""""\ndef test_app_request_processing(app, client):'
False, '""""""\nTests the functionality of the `get_debug_flag` function.\n\nThis test case verifies that the `get_debug_flag` function returns the correct value when the Flask debug flag is set to a specific value.\n\nParameters:\n    monkeypatch (object): A mock object used for patching environment variables.\n    debug (bool): The expected value of the Flask debug flag.\n    expect (bool): The expected return value of the `get_debug_flag` function.\n\nReturns:\n    None\n""""""\ndef test_get_debug_flag(self, monkeypatch, debug, expect):\n    monkeypatch.setenv(""FLASK_DEBUG"", debug)\n    assert get_debug_flag() == expect'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nTest session special types.\n\nThis function tests the behavior of Flask\'s session object when storing\nspecial types such as bytes, Markup objects, and UUIDs. It verifies that\nthese types are stored correctly and can be retrieved later.\n\nParameters:\napp (Flask application): The Flask application instance.\nclient (Client): The client instance used for testing.\n\nReturns:\nNone\n""""""'
True, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\nNone\n\nReturns:\nstr: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the flashed messages are correctly retrieved and asserted.\n\nThis function tests the functionality of Flask\'s `get_flashed_messages` method.\nIt asserts that the returned list of messages matches the expected output,\nwhich includes a mix of plain text and HTML markup. If the assertion fails,\nit returns an empty string to indicate test failure.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of the `get_flashed_messages` function from Flask, \nspecifically when using category filters.\n\nThis test case checks that the function returns a list of messages with their respective categories,\nand that it correctly handles the \'with_categories\' parameter.\n\nParameters:\n- None\n\nReturns:\n- A string indicating whether the test passed or failed.\n""""""\ndef test_filters():\n    messages = flask.get_flashed_messages(\n        category_filter=[""message"", ""warning""], with_categories=True\n    )\n    assert list(messages) == [\n        (""message"", ""Hello World""),\n        (""warning"", Markup(""<em>Testing</em>"")),\n    ]\n    return """"'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n""""""'
True, '""""""\nTests the escaping of HTML characters in a Flask application.\n\nThis function tests that the Flask application correctly escapes HTML characters\nin the `text` variable, which is passed to the `escaping_template.html` template.\nThe test checks that the escaped characters are properly rendered as HTML entities.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (Client): The client instance used for testing.\n\nReturns:\nNone\n""""""'
True, '""""""\nReturns an HTML template with escaped text and HTML markup.\n\nThis function uses Flask\'s `render_template` method to render a template\nwith the provided text and HTML markup. The `text` parameter is passed as-is,\nwhile the `html` parameter is marked up using Markup from the Marked library.\n\nArgs:\n    text (str): The text to be rendered in the template.\n    html (Markup): The HTML markup to be rendered in the template.\n\nReturns:\n    flask.Response: The rendered HTML response.\n""""""'
True, '""""""\nTest function to verify that HTML escaping is not applied in the Flask application.\n\nThis test checks if the `flask.render_template` function correctly passes through the HTML text without escaping it, \nand if the client receives the escaped version of the HTML text.\n\nParameters:\napp (Flask app): The Flask application instance.\nclient (Client): The client instance used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nReturns an HTML page using Flask\'s render_template function.\n\nThis function takes in a template file name and passes two variables: \'text\' and \'html\'. The \'text\' variable is rendered as plain text, while the \'html\' variable is rendered with HTML escaping enabled to prevent XSS attacks. \n\nParameters:\n    None\n\nReturns:\n    A rendered Flask template object\n""""""'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nDeprecation Notice: `got_first_request` is deprecated and will be removed in Flask 2.4.\n\nReturns:\n    bool: Whether the first request has been received.\n\nRaises:\n    DeprecationWarning: If the function is called, indicating that it should not be used.\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
True, '""""""\nInitialize a cached property with optional getter, name, and documentation.\n\nThis method initializes a cached property with the provided getter function, \nname (defaulting to None), and documentation (defaulting to None). It also sets up \na lock for thread-safe access to the property.\n\nArgs:\n    fget: The getter function for the property.\n    name: The name of the property (optional).\n    doc: The documentation string for the property (optional).\n\nReturns:\n    None\n""""""'
True, '""""""\nLoads a configuration file from disk.\n\nThis method attempts to open the specified file and load its contents using the provided `load` function.\nIf successful, it returns whether the loaded object is a mapping (i.e., a dictionary or similar data structure).\nIf an error occurs while loading the file, it will be raised unless `silent` is True, in which case it will return False instead.\n\nParameters:\nfilename (str): The path to the configuration file to load.\nload (Callable[[IO[Any], Mapping]): A function that takes an IO object and returns a mapping.\nsilent (bool, optional): Whether to suppress error messages. Defaults to False.\ntext (bool, optional): Whether to open the file in text mode instead of binary mode. Defaults to True.\n\nReturns:\nbool: Whether the loaded object is a mapping or not.\n""""""'
True, '""""""\nLoads the application configuration from a JSON file.\n\nThis function initializes a Flask application instance and loads its configuration\nfrom a JSON file named \'config.json\' located in the \'static\' directory of the current working directory.\nThe loaded configuration is then passed to the `common_object_test` function for further processing.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    FileNotFoundError: If the \'config.json\' file does not exist in the specified location.\n    json.JSONDecodeError: If the \'config.json\' file contains invalid JSON data.\n""""""'
False, '""""""\nTests configuration from a TOML file.\n\nThis function tests the ability to load configuration from a TOML file using the `tomllib` library.\nIt creates a Flask application instance and loads the configuration from a file named ""config.toml"" in the static directory of the current working directory.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""\ndef test_config_from_file_toml():'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns the name of the session cookie.\n\nThis method is deprecated and will be removed in Flask 2.3. Instead, use\n`app.config[\'SESSION_COOKIE_NAME\']`.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the session cookie.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `session_cookie_name` method is deprecated and will be removed in Flask 2.3.\nUse the \'SESSION_COOKIE_NAME\' configuration option in \'app.config\' instead.\n\nParameters:\nvalue (str): The new session cookie name.\n\nReturns:\nNone\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nReturns:\n    Optional[timedelta]: The maximum age for sending files, or None if not set.\n\nRaises:\n    DeprecationWarning: If the deprecated method is called.\n\nNote:\nThis function is only available for backwards compatibility and should not be used in new code.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nParameters:\n    value (Union[int, timedelta, None]): The maximum age of sent files in seconds.\n        If int, the value is used directly as a number of seconds.\n        If timedelta, the value is converted to seconds.\n        If None, no default is set.\n\nReturns:\n    None\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `use_x_sendfile` method is deprecated and will be removed in Flask 2.3.\nInstead, use the \'USE_X_SENDFILE\' configuration option in the application\'s\nconfiguration dictionary.\n\nReturns:\n    bool: The value of the \'USE_X_SENDFILE\' configuration option.\n\nRaises:\n    DeprecationWarning: If the \'use_x_sendfile\' method is called.\n""""""'
False, '""""""\nDeprecates the use of `use_x_sendfile` method and replaces it with using the `USE_X_SENDFILE` configuration option.\n\n### Parameters\n\n- **value** (`bool`): A boolean indicating whether to enable or disable xSendFile functionality.\n\n### Returns\n\n- None\n""""""\n \nimport warnings\n\nwarnings.warn(\n    ""\'use_x_sendfile\' is deprecated and will be removed in Flask 2.3. Use""\n    "" \'USE_X_SENDFILE\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\n\nself.config[""USE_X_SENDFILE""] = value'
True, '""""""\nReturns the JSON encoder class for this application.\n\nThis method is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'.\nThe `DeprecationWarning` will be raised when calling this function.\n \nArgs:\n    None\n \nReturns:\n    t.Type[json.JSONEncoder]: The JSON encoder class.\n""""""'
True, '""""""\nDeprecation Warning: `json_encoder` is deprecated and will be removed in Flask 2.3.\nCustomize `json_provider_class` or `json` instead.\n\nArgs:\n    value (t.Type[json.JSONEncoder]): The new JSON encoder class to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the JSON decoder class.\n\nThis function returns the JSON decoder class used by the application. It is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'. \n\nParameters:\n    None\n\nReturns:\n    t.Type[json.JSONDecoder]: The JSON decoder class.\n\nRaises:\n    DeprecationWarning: If \'app.json_decoder\' is called, it will raise a deprecation warning.\n""""""'
True, '""""""\nDecodes JSON data using the provided decoder.\n\nThis function is deprecated in Flask 2.3 and will be removed.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Type[json.JSONDecoder]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
False, 'def __init__(\n    self,\n    import_name: str,\n    static_url_path: t.Optional[str] = None,\n    static_folder: t.Optional[t.Union[str, os.PathLike]] = ""static"",\n    static_host: t.Optional[str] = None,\n    host_matching: bool = False,\n    subdomain_matching: bool = False,\n    template_folder: t.Optional[t.Union[str, os.PathLike]] = ""templates"",\n    instance_path: t.Optional[str] = None,\n    instance_relative_config: bool = False,\n    root_path: t.Optional[str] = None,\n):\n    """"""\n    Initializes a new Flask application.\n\n    This method is called when creating a new Flask application. It sets up the\n    basic configuration and initializes the internal state of the application.\n\n    :param import_name: The name of the module to import.\n    :param static_url_path: The URL path for serving static files.\n    :param static_folder: The folder where static files are stored.\n    :param static_host: The host for serving static files.\n    :param host_matching: Whether to match hosts in routing.\n    :param subdomain_matching: Whether to match subdomains in routing.\n    :param template_folder: The folder where templates are stored.\n    :param instance_path: The path to the instance folder. If not provided, it\n        will be automatically determined.\n    :param instance_relative_config: Whether to load configuration from files\n        relative to the instance folder.\n    :param root_path: The root path of the application.\n\n    .. versionadded:: 0.8\n\n    .. deprecated:: 2.2\n        Will be removed in Flask 2.3. Run setup code when creating the\n        application instead.\n    """"""\n\n    super().__init__(\n        import_name=import_name,\n        static_folder=static_folder,\n        static_url_path=static_url_path,\n        template_folder=template_folder,\n        root_path=root_path,\n    )\n\n    if instance_path is None:\n        instance_path = self.auto_find_instance_path()\n    elif not os.path.isabs(instance_path):\n        raise ValueError(\n            ""If an instance path is provided it must be absolute.""\n            "" A relative path was given instead.""\n        )\n\n    #: Holds the path to the instance folder.\n    #: \n    #: .. versionadded:: 0.8\n    self.instance_path = instance_path\n\n    #: The configuration dictionary as :class:`Config`.  This behaves\n    #: exactly like a regular dictionary but supports additional methods\n    #: to load a config from files.\n    #: \n    #: .. versionadded:: 0.8\n    self.config = self.make_config(instance_relative_config)\n\n    #: An instance of :attr:`aborter_class` created by\n    #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n    #: to raise HTTP errors, and can be called directly as well.\n    #: \n    #: .. versionadded:: 2.2\n    #:     Moved from ``flask.abort``, which calls this object.\n    self.aborter = self.make_aborter()\n\n    self.json: JSONProvider = self.json_provider_class(self)\n    """"""\n    Provides access to JSON methods.\n\n    Functions in ``flask.json`` will call methods on this provider when the application context is active. Used for handling JSON requests and responses.\n\n    An instance of :attr:`json_provider_class`. Can be customized by changing that attribute on a subclass, or by assigning to this attribute afterwards.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n    uses Python\'s built-in :mod:`json` library. A different provider\n    can use a different JSON library.\n\n    .. versionadded:: 2.2\n    """"""\n\n    #: A list of functions that are called by\n    #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n    #: :exc:`~werkzeug.routing.BuildError`. Each function is called with ``error``, ``endpoint`` and ``values``. If a function returns ``None`` or raises a ``BuildError``, it is skipped.\n    #: Otherwise, its return value is returned by ``url_for``.\n    #: \n    #: .. versionadded:: 0.9\n    self.url_build_error_handlers: t.List[\n        t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n    ] = []\n\n    #: A list of functions that will be called at the beginning of the\n    #: first request to this instance. To register a function, use the\n    #: :meth:`before_first_request` decorator.\n    #: \n    #: .. deprecated:: 2.2\n    #:     Will be removed in Flask 2.3. Run setup code when creating the application instead.\n    #: \n    #: .. versionadded:: 0.8\n    self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []\n\n    #: A list of functions that are called when the application context\n    #: is destroyed.  Since the application context is also torn down\n    #: if the request ends this is the place to store code that disconnects\n    #: from databases.\n    #: \n    #: .. versionadded:: 0.9\n    self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []\n\n    #: A list of shell context processor functions that should be run\n    #: when a shell context is created.\n    #: \n    #: .. versionadded:: 0.11\n    self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []\n\n    #: Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in.\n    #: Blueprints can be registered multiple times, this dict does not track how often they were attached.\n    #: \n    #: .. versionadded:: 0.7\n    self.blueprints: t.Dict[str, ""Blueprint""] = {}\n\n    #: a place where extensions can store application specific state.  For example this is where an extension could store database engines and similar things.\n    #: \n    #: The key must match the name of the extension module. For example in case of a ""Flask-Foo"" extension in `flask_foo`, the key would be `\'foo\'`.\n    #: \n    #: .. versionadded:: 0.7\n    self.extensions: dict = {}\n\n    #: The :class:`~werkzeug.routing.Map` for this instance.  You can use this to change the routing converters after the class was created but before any routes are connected.  Example::\n    #: \n    #:    from werkzeug.routing import BaseConverter\n    #: \n    #:    class ListConverter(BaseConverter):\n    #:        def to_python(self, value):\n    #:            return value.split(\',\')\n    #:        def to_url(self, values):\n    #:            return \',\'.join(super(ListConverter, self).to_url(value)\n    #:                            for value in values)\n    #:\n    #:    app = Flask(__name__)\n    #:    app.url_map.converters[\'list\'] = ListConverter\n    self.url_map = self.url_map_class()\n\n    self.url_map.host_matching = host_matching\n    self.subdomain_matching = subdomain_matching\n\n    # tracks internally if the application already handled at least one request.\n    self._got_first_request = False\n    self._before_request_lock = Lock()\n\n    # Add a static route using the provided static_url_path, static_host,\n    # and static_folder if there is a configured static_folder.\n    # Note we do this without checking if static_folder exists.\n    # For one, it might be created while the server is running (e.g. during\n    # development). Also, Google App Engine stores static files somewhere\n    if self.has_static_folder:\n        assert (\n            bool(static_host) == host_matching\n        ), ""Invalid static_host/host_matching combination""\n        # Use a weakref to avoid creating a reference cycle between the app\n        # and the view function (see #3761).\n        self_ref = weakref.ref(self)\n        self.add_url_rule(\n            f""{self.static_url_path}/<path:filename>"",\n            endpoint=""static"",\n            host=static_host,\n            view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n        )\n\n    # Set the name of the Click group in case someone wants to add\n    # the app\'s commands to another CLI tool.\n    self.cli.name = self.name'
True, '""""""\nPropagates exceptions to the application\'s context.\n\nThis function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\nIf it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether exceptions should be propagated to the application\'s context.\n""""""'
False, 'def make_config(\n    """"""\n    Creates a configuration object for the application.\n\n    Args:\n        instance_relative (bool): If True, uses the instance\'s path as the root path.\n            Defaults to False.\n\n    Returns:\n        Config: The created configuration object.\n    """"""\n    root_path = self.root_path\n    if instance_relative:\n        root_path = self.instance_path\n    defaults = dict(self.default_config)\n    defaults[""ENV""] = os.environ.get(""FLASK_ENV"") or ""production""\n    defaults[""DEBUG""] = get_debug_flag()\n    return self.config_class(root_path, defaults)'
True, '""""""\nReturns the value of `TEMPLATES_AUTO_RELOAD` from the application configuration.\n\nIf `TEMPLATES_AUTO_RELOAD` is set, its value is returned. Otherwise, the value of `debug` is used as a fallback.\n\nDeprecated since Flask 2.3 in favor of using `TEMPLATES_AUTO_RELOAD` in `app.config`.\n\nArgs:\n    None\n\nReturns:\n    bool: The value of `TEMPLATES_AUTO_RELOAD` or `debug` if not set.\n""""""'
False, '""""""\nDeprecation Notice:\n\n    The `templates_auto_reload` method is deprecated and will be removed in Flask 2.3.\n    Use the \'TEMPLATES_AUTO_RELOAD\' configuration option instead.\n\n    Args:\n        value (bool): Whether to enable or disable template auto-reload.\n\n    Returns:\n        None\n""""""\ndef templates_auto_reload(self, value: bool) -> None:\nimport warnings\n\nwarnings.warn(\n    ""\'templates_auto_reload\' is deprecated and will be removed in Flask 2.3.""\n    "" Use \'TEMPLATES_AUTO_RELOAD\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\nself.config[""TEMPLATES_AUTO_RELOAD""] = value'
True, '""""""\nReturns the environment variable as a string.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3.\nUse `app.debug` instead.\n\nArgs:\n    None\n\nReturns:\n    str: The environment variable value.\n\nRaises:\n    DeprecationWarning: If the \'app.env\' method is called.\n""""""'
True, '""""""\nDeprecation Warning: `env` method is deprecated and will be removed in Flask 2.3.\nUse `debug` attribute instead.\n\nArgs:\n    value (str): The environment variable to set.\n\nReturns:\n    None\n""""""'
False, '```\nRun the Flask Development Server.\n\n### Parameters\n\n- `host`: The host IP address or hostname to bind to (default: None)\n- `port`: The port number to use for the server (default: None)\n- `debug`: Whether to enable debug mode (default: None, will override other sources)\n- `load_dotenv`: Whether to load environment variables from a .env file (default: True)\n- `options`: Additional options for the server (default: {})\n\n### Returns\n\nNone. This function runs the Flask development server and does not return any value.\n\n### Notes\n\nThis function is used to run the Flask development server. It takes several parameters, including host, port, debug mode, and environment variables from a .env file. The `debug` parameter can override other sources of debug information. If no host or port are provided, it will use the default values. The `options` dictionary can be used to customize the behavior of the server.\n\n### Example Usage\n\n```python\napp = Flask(__name__)\napp.run(host=""0.0.0.0"", port=5000)\n```\n\nThis example runs the Flask development server on host ""0.0.0.0"" and port 5000.'
True, '""""""\nDeprecation Warning: before_first_request function is deprecated and will be removed in Flask 2.3.\n \n   To avoid deprecation warnings, run setup code while creating the application instead.\n\n   Parameters:\n       f (T_before_first_request): The function to be executed before the first request.\n\n   Returns:\n       T_before_first_request: The input function for appending to self.before_first_request_funcs.\n\n   Note:\n       This function is deprecated and should not be used in new applications. Instead, run setup code while creating the application.\n""""""'
True, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\n----------\nself : object\n    The instance of the class that this method belongs to.\n\nReturns\n-------\nResponse\n    The response from the dispatching process.\n""""""'
True, '""""""\nReturns the JSON encoder class, deprecation warning if applicable.\n\nThis function is deprecated and will be removed in Flask 2.3. It\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    None\n\nReturns:\n    t.Union[t.Type[json.JSONEncoder], None]: The JSON encoder class or None.\n""""""'
True, '""""""\nDeprecation Warning: json_encoder function is deprecated and will be removed in Flask 2.3.\n \nTo customize the JSON encoding behavior, use either \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    value (Union[Type[JSONEncoder], None]): The JSON encoder class to use. Defaults to None.\n\nReturns:\n    None\n""""""'
False, '""""""\nDecodes JSON data.\n\nThis function returns the instance of `JSONDecoder` class, which is used to decode JSON data.\nHowever, due to deprecation, it\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nReturns:\n    t.Union[t.Type[json.JSONDecoder], None]: The instance of `JSONDecoder` class or None if not available.'
True, '""""""\nDecodes JSON values.\n\nThis function is deprecated and will be removed in Flask 2.3.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Union[t.Type[json.JSONDecoder], None]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `before_app_first_request` function is deprecated and will be removed in Flask 2.3.\nUse the `record_once` method instead to run setup code when registering a blueprint.\n\nParameters:\nf (T_before_first_request): The function to register for before first request.\n\nReturns:\nT_before_first_request: The registered function.\n\nRaises:\nDeprecationWarning: If the function is deprecated and should be replaced with `record_once`.\n""""""'
True, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
True, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.\n""""""'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of `flask.get_flashed_messages` with category filtering.\n\nThis function tests that the `get_flashed_messages` method returns a list of\nflashed messages, filtered by categories. The test case checks that the\nfiltered messages match the expected output.\n\nParameters:\n    None\n\nReturns:\n    A string indicating whether the test passed or failed.\n""""""\ndef test_filters():'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
True, '""""""\nRenders the first request to an application.\n\nThis function simulates a client making a GET request to the root URL of the application.\nIt asserts that the `debug` attribute is set to True, and that the response from the server matches the expected value.\nAdditionally, it tests that attempting to add a new route after the first request raises an AssertionError with a specific message.\n\nArgs:\n    app (Flask application): The Flask application instance being tested.\n    client (requests.Session): A requests session object used to simulate the client\'s request.\n\nReturns:\n    None\n""""""'
True, '""""""\nRequest Functions for Application Testing\n\nThis function tests the application\'s behavior when making requests before and after the first request.\n\nParameters:\napp (object): The application object to be tested.\nclient (object): The client object used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nAdds 42 to the \'got\' list.\n\nThis function is not intended for external use and should only be accessed internally within the application.\n""""""'
True, '""""""\nConcurrently tests the application\'s routing functionality by making a request to the root URL while another thread is asserting that a value was appended to the `got` list.\n\nThis function uses pytest\'s deprecated_call context manager to ensure that the `foo` function, which appends a value to the `got` list, is called before the first request is made. It then creates a new thread that runs the `get_and_assert` function in parallel with the main thread.\n\nThe `get_and_assert` function makes a GET request to the root URL and asserts that the value appended to the `got` list matches the expected value. The main thread waits for the thread to finish before asserting that the application\'s `got_first_request` attribute is set to True.\n\nThis test ensures that the application\'s routing functionality works correctly even when multiple threads are making requests concurrently.\n""""""'
True, '""""""\nReturns the result of appending 42 to the \'got\' list after a 200ms delay.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    None\n\nExample:\n    >>> get_and_asse()\n""""""'
False, '""""""\nTests the functionality of the get method on the client object.\n\nThis test case checks if the get method returns a list containing the expected value when called with the root URL (""/"").\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.\n""""""\n\nclient.get(""/"")\nassert got == [42]\n\n""""""\nTests the functionality of threading in Python.\n\nThis test case checks if the Thread class can be instantiated correctly and if it can target a specific function.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the thread is not created successfully or if it does not target the expected function.\n""""""\n\nt = Thread(target=  # <--- Missing keyword \'self\''
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""'
True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""'
True, ""# Propagates exceptions to the application's context.\n#\n# This function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\n# If it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n#\n# Deprecation Warning: This method is deprecated and will be removed in Flask 2.3. It's recommended to use a different approach for exception propagation.\n#\n# Args:\n#     None\n#\n# Returns:\n#     bool: Whether exceptions should be propagated to the application's context.""]
False, '```python\ndef run(\n    host: t.Optional[str] = None,\n    port: t.Optional[int] = None,\n    debug: t.Optional[bool] = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This method is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If these\n    parameters are not provided, they will be set based on the configuration\n    of the application.\n\n    Args:\n        host: The hostname or IP address to bind to. Defaults to None.\n        port: The port number to use. Defaults to None.\n        debug: A boolean indicating whether to enable debug mode. Defaults to None.\n        load_dotenv: A boolean indicating whether to load environment variables\n            from a .env file. Defaults to True.\n        **options: Additional keyword arguments to pass to the `run_simple`\n            function.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid port number is provided.\n    """"""\n```'
True, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself : object\n    The instance of the class that this method belongs to.\n\nReturns\nResponse\n    The response from the dispatching process.\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of the `get_flashed_messages` function from Flask, \nspecifically when using category filters.\n\nThis test case checks that the function returns a list of messages with their respective categories,\nand that it correctly handles the \'with_categories\' parameter.\n\nParameters:\n- None\n\nReturns:\n- A string indicating whether the test passed or failed.\n""""""\ndef test_filters():\n    messages = flask.get_flashed_messages(\n        category_filter=[""message"", ""warning""], with_categories=True\n    )\n    assert list(messages) == [\n        (""message"", ""Hello World""),\n        (""warning"", Markup(""<em>Testing</em>"")),\n    ]\n    return """"'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
False, 'def url_for(\n    """"""\n    Generates a URL for the given endpoint.\n\n    This function is used to generate URLs for routes in Flask. It takes into account\n    various parameters such as scheme, domain, and anchor.\n\n    Args:\n        endpoint (str): The name of the route.\n        _anchor (t.Optional[str], optional): The anchor for the URL. Defaults to None.\n        _method (t.Optional[str], optional): The HTTP method for the URL. Defaults to None.\n        _scheme (t.Optional[str], optional): The scheme for the URL. Defaults to None.\n        _external (t.Optional[bool], optional): Whether the URL is external or not. Defaults to None.\n        **values: t.Any): Additional values to be passed to the route.\n\n    Returns:\n        str: The generated URL.\n\n    Raises:\n        RuntimeError: If unable to build URLs outside an active request without \'SERVER_NAME\' configured.\n        ValueError: If \'_scheme\' is specified when \'_external\' is False.\n    """"""\n) -> str:\n    req_ctx = _cv_request.get(None)\n\n    if req_ctx is not None:\n        url_adapter = req_ctx.url_adapter\n        blueprint_name = req_ctx.request.blueprint\n\n        # If the endpoint starts with ""."" and the request matches a\n        # blueprint, the endpoint is relative to the blueprint.\n        if endpoint[:1] == ""."":\n            if blueprint_name is not None:\n                endpoint = f""{blueprint_name}{endpoint}""\n            else:\n                endpoint = endpoint[1:]\n\n        # When in a request, generate a URL without scheme and\n        # domain by default, unless a scheme is given.\n        if _external is None:\n            _external = _scheme is not None\n    else:\n        app_ctx = _cv_app.get(None)\n\n        # If called by helpers.url_for, an app context is active,\n        # use its url_adapter. Otherwise, app.url_for was called\n        # directly, build an adapter.\n        if app_ctx is not None:\n            url_adapter = app_ctx.url_adapter\n        else:\n            url_adapter = self.create_url_adapter(None)\n\n        if url_adapter is None:\n            raise RuntimeError(\n                ""Unable to build URLs outside an active request""\n                "" without \'SERVER_NAME\' configured. Also configure""\n                "" \'APPLICATION_ROOT\' and \'PREFERRED_URL_SCHEME\' as""\n                "" needed.""\n            )\n\n        # When outside a request, generate a URL with scheme and\n        # domain by default.\n        if _external is None:\n            _external = True\n\n    # It is an error to set _scheme when _external=False, in order\n    # to avoid accidental insecure URLs.\n    if _scheme is not None and not _external:\n        raise ValueError(""When specifying \'_scheme\', \'_external\' must be True."")\n\n    self.inject_url_defaults(endpoint, values)\n\n    try:\n        rv = url_adapter.build(  # type: ignore[union-attr]\n            endpoint,\n            values,\n            method=_method,\n            url_scheme=_scheme,\n            force_external=_external,\n        )\n    except BuildError as error:\n        values.update(\n            _anchor=_anchor, _method=_method, _scheme=_scheme, _external=_external\n        )\n        return self.handle_url_build_error(error, endpoint, values)\n\n    if _anchor is not None:\n        _anchor = _url_quote(_anchor, safe=""%!#$&\'()*+,/:;=?@"")\n        rv = f""{rv}#{_anchor}""\n\n    return rv'
True, '""""""\nInitialize the application.\n\nThis method is called when an instance of this class is created. It takes in various parameters to configure the application\'s URL structure.\n\nParameters:\napp (Flask): The Flask application instance.\npath (str): The root path of the application. Defaults to ""/"".\nbase_url (Optional[str]): The base URL of the application. If provided, subdomain and url_scheme cannot be used. Defaults to None.\nsubdomain (Optional[str]): The subdomain of the application. If provided with a base_url, it will override the base_url. Defaults to None.\nurl_scheme (Optional[str]): The scheme of the URL. If not provided, it will use the preferred scheme from the Flask configuration. Defaults to None.\n\nReturns:\nNone\n""""""'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""'
True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""'
False, 'def got_first_request(self) -> bool:\n    """"""\n    Returns an instance of the Logger class.\n\n    This method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\n    Args:\n        self: The current object.\n\n    Returns:\n        logging.Logger: An instance of the Logger class.\n""""""\ndef _got_first_request(self) -> bool:\n    """"""\n    Returns an instance of Jinja2\'s Environment class.\n\n    This method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\n    Note: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""\n    import warnings\n\n    warnings.warn(\n        ""\'got_first_request\' is deprecated and will be removed in Flask 2.4."",\n        DeprecationWarning,\n        stacklevel=2,\n    )'
False, '```python\ndef run(\n    host: t.Optional[str] = None,\n    port: t.Optional[int] = None,\n    debug: t.Optional[bool] = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This method is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If these\n    parameters are not provided, they will be set based on the configuration\n    of the application.\n\n    Args:\n        host: The hostname or IP address to bind to. Defaults to None.\n        port: The port number to use. Defaults to None.\n        debug: A boolean indicating whether to enable debug mode. Defaults to None.\n        load_dotenv: A boolean indicating whether to load environment variables\n            from a .env file. Defaults to True.\n        **options: Additional keyword arguments to pass to the `run_simple`\n            function.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid port number is provided.\n    """"""\n```'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    This method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\n    Parameters\n    self (object): The instance of the class that this method belongs to.\n\n    Returns\n    Response: The response from the dispatching process.\n    """"""\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of the `get_flashed_messages` function from Flask, \nspecifically when using category filters.\n\nThis test case checks that the function returns a list of messages with their respective categories,\nand that it correctly handles the \'with_categories\' parameter.\n\nParameters:\n- None\n\nReturns:\n- A string indicating whether the test passed or failed.\n""""""\ndef test_filters():\n    messages = flask.get_flashed_messages(\n        category_filter=[""message"", ""warning""], with_categories=True\n    )\n    assert list(messages) == [\n        (""message"", ""Hello World""),\n        (""warning"", Markup(""<em>Testing</em>"")),\n    ]\n    return """"'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
True, '""""""\nInitialize a new instance of the class.\n\nParameters:\n    name (str): The name of the application or module.\n    import_name (str): The import name of the application or module.\n    static_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the static folder. Defaults to None.\n    static_url_path (t.Optional[str], optional): The URL path for static files. Defaults to None.\n    template_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the template folder. Defaults to None.\n    url_prefix (t.Optional[str], optional): The prefix for URLs. Defaults to None.\n    subdomain (t.Optional[str], optional): The subdomain for URLs. Defaults to None.\n    url_defaults (t.Optional[dict], optional): Default values for URL parameters. Defaults to None.\n    root_path (t.Optional[str], optional): The root path of the application or module. Defaults to None.\n    cli_group (t.Optional[str], optional): The CLI group name. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the application or module.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for URLs.\n    deferred_functions (list): A list of deferred functions.\n    url_values_defaults (dict): Default values for URL parameters.\n    cli_group (str): The CLI group name.\n    _blueprints (list): A list of blueprints and their configurations.\n""""""'
True, '""""""\nTests that attempting to create a Flask Blueprint with an empty name raises a ValueError.\n\nArgs:\n    app (object): The application instance.\n    client (object): The test client instance.\n\nRaises:\n    ValueError: If the Blueprint name is empty.\n""""""'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns the name of the session cookie.\n\nThis method is deprecated and will be removed in Flask 2.3. Instead, use\n`app.config[\'SESSION_COOKIE_NAME\']`.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the session cookie.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `session_cookie_name` method is deprecated and will be removed in Flask 2.3.\nUse the \'SESSION_COOKIE_NAME\' configuration option in \'app.config\' instead.\n\nParameters:\nvalue (str): The new session cookie name.\n\nReturns:\nNone\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nReturns:\n    Optional[timedelta]: The maximum age for sending files, or None if not set.\n\nRaises:\n    DeprecationWarning: If the deprecated method is called.\n\nNote:\nThis function is only available for backwards compatibility and should not be used in new code.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nParameters:\n    value (Union[int, timedelta, None]): The maximum age of sent files in seconds.\n        If int, the value is used directly as a number of seconds.\n        If timedelta, the value is converted to seconds.\n        If None, no default is set.\n\nReturns:\n    None\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `use_x_sendfile` method is deprecated and will be removed in Flask 2.3.\nInstead, use the \'USE_X_SENDFILE\' configuration option in the application\'s\nconfiguration dictionary.\n\nReturns:\n    bool: The value of the \'USE_X_SENDFILE\' configuration option.\n\nRaises:\n    DeprecationWarning: If the \'use_x_sendfile\' method is called.\n""""""'
False, '""""""\nDeprecates the use of `use_x_sendfile` method and replaces it with using the `USE_X_SENDFILE` configuration option.\n\n### Parameters\n\n- **value** (`bool`): A boolean indicating whether to enable or disable xSendFile functionality.\n\n### Returns\n\n- None\n""""""\n \nimport warnings\n\nwarnings.warn(\n    ""\'use_x_sendfile\' is deprecated and will be removed in Flask 2.3. Use""\n    "" \'USE_X_SENDFILE\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\n\nself.config[""USE_X_SENDFILE""] = value'
True, '""""""\nReturns the JSON encoder class for this application.\n\nThis method is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'.\nThe `DeprecationWarning` will be raised when calling this function.\n \nArgs:\n    None\n \nReturns:\n    t.Type[json.JSONEncoder]: The JSON encoder class.\n""""""'
True, '""""""\nDeprecation Warning: `json_encoder` is deprecated and will be removed in Flask 2.3.\nCustomize `json_provider_class` or `json` instead.\n\nArgs:\n    value (t.Type[json.JSONEncoder]): The new JSON encoder class to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the JSON decoder class.\n\nThis function returns the JSON decoder class used by the application. It is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'. \n\nParameters:\n    None\n\nReturns:\n    t.Type[json.JSONDecoder]: The JSON decoder class.\n\nRaises:\n    DeprecationWarning: If \'app.json_decoder\' is called, it will raise a deprecation warning.\n""""""'
True, '""""""\nDecodes JSON data using the provided decoder.\n\nThis function is deprecated in Flask 2.3 and will be removed.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Type[json.JSONDecoder]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
False, 'def __init__(\n    self,\n    import_name: str,\n    static_url_path: t.Optional[str] = None,\n    static_folder: t.Optional[t.Union[str, os.PathLike]] = ""static"",\n    static_host: t.Optional[str] = None,\n    host_matching: bool = False,\n    subdomain_matching: bool = False,\n    template_folder: t.Optional[t.Union[str, os.PathLike]] = ""templates"",\n    instance_path: t.Optional[str] = None,\n    instance_relative_config: bool = False,\n    root_path: t.Optional[str] = None,\n):\n    """"""\n    Initializes a new Flask application.\n\n    This method is called when creating a new Flask application. It sets up the\n    basic configuration and initializes the internal state of the application.\n\n    :param import_name: The name of the module to import.\n    :param static_url_path: The URL path for serving static files.\n    :param static_folder: The folder where static files are stored.\n    :param static_host: The host for serving static files.\n    :param host_matching: Whether to match hosts in routing.\n    :param subdomain_matching: Whether to match subdomains in routing.\n    :param template_folder: The folder where templates are stored.\n    :param instance_path: The path to the instance folder. If not provided, it\n        will be automatically determined.\n    :param instance_relative_config: Whether to load configuration from files\n        relative to the instance folder.\n    :param root_path: The root path of the application.\n\n    .. versionadded:: 0.8\n\n    .. deprecated:: 2.2\n        Will be removed in Flask 2.3. Run setup code when creating the\n        application instead.\n    """"""\n\n    super().__init__(\n        import_name=import_name,\n        static_folder=static_folder,\n        static_url_path=static_url_path,\n        template_folder=template_folder,\n        root_path=root_path,\n    )\n\n    if instance_path is None:\n        instance_path = self.auto_find_instance_path()\n    elif not os.path.isabs(instance_path):\n        raise ValueError(\n            ""If an instance path is provided it must be absolute.""\n            "" A relative path was given instead.""\n        )\n\n    #: Holds the path to the instance folder.\n    #: \n    #: .. versionadded:: 0.8\n    self.instance_path = instance_path\n\n    #: The configuration dictionary as :class:`Config`.  This behaves\n    #: exactly like a regular dictionary but supports additional methods\n    #: to load a config from files.\n    #: \n    #: .. versionadded:: 0.8\n    self.config = self.make_config(instance_relative_config)\n\n    #: An instance of :attr:`aborter_class` created by\n    #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n    #: to raise HTTP errors, and can be called directly as well.\n    #: \n    #: .. versionadded:: 2.2\n    #:     Moved from ``flask.abort``, which calls this object.\n    self.aborter = self.make_aborter()\n\n    self.json: JSONProvider = self.json_provider_class(self)\n    """"""\n    Provides access to JSON methods.\n\n    Functions in ``flask.json`` will call methods on this provider when the application context is active. Used for handling JSON requests and responses.\n\n    An instance of :attr:`json_provider_class`. Can be customized by changing that attribute on a subclass, or by assigning to this attribute afterwards.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n    uses Python\'s built-in :mod:`json` library. A different provider\n    can use a different JSON library.\n\n    .. versionadded:: 2.2\n    """"""\n\n    #: A list of functions that are called by\n    #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n    #: :exc:`~werkzeug.routing.BuildError`. Each function is called with ``error``, ``endpoint`` and ``values``. If a function returns ``None`` or raises a ``BuildError``, it is skipped.\n    #: Otherwise, its return value is returned by ``url_for``.\n    #: \n    #: .. versionadded:: 0.9\n    self.url_build_error_handlers: t.List[\n        t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n    ] = []\n\n    #: A list of functions that will be called at the beginning of the\n    #: first request to this instance. To register a function, use the\n    #: :meth:`before_first_request` decorator.\n    #: \n    #: .. deprecated:: 2.2\n    #:     Will be removed in Flask 2.3. Run setup code when creating the application instead.\n    #: \n    #: .. versionadded:: 0.8\n    self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []\n\n    #: A list of functions that are called when the application context\n    #: is destroyed.  Since the application context is also torn down\n    #: if the request ends this is the place to store code that disconnects\n    #: from databases.\n    #: \n    #: .. versionadded:: 0.9\n    self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []\n\n    #: A list of shell context processor functions that should be run\n    #: when a shell context is created.\n    #: \n    #: .. versionadded:: 0.11\n    self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []\n\n    #: Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in.\n    #: Blueprints can be registered multiple times, this dict does not track how often they were attached.\n    #: \n    #: .. versionadded:: 0.7\n    self.blueprints: t.Dict[str, ""Blueprint""] = {}\n\n    #: a place where extensions can store application specific state.  For example this is where an extension could store database engines and similar things.\n    #: \n    #: The key must match the name of the extension module. For example in case of a ""Flask-Foo"" extension in `flask_foo`, the key would be `\'foo\'`.\n    #: \n    #: .. versionadded:: 0.7\n    self.extensions: dict = {}\n\n    #: The :class:`~werkzeug.routing.Map` for this instance.  You can use this to change the routing converters after the class was created but before any routes are connected.  Example::\n    #: \n    #:    from werkzeug.routing import BaseConverter\n    #: \n    #:    class ListConverter(BaseConverter):\n    #:        def to_python(self, value):\n    #:            return value.split(\',\')\n    #:        def to_url(self, values):\n    #:            return \',\'.join(super(ListConverter, self).to_url(value)\n    #:                            for value in values)\n    #:\n    #:    app = Flask(__name__)\n    #:    app.url_map.converters[\'list\'] = ListConverter\n    self.url_map = self.url_map_class()\n\n    self.url_map.host_matching = host_matching\n    self.subdomain_matching = subdomain_matching\n\n    # tracks internally if the application already handled at least one request.\n    self._got_first_request = False\n    self._before_request_lock = Lock()\n\n    # Add a static route using the provided static_url_path, static_host,\n    # and static_folder if there is a configured static_folder.\n    # Note we do this without checking if static_folder exists.\n    # For one, it might be created while the server is running (e.g. during\n    # development). Also, Google App Engine stores static files somewhere\n    if self.has_static_folder:\n        assert (\n            bool(static_host) == host_matching\n        ), ""Invalid static_host/host_matching combination""\n        # Use a weakref to avoid creating a reference cycle between the app\n        # and the view function (see #3761).\n        self_ref = weakref.ref(self)\n        self.add_url_rule(\n            f""{self.static_url_path}/<path:filename>"",\n            endpoint=""static"",\n            host=static_host,\n            view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n        )\n\n    # Set the name of the Click group in case someone wants to add\n    # the app\'s commands to another CLI tool.\n    self.cli.name = self.name'
True, '""""""\nPropagates exceptions to the application\'s context.\n\nThis function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\nIf it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether exceptions should be propagated to the application\'s context.\n""""""'
False, 'def make_config(\n    """"""\n    Creates a configuration object for the application.\n\n    Args:\n        instance_relative (bool): If True, uses the instance\'s path as the root path.\n            Defaults to False.\n\n    Returns:\n        Config: The created configuration object.\n    """"""\n    root_path = self.root_path\n    if instance_relative:\n        root_path = self.instance_path\n    defaults = dict(self.default_config)\n    defaults[""ENV""] = os.environ.get(""FLASK_ENV"") or ""production""\n    defaults[""DEBUG""] = get_debug_flag()\n    return self.config_class(root_path, defaults)'
True, '""""""\nReturns the value of `TEMPLATES_AUTO_RELOAD` from the application configuration.\n\nIf `TEMPLATES_AUTO_RELOAD` is set, its value is returned. Otherwise, the value of `debug` is used as a fallback.\n\nDeprecated since Flask 2.3 in favor of using `TEMPLATES_AUTO_RELOAD` in `app.config`.\n\nArgs:\n    None\n\nReturns:\n    bool: The value of `TEMPLATES_AUTO_RELOAD` or `debug` if not set.\n""""""'
False, '""""""\nDeprecation Notice:\n\n    The `templates_auto_reload` method is deprecated and will be removed in Flask 2.3.\n    Use the \'TEMPLATES_AUTO_RELOAD\' configuration option instead.\n\n    Args:\n        value (bool): Whether to enable or disable template auto-reload.\n\n    Returns:\n        None\n""""""\ndef templates_auto_reload(self, value: bool) -> None:\nimport warnings\n\nwarnings.warn(\n    ""\'templates_auto_reload\' is deprecated and will be removed in Flask 2.3.""\n    "" Use \'TEMPLATES_AUTO_RELOAD\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\nself.config[""TEMPLATES_AUTO_RELOAD""] = value'
True, '""""""\nReturns the environment variable as a string.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3.\nUse `app.debug` instead.\n\nArgs:\n    None\n\nReturns:\n    str: The environment variable value.\n\nRaises:\n    DeprecationWarning: If the \'app.env\' method is called.\n""""""'
True, '""""""\nDeprecation Warning: `env` method is deprecated and will be removed in Flask 2.3.\nUse `debug` attribute instead.\n\nArgs:\n    value (str): The environment variable to set.\n\nReturns:\n    None\n""""""'
False, '```\nRun the Flask Development Server.\n\n### Parameters\n\n- `host`: The host IP address or hostname to bind to (default: None)\n- `port`: The port number to use for the server (default: None)\n- `debug`: Whether to enable debug mode (default: None, will override other sources)\n- `load_dotenv`: Whether to load environment variables from a .env file (default: True)\n- `options`: Additional options for the server (default: {})\n\n### Returns\n\nNone. This function runs the Flask development server and does not return any value.\n\n### Notes\n\nThis function is used to run the Flask development server. It takes several parameters, including host, port, debug mode, and environment variables from a .env file. The `debug` parameter can override other sources of debug information. If no host or port are provided, it will use the default values. The `options` dictionary can be used to customize the behavior of the server.\n\n### Example Usage\n\n```python\napp = Flask(__name__)\napp.run(host=""0.0.0.0"", port=5000)\n```\n\nThis example runs the Flask development server on host ""0.0.0.0"" and port 5000.'
True, '""""""\nDeprecation Warning: before_first_request function is deprecated and will be removed in Flask 2.3.\n \n   To avoid deprecation warnings, run setup code while creating the application instead.\n\n   Parameters:\n       f (T_before_first_request): The function to be executed before the first request.\n\n   Returns:\n       T_before_first_request: The input function for appending to self.before_first_request_funcs.\n\n   Note:\n       This function is deprecated and should not be used in new applications. Instead, run setup code while creating the application.\n""""""'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    # Run before_first_request functions if this is the thread\'s first request.\n    # Inlined to avoid a method call on subsequent requests.\n    # This is deprecated, will be removed in Flask 2.3.\n    if not self._got_first_request:\n        with self._before_request_lock:\n            if not self._got_first_request:\n                for func in self.before_first_request_funcs:\n                    self.ensure_sync(func)()\n\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nReturns the JSON encoder class, deprecation warning if applicable.\n\nThis function is deprecated and will be removed in Flask 2.3. It\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    None\n\nReturns:\n    t.Union[t.Type[json.JSONEncoder], None]: The JSON encoder class or None.\n""""""'
True, '""""""\nDeprecation Warning: json_encoder function is deprecated and will be removed in Flask 2.3.\n \nTo customize the JSON encoding behavior, use either \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    value (Union[Type[JSONEncoder], None]): The JSON encoder class to use. Defaults to None.\n\nReturns:\n    None\n""""""'
False, '""""""\nDecodes JSON data.\n\nThis function returns the instance of `JSONDecoder` class, which is used to decode JSON data.\nHowever, due to deprecation, it\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nReturns:\n    t.Union[t.Type[json.JSONDecoder], None]: The instance of `JSONDecoder` class or None if not available.'
True, '""""""\nDecodes JSON values.\n\nThis function is deprecated and will be removed in Flask 2.3.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Union[t.Type[json.JSONDecoder], None]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `before_app_first_request` function is deprecated and will be removed in Flask 2.3.\nUse the `record_once` method instead to run setup code when registering a blueprint.\n\nParameters:\nf (T_before_first_request): The function to register for before first request.\n\nReturns:\nT_before_first_request: The registered function.\n\nRaises:\nDeprecationWarning: If the function is deprecated and should be replaced with `record_once`.\n""""""'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = flask.Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of `flask.get_flashed_messages` with category filtering.\n\nThis function tests that the `get_flashed_messages` method returns a list of\nflashed messages, filtered by categories. The test case checks that the\nfiltered messages match the expected output.\n\nParameters:\n    None\n\nReturns:\n    A string indicating whether the test passed or failed.\n""""""\ndef test_filters():'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
True, '""""""\nRenders the first request to an application.\n\nThis function simulates a client making a GET request to the root URL of the application.\nIt asserts that the `debug` attribute is set to True, and that the response from the server matches the expected value.\nAdditionally, it tests that attempting to add a new route after the first request raises an AssertionError with a specific message.\n\nArgs:\n    app (Flask application): The Flask application instance being tested.\n    client (requests.Session): A requests session object used to simulate the client\'s request.\n\nReturns:\n    None\n""""""'
True, '""""""\nRequest Functions for Application Testing\n\nThis function tests the application\'s behavior when making requests before and after the first request.\n\nParameters:\napp (object): The application object to be tested.\nclient (object): The client object used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nAdds 42 to the \'got\' list.\n\nThis function is not intended for external use and should only be accessed internally within the application.\n""""""'
True, '""""""\nConcurrently tests the application\'s routing functionality by making a request to the root URL while another thread is asserting that a value was appended to the `got` list.\n\nThis function uses pytest\'s deprecated_call context manager to ensure that the `foo` function, which appends a value to the `got` list, is called before the first request is made. It then creates a new thread that runs the `get_and_assert` function in parallel with the main thread.\n\nThe `get_and_assert` function makes a GET request to the root URL and asserts that the value appended to the `got` list matches the expected value. The main thread waits for the thread to finish before asserting that the application\'s `got_first_request` attribute is set to True.\n\nThis test ensures that the application\'s routing functionality works correctly even when multiple threads are making requests concurrently.\n""""""'
True, '""""""\nReturns the result of appending 42 to the \'got\' list after a 200ms delay.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    None\n\nExample:\n    >>> get_and_asse()\n""""""'
False, '""""""\nTests the functionality of the get method on the client object.\n\nThis test case checks if the get method returns a list containing the expected value when called with the root URL (""/"").\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.\n""""""\n\nclient.get(""/"")\nassert got == [42]\n\n""""""\nTests the functionality of threading in Python.\n\nThis test case checks if the Thread class can be instantiated correctly and if it can target a specific function.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the thread is not created successfully or if it does not target the expected function.\n""""""\n\nt = Thread(target=  # <--- Missing keyword \'self\''
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""'
True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""'
False, 'def got_first_request(self) -> bool:\n    """"""\n    Propagates exceptions to the application\'s context.\n\n    This function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\n    If it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\n    Deprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\n    Args:\n        None\n\n    Returns:\n        bool: Whether exceptions should be propagated to the application\'s context.\n    """"""\n    import warnings\n    warnings.warn(\n        ""\'got_first_request\' is deprecated and will be removed in Flask 2.4."",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self._got_first_request'
False, '```python\ndef run(\n    host: t.Optional[str] = None,\n    port: t.Optional[int] = None,\n    debug: t.Optional[bool] = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This method is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If these\n    parameters are not provided, they will be set based on the configuration\n    of the application.\n\n    Args:\n        host: The hostname or IP address to bind to. Defaults to None.\n        port: The port number to use. Defaults to None.\n        debug: A boolean indicating whether to enable debug mode. Defaults to None.\n        load_dotenv: A boolean indicating whether to load environment variables\n            from a .env file. Defaults to True.\n        **options: Additional keyword arguments to pass to the `run_simple`\n            function.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid port number is provided.\n    """"""\n```'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    This method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\n    Parameters\n    self (object): The instance of the class that this method belongs to.\n\n    Returns\n    Response: The response from the dispatching process.\n    """"""\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nInitialize a new instance of the class.\n\nParameters:\n    name (str): The name of the application or module.\n    import_name (str): The import name of the application or module.\n    static_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the static folder. Defaults to None.\n    static_url_path (t.Optional[str], optional): The URL path for static files. Defaults to None.\n    template_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the template folder. Defaults to None.\n    url_prefix (t.Optional[str], optional): The prefix for URLs. Defaults to None.\n    subdomain (t.Optional[str], optional): The subdomain for URLs. Defaults to None.\n    url_defaults (t.Optional[dict], optional): Default values for URL parameters. Defaults to None.\n    root_path (t.Optional[str], optional): The root path of the application or module. Defaults to None.\n    cli_group (t.Optional[str], optional): The CLI group name. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the application or module.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for URLs.\n    deferred_functions (list): A list of deferred functions.\n    url_values_defaults (dict): Default values for URL parameters.\n    cli_group (str): The CLI group name.\n    _blueprints (list): A list of blueprints and their configurations.\n\nNote:\nThis function initializes a new instance of the class, setting up various attributes such as `name`, `url_prefix`, `subdomain`, and more. It also raises a ValueError if the \'name\' parameter is empty or contains a dot \'.\' character.\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of the `get_flashed_messages` function from Flask, \nspecifically when using category filters.\n\nThis test case checks that the function returns a list of messages with their respective categories,\nand that it correctly handles the \'with_categories\' parameter.\n\nParameters:\n- None\n\nReturns:\n- A string indicating whether the test passed or failed.\n""""""\ndef test_filters():\n    messages = flask.get_flashed_messages(\n        category_filter=[""message"", ""warning""], with_categories=True\n    )\n    assert list(messages) == [\n        (""message"", ""Hello World""),\n        (""warning"", Markup(""<em>Testing</em>"")),\n    ]\n    return """"'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns the name of the session cookie.\n\nThis method is deprecated and will be removed in Flask 2.3. Instead, use\n`app.config[\'SESSION_COOKIE_NAME\']`.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the session cookie.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `session_cookie_name` method is deprecated and will be removed in Flask 2.3.\nUse the \'SESSION_COOKIE_NAME\' configuration option in \'app.config\' instead.\n\nParameters:\nvalue (str): The new session cookie name.\n\nReturns:\nNone\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nReturns:\n    Optional[timedelta]: The maximum age for sending files, or None if not set.\n\nRaises:\n    DeprecationWarning: If the deprecated method is called.\n\nNote:\nThis function is only available for backwards compatibility and should not be used in new code.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nParameters:\n    value (Union[int, timedelta, None]): The maximum age of sent files in seconds.\n        If int, the value is used directly as a number of seconds.\n        If timedelta, the value is converted to seconds.\n        If None, no default is set.\n\nReturns:\n    None\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `use_x_sendfile` method is deprecated and will be removed in Flask 2.3.\nInstead, use the \'USE_X_SENDFILE\' configuration option in the application\'s\nconfiguration dictionary.\n\nReturns:\n    bool: The value of the \'USE_X_SENDFILE\' configuration option.\n\nRaises:\n    DeprecationWarning: If the \'use_x_sendfile\' method is called.\n""""""'
False, '""""""\nDeprecates the use of `use_x_sendfile` method and replaces it with using the `USE_X_SENDFILE` configuration option.\n\n### Parameters\n\n- **value** (`bool`): A boolean indicating whether to enable or disable xSendFile functionality.\n\n### Returns\n\n- None\n""""""\n \nimport warnings\n\nwarnings.warn(\n    ""\'use_x_sendfile\' is deprecated and will be removed in Flask 2.3. Use""\n    "" \'USE_X_SENDFILE\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\n\nself.config[""USE_X_SENDFILE""] = value'
True, '""""""\nReturns the JSON encoder class for this application.\n\nThis method is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'.\nThe `DeprecationWarning` will be raised when calling this function.\n \nArgs:\n    None\n \nReturns:\n    t.Type[json.JSONEncoder]: The JSON encoder class.\n""""""'
True, '""""""\nDeprecation Warning: `json_encoder` is deprecated and will be removed in Flask 2.3.\nCustomize `json_provider_class` or `json` instead.\n\nArgs:\n    value (t.Type[json.JSONEncoder]): The new JSON encoder class to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the JSON decoder class.\n\nThis function returns the JSON decoder class used by the application. It is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'. \n\nParameters:\n    None\n\nReturns:\n    t.Type[json.JSONDecoder]: The JSON decoder class.\n\nRaises:\n    DeprecationWarning: If \'app.json_decoder\' is called, it will raise a deprecation warning.\n""""""'
True, '""""""\nDecodes JSON data using the provided decoder.\n\nThis function is deprecated in Flask 2.3 and will be removed.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Type[json.JSONDecoder]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
False, 'def __init__(\n    self,\n    import_name: str,\n    static_url_path: t.Optional[str] = None,\n    static_folder: t.Optional[t.Union[str, os.PathLike]] = ""static"",\n    static_host: t.Optional[str] = None,\n    host_matching: bool = False,\n    subdomain_matching: bool = False,\n    template_folder: t.Optional[t.Union[str, os.PathLike]] = ""templates"",\n    instance_path: t.Optional[str] = None,\n    instance_relative_config: bool = False,\n    root_path: t.Optional[str] = None,\n):\n    """"""\n    Initializes a new Flask application.\n\n    This method is called when creating a new Flask application. It sets up the\n    basic configuration and initializes the internal state of the application.\n\n    :param import_name: The name of the module to import.\n    :param static_url_path: The URL path for serving static files.\n    :param static_folder: The folder where static files are stored.\n    :param static_host: The host for serving static files.\n    :param host_matching: Whether to match hosts in routing.\n    :param subdomain_matching: Whether to match subdomains in routing.\n    :param template_folder: The folder where templates are stored.\n    :param instance_path: The path to the instance folder. If not provided, it\n        will be automatically determined.\n    :param instance_relative_config: Whether to load configuration from files\n        relative to the instance folder.\n    :param root_path: The root path of the application.\n\n    .. versionadded:: 0.8\n\n    .. deprecated:: 2.2\n        Will be removed in Flask 2.3. Run setup code when creating the\n        application instead.\n    """"""\n\n    super().__init__(\n        import_name=import_name,\n        static_folder=static_folder,\n        static_url_path=static_url_path,\n        template_folder=template_folder,\n        root_path=root_path,\n    )\n\n    if instance_path is None:\n        instance_path = self.auto_find_instance_path()\n    elif not os.path.isabs(instance_path):\n        raise ValueError(\n            ""If an instance path is provided it must be absolute.""\n            "" A relative path was given instead.""\n        )\n\n    #: Holds the path to the instance folder.\n    #: \n    #: .. versionadded:: 0.8\n    self.instance_path = instance_path\n\n    #: The configuration dictionary as :class:`Config`.  This behaves\n    #: exactly like a regular dictionary but supports additional methods\n    #: to load a config from files.\n    #: \n    #: .. versionadded:: 0.8\n    self.config = self.make_config(instance_relative_config)\n\n    #: An instance of :attr:`aborter_class` created by\n    #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n    #: to raise HTTP errors, and can be called directly as well.\n    #: \n    #: .. versionadded:: 2.2\n    #:     Moved from ``flask.abort``, which calls this object.\n    self.aborter = self.make_aborter()\n\n    self.json: JSONProvider = self.json_provider_class(self)\n    """"""\n    Provides access to JSON methods.\n\n    Functions in ``flask.json`` will call methods on this provider when the application context is active. Used for handling JSON requests and responses.\n\n    An instance of :attr:`json_provider_class`. Can be customized by changing that attribute on a subclass, or by assigning to this attribute afterwards.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n    uses Python\'s built-in :mod:`json` library. A different provider\n    can use a different JSON library.\n\n    .. versionadded:: 2.2\n    """"""\n\n    #: A list of functions that are called by\n    #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n    #: :exc:`~werkzeug.routing.BuildError`. Each function is called with ``error``, ``endpoint`` and ``values``. If a function returns ``None`` or raises a ``BuildError``, it is skipped.\n    #: Otherwise, its return value is returned by ``url_for``.\n    #: \n    #: .. versionadded:: 0.9\n    self.url_build_error_handlers: t.List[\n        t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n    ] = []\n\n    #: A list of functions that will be called at the beginning of the\n    #: first request to this instance. To register a function, use the\n    #: :meth:`before_first_request` decorator.\n    #: \n    #: .. deprecated:: 2.2\n    #:     Will be removed in Flask 2.3. Run setup code when creating the application instead.\n    #: \n    #: .. versionadded:: 0.8\n    self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []\n\n    #: A list of functions that are called when the application context\n    #: is destroyed.  Since the application context is also torn down\n    #: if the request ends this is the place to store code that disconnects\n    #: from databases.\n    #: \n    #: .. versionadded:: 0.9\n    self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []\n\n    #: A list of shell context processor functions that should be run\n    #: when a shell context is created.\n    #: \n    #: .. versionadded:: 0.11\n    self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []\n\n    #: Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in.\n    #: Blueprints can be registered multiple times, this dict does not track how often they were attached.\n    #: \n    #: .. versionadded:: 0.7\n    self.blueprints: t.Dict[str, ""Blueprint""] = {}\n\n    #: a place where extensions can store application specific state.  For example this is where an extension could store database engines and similar things.\n    #: \n    #: The key must match the name of the extension module. For example in case of a ""Flask-Foo"" extension in `flask_foo`, the key would be `\'foo\'`.\n    #: \n    #: .. versionadded:: 0.7\n    self.extensions: dict = {}\n\n    #: The :class:`~werkzeug.routing.Map` for this instance.  You can use this to change the routing converters after the class was created but before any routes are connected.  Example::\n    #: \n    #:    from werkzeug.routing import BaseConverter\n    #: \n    #:    class ListConverter(BaseConverter):\n    #:        def to_python(self, value):\n    #:            return value.split(\',\')\n    #:        def to_url(self, values):\n    #:            return \',\'.join(super(ListConverter, self).to_url(value)\n    #:                            for value in values)\n    #:\n    #:    app = Flask(__name__)\n    #:    app.url_map.converters[\'list\'] = ListConverter\n    self.url_map = self.url_map_class()\n\n    self.url_map.host_matching = host_matching\n    self.subdomain_matching = subdomain_matching\n\n    # tracks internally if the application already handled at least one request.\n    self._got_first_request = False\n    self._before_request_lock = Lock()\n\n    # Add a static route using the provided static_url_path, static_host,\n    # and static_folder if there is a configured static_folder.\n    # Note we do this without checking if static_folder exists.\n    # For one, it might be created while the server is running (e.g. during\n    # development). Also, Google App Engine stores static files somewhere\n    if self.has_static_folder:\n        assert (\n            bool(static_host) == host_matching\n        ), ""Invalid static_host/host_matching combination""\n        # Use a weakref to avoid creating a reference cycle between the app\n        # and the view function (see #3761).\n        self_ref = weakref.ref(self)\n        self.add_url_rule(\n            f""{self.static_url_path}/<path:filename>"",\n            endpoint=""static"",\n            host=static_host,\n            view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n        )\n\n    # Set the name of the Click group in case someone wants to add\n    # the app\'s commands to another CLI tool.\n    self.cli.name = self.name'
True, '""""""\nPropagates exceptions to the application\'s context.\n\nThis function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\nIf it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether exceptions should be propagated to the application\'s context.\n""""""'
False, 'def make_config(\n    """"""\n    Creates a configuration object for the application.\n\n    Args:\n        instance_relative (bool): If True, uses the instance\'s path as the root path.\n            Defaults to False.\n\n    Returns:\n        Config: The created configuration object.\n    """"""\n    root_path = self.root_path\n    if instance_relative:\n        root_path = self.instance_path\n    defaults = dict(self.default_config)\n    defaults[""ENV""] = os.environ.get(""FLASK_ENV"") or ""production""\n    defaults[""DEBUG""] = get_debug_flag()\n    return self.config_class(root_path, defaults)'
True, '""""""\nReturns the value of `TEMPLATES_AUTO_RELOAD` from the application configuration.\n\nIf `TEMPLATES_AUTO_RELOAD` is set, its value is returned. Otherwise, the value of `debug` is used as a fallback.\n\nDeprecated since Flask 2.3 in favor of using `TEMPLATES_AUTO_RELOAD` in `app.config`.\n\nArgs:\n    None\n\nReturns:\n    bool: The value of `TEMPLATES_AUTO_RELOAD` or `debug` if not set.\n""""""'
False, '""""""\nDeprecation Notice:\n\n    The `templates_auto_reload` method is deprecated and will be removed in Flask 2.3.\n    Use the \'TEMPLATES_AUTO_RELOAD\' configuration option instead.\n\n    Args:\n        value (bool): Whether to enable or disable template auto-reload.\n\n    Returns:\n        None\n""""""\ndef templates_auto_reload(self, value: bool) -> None:\nimport warnings\n\nwarnings.warn(\n    ""\'templates_auto_reload\' is deprecated and will be removed in Flask 2.3.""\n    "" Use \'TEMPLATES_AUTO_RELOAD\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\nself.config[""TEMPLATES_AUTO_RELOAD""] = value'
True, '""""""\nReturns the environment variable as a string.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3.\nUse `app.debug` instead.\n\nArgs:\n    None\n\nReturns:\n    str: The environment variable value.\n\nRaises:\n    DeprecationWarning: If the \'app.env\' method is called.\n""""""'
True, '""""""\nDeprecation Warning: `env` method is deprecated and will be removed in Flask 2.3.\nUse `debug` attribute instead.\n\nArgs:\n    value (str): The environment variable to set.\n\nReturns:\n    None\n""""""'
False, '```\nRun the Flask Development Server.\n\n### Parameters\n\n- `host`: The host IP address or hostname to bind to (default: None)\n- `port`: The port number to use for the server (default: None)\n- `debug`: Whether to enable debug mode (default: None, will override other sources)\n- `load_dotenv`: Whether to load environment variables from a .env file (default: True)\n- `options`: Additional options for the server (default: {})\n\n### Returns\n\nNone. This function runs the Flask development server and does not return any value.\n\n### Notes\n\nThis function is used to run the Flask development server. It takes several parameters, including host, port, debug mode, and environment variables from a .env file. The `debug` parameter can override other sources of debug information. If no host or port are provided, it will use the default values. The `options` dictionary can be used to customize the behavior of the server.\n\n### Example Usage\n\n```python\napp = Flask(__name__)\napp.run(host=""0.0.0.0"", port=5000)\n```\n\nThis example runs the Flask development server on host ""0.0.0.0"" and port 5000.'
True, '""""""\nDeprecation Warning: before_first_request function is deprecated and will be removed in Flask 2.3.\n \n   To avoid deprecation warnings, run setup code while creating the application instead.\n\n   Parameters:\n       f (T_before_first_request): The function to be executed before the first request.\n\n   Returns:\n       T_before_first_request: The input function for appending to self.before_first_request_funcs.\n\n   Note:\n       This function is deprecated and should not be used in new applications. Instead, run setup code while creating the application.\n""""""'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    # Run before_first_request functions if this is the thread\'s first request.\n    # Inlined to avoid a method call on subsequent requests.\n    # This is deprecated, will be removed in Flask 2.3.\n    if not self._got_first_request:\n        with self._before_request_lock:\n            if not self._got_first_request:\n                for func in self.before_first_request_funcs:\n                    self.ensure_sync(func)()\n\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nReturns the JSON encoder class, deprecation warning if applicable.\n\nThis function is deprecated and will be removed in Flask 2.3. It\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    None\n\nReturns:\n    t.Union[t.Type[json.JSONEncoder], None]: The JSON encoder class or None.\n""""""'
True, '""""""\nDeprecation Warning: json_encoder function is deprecated and will be removed in Flask 2.3.\n \nTo customize the JSON encoding behavior, use either \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    value (Union[Type[JSONEncoder], None]): The JSON encoder class to use. Defaults to None.\n\nReturns:\n    None\n""""""'
False, '""""""\nDecodes JSON data.\n\nThis function returns the instance of `JSONDecoder` class, which is used to decode JSON data.\nHowever, due to deprecation, it\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nReturns:\n    t.Union[t.Type[json.JSONDecoder], None]: The instance of `JSONDecoder` class or None if not available.'
True, '""""""\nDecodes JSON values.\n\nThis function is deprecated and will be removed in Flask 2.3.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Union[t.Type[json.JSONDecoder], None]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `before_app_first_request` function is deprecated and will be removed in Flask 2.3.\nUse the `record_once` method instead to run setup code when registering a blueprint.\n\nParameters:\nf (T_before_first_request): The function to register for before first request.\n\nReturns:\nT_before_first_request: The registered function.\n\nRaises:\nDeprecationWarning: If the function is deprecated and should be replaced with `record_once`.\n""""""'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = flask.Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of `flask.get_flashed_messages` with category filtering.\n\nThis function tests that the `get_flashed_messages` method returns a list of\nflashed messages, filtered by categories. The test case checks that the\nfiltered messages match the expected output.\n\nParameters:\n    None\n\nReturns:\n    A string indicating whether the test passed or failed.\n""""""\ndef test_filters():'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
True, '""""""\nRenders the first request to an application.\n\nThis function simulates a client making a GET request to the root URL of the application.\nIt asserts that the `debug` attribute is set to True, and that the response from the server matches the expected value.\nAdditionally, it tests that attempting to add a new route after the first request raises an AssertionError with a specific message.\n\nArgs:\n    app (Flask application): The Flask application instance being tested.\n    client (requests.Session): A requests session object used to simulate the client\'s request.\n\nReturns:\n    None\n""""""'
True, '""""""\nRequest Functions for Application Testing\n\nThis function tests the application\'s behavior when making requests before and after the first request.\n\nParameters:\napp (object): The application object to be tested.\nclient (object): The client object used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nAdds 42 to the \'got\' list.\n\nThis function is not intended for external use and should only be accessed internally within the application.\n""""""'
True, '""""""\nConcurrently tests the application\'s routing functionality by making a request to the root URL while another thread is asserting that a value was appended to the `got` list.\n\nThis function uses pytest\'s deprecated_call context manager to ensure that the `foo` function, which appends a value to the `got` list, is called before the first request is made. It then creates a new thread that runs the `get_and_assert` function in parallel with the main thread.\n\nThe `get_and_assert` function makes a GET request to the root URL and asserts that the value appended to the `got` list matches the expected value. The main thread waits for the thread to finish before asserting that the application\'s `got_first_request` attribute is set to True.\n\nThis test ensures that the application\'s routing functionality works correctly even when multiple threads are making requests concurrently.\n""""""'
True, '""""""\nReturns the result of appending 42 to the \'got\' list after a 200ms delay.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    None\n\nExample:\n    >>> get_and_asse()\n""""""'
False, '""""""\nTests the functionality of the get method on the client object.\n\nThis test case checks if the get method returns a list containing the expected value when called with the root URL (""/"").\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.\n""""""\n\nclient.get(""/"")\nassert got == [42]\n\n""""""\nTests the functionality of threading in Python.\n\nThis test case checks if the Thread class can be instantiated correctly and if it can target a specific function.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the thread is not created successfully or if it does not target the expected function.\n""""""\n\nt = Thread(target=  # <--- Missing keyword \'self\''
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""'
True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""'
False, 'def got_first_request(self) -> bool:\n""""""\nPropagates exceptions to the application\'s context.\n\nThis function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\nIf it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether exceptions should be propagated to the application\'s context.\n""""""\nimport warnings\nwarnings.warn(\n    ""\'got_first_request\' is deprecated and will be removed in Flask 2.4."",\n    DeprecationWarning,\n    stacklevel=2,\n)\nreturn self._got_first_request'
False, '```python\ndef run(\n    host: t.Optional[str] = None,\n    port: t.Optional[int] = None,\n    debug: t.Optional[bool] = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This method is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If these\n    parameters are not provided, they will be set based on the configuration\n    of the application.\n\n    Args:\n        host: The hostname or IP address to bind to. Defaults to None.\n        port: The port number to use. Defaults to None.\n        debug: A boolean indicating whether to enable debug mode. Defaults to None.\n        load_dotenv: A boolean indicating whether to load environment variables\n            from a .env file. Defaults to True.\n        **options: Additional keyword arguments to pass to the `run_simple`\n            function.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid port number is provided.\n    """"""\n```'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    This method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\n    Parameters\n    self (object): The instance of the class that this method belongs to.\n\n    Returns\n    Response: The response from the dispatching process.\n    """"""\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nInitialize a new instance of the class.\n\nParameters:\n    name (str): The name of the application or module.\n    import_name (str): The import name of the application or module.\n    static_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the static folder. Defaults to None.\n    static_url_path (t.Optional[str], optional): The URL path for static files. Defaults to None.\n    template_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the template folder. Defaults to None.\n    url_prefix (t.Optional[str], optional): The prefix for URLs. Defaults to None.\n    subdomain (t.Optional[str], optional): The subdomain for URLs. Defaults to None.\n    url_defaults (t.Optional[dict], optional): Default values for URL parameters. Defaults to None.\n    root_path (t.Optional[str], optional): The root path of the application or module. Defaults to None.\n    cli_group (t.Optional[str], optional): The CLI group name. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the application or module.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for URLs.\n    deferred_functions (list): A list of deferred functions.\n    url_values_defaults (dict): Default values for URL parameters.\n    cli_group (str): The CLI group name.\n    _blueprints (list): A list of blueprints and their configurations.\n\nNote:\nThis function initializes a new instance of the class, setting up various attributes such as `name`, `url_prefix`, `subdomain`, and more. It also raises a ValueError if the \'name\' parameter is empty or contains a dot \'.\' character.\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of the `get_flashed_messages` function from Flask, \nspecifically when using category filters.\n\nThis test case checks that the function returns a list of messages with their respective categories,\nand that it correctly handles the \'with_categories\' parameter.\n\nParameters:\n- None\n\nReturns:\n- A string indicating whether the test passed or failed.\n""""""\ndef test_filters():\n    messages = flask.get_flashed_messages(\n        category_filter=[""message"", ""warning""], with_categories=True\n    )\n    assert list(messages) == [\n        (""message"", ""Hello World""),\n        (""warning"", Markup(""<em>Testing</em>"")),\n    ]\n    return """"'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
True, '""""""\nChecks if the provided string is a valid IP address.\n\nThis function uses the `socket` module to perform the validation.\nIt supports both IPv4 and IPv6 addresses.\n\nArgs:\n    value (str): The IP address to be validated.\n\nReturns:\n    bool: True if the IP address is valid, False otherwise.\n\nDeprecation Warning: This function is deprecated and will be removed in Flask 2.4.\n""""""'
True, '""""""\nReturns the domain of the session cookie for a given Flask application.\n\nArgs:\n    app (Flask): The Flask application instance.\n\nReturns:\n    Optional[str]: The domain of the session cookie, or None if not set.\n""""""'
True, '""""""\nTests the session path configuration for a Flask application.\n\nThis function tests that the `APPLICATION_ROOT` is correctly set as the\nsession path. It does this by updating the app\'s config, creating an index\nroute with a test session value, and then making a GET request to the root\nURL of the app. The response headers are checked to ensure that the correct\nCookie is being set.\n\nArgs:\n    app (Flask): The Flask application instance.\n    client (requests.Session): A requests session object for making HTTP requests.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the expected Cookie header value is not found in the response.\n""""""'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns the name of the session cookie.\n\nThis method is deprecated and will be removed in Flask 2.3. Instead, use\n`app.config[\'SESSION_COOKIE_NAME\']`.\n\nArgs:\n    None\n\nReturns:\n    str: The name of the session cookie.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `session_cookie_name` method is deprecated and will be removed in Flask 2.3.\nUse the \'SESSION_COOKIE_NAME\' configuration option in \'app.config\' instead.\n\nParameters:\nvalue (str): The new session cookie name.\n\nReturns:\nNone\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nReturns:\n    Optional[timedelta]: The maximum age for sending files, or None if not set.\n\nRaises:\n    DeprecationWarning: If the deprecated method is called.\n\nNote:\nThis function is only available for backwards compatibility and should not be used in new code.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `send_file_max_age_default` method is deprecated and will be removed in Flask 2.3.\nUse \'SEND_FILE_MAX_AGE_DEFAULT\' in \'app.config\' instead.\n\nParameters:\n    value (Union[int, timedelta, None]): The maximum age of sent files in seconds.\n        If int, the value is used directly as a number of seconds.\n        If timedelta, the value is converted to seconds.\n        If None, no default is set.\n\nReturns:\n    None\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `use_x_sendfile` method is deprecated and will be removed in Flask 2.3.\nInstead, use the \'USE_X_SENDFILE\' configuration option in the application\'s\nconfiguration dictionary.\n\nReturns:\n    bool: The value of the \'USE_X_SENDFILE\' configuration option.\n\nRaises:\n    DeprecationWarning: If the \'use_x_sendfile\' method is called.\n""""""'
False, '""""""\nDeprecates the use of `use_x_sendfile` method and replaces it with using the `USE_X_SENDFILE` configuration option.\n\n### Parameters\n\n- **value** (`bool`): A boolean indicating whether to enable or disable xSendFile functionality.\n\n### Returns\n\n- None\n""""""\n \nimport warnings\n\nwarnings.warn(\n    ""\'use_x_sendfile\' is deprecated and will be removed in Flask 2.3. Use""\n    "" \'USE_X_SENDFILE\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\n\nself.config[""USE_X_SENDFILE""] = value'
True, '""""""\nReturns the JSON encoder class for this application.\n\nThis method is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'.\nThe `DeprecationWarning` will be raised when calling this function.\n \nArgs:\n    None\n \nReturns:\n    t.Type[json.JSONEncoder]: The JSON encoder class.\n""""""'
True, '""""""\nDeprecation Warning: `json_encoder` is deprecated and will be removed in Flask 2.3.\nCustomize `json_provider_class` or `json` instead.\n\nArgs:\n    value (t.Type[json.JSONEncoder]): The new JSON encoder class to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the JSON decoder class.\n\nThis function returns the JSON decoder class used by the application. It is deprecated in favor of customizing \'app.json_provider_class\' or \'app.json\'. \n\nParameters:\n    None\n\nReturns:\n    t.Type[json.JSONDecoder]: The JSON decoder class.\n\nRaises:\n    DeprecationWarning: If \'app.json_decoder\' is called, it will raise a deprecation warning.\n""""""'
True, '""""""\nDecodes JSON data using the provided decoder.\n\nThis function is deprecated in Flask 2.3 and will be removed.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Type[json.JSONDecoder]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
False, 'def __init__(\n    self,\n    import_name: str,\n    static_url_path: t.Optional[str] = None,\n    static_folder: t.Optional[t.Union[str, os.PathLike]] = ""static"",\n    static_host: t.Optional[str] = None,\n    host_matching: bool = False,\n    subdomain_matching: bool = False,\n    template_folder: t.Optional[t.Union[str, os.PathLike]] = ""templates"",\n    instance_path: t.Optional[str] = None,\n    instance_relative_config: bool = False,\n    root_path: t.Optional[str] = None,\n):\n    """"""\n    Initializes a new Flask application.\n\n    This method is called when creating a new Flask application. It sets up the\n    basic configuration and initializes the internal state of the application.\n\n    :param import_name: The name of the module to import.\n    :param static_url_path: The URL path for serving static files.\n    :param static_folder: The folder where static files are stored.\n    :param static_host: The host for serving static files.\n    :param host_matching: Whether to match hosts in routing.\n    :param subdomain_matching: Whether to match subdomains in routing.\n    :param template_folder: The folder where templates are stored.\n    :param instance_path: The path to the instance folder. If not provided, it\n        will be automatically determined.\n    :param instance_relative_config: Whether to load configuration from files\n        relative to the instance folder.\n    :param root_path: The root path of the application.\n\n    .. versionadded:: 0.8\n\n    .. deprecated:: 2.2\n        Will be removed in Flask 2.3. Run setup code when creating the\n        application instead.\n    """"""\n\n    super().__init__(\n        import_name=import_name,\n        static_folder=static_folder,\n        static_url_path=static_url_path,\n        template_folder=template_folder,\n        root_path=root_path,\n    )\n\n    if instance_path is None:\n        instance_path = self.auto_find_instance_path()\n    elif not os.path.isabs(instance_path):\n        raise ValueError(\n            ""If an instance path is provided it must be absolute.""\n            "" A relative path was given instead.""\n        )\n\n    #: Holds the path to the instance folder.\n    #: \n    #: .. versionadded:: 0.8\n    self.instance_path = instance_path\n\n    #: The configuration dictionary as :class:`Config`.  This behaves\n    #: exactly like a regular dictionary but supports additional methods\n    #: to load a config from files.\n    #: \n    #: .. versionadded:: 0.8\n    self.config = self.make_config(instance_relative_config)\n\n    #: An instance of :attr:`aborter_class` created by\n    #: :meth:`make_aborter`. This is called by :func:`flask.abort`\n    #: to raise HTTP errors, and can be called directly as well.\n    #: \n    #: .. versionadded:: 2.2\n    #:     Moved from ``flask.abort``, which calls this object.\n    self.aborter = self.make_aborter()\n\n    self.json: JSONProvider = self.json_provider_class(self)\n    """"""\n    Provides access to JSON methods.\n\n    Functions in ``flask.json`` will call methods on this provider when the application context is active. Used for handling JSON requests and responses.\n\n    An instance of :attr:`json_provider_class`. Can be customized by changing that attribute on a subclass, or by assigning to this attribute afterwards.\n\n    The default, :class:`~flask.json.provider.DefaultJSONProvider`,\n    uses Python\'s built-in :mod:`json` library. A different provider\n    can use a different JSON library.\n\n    .. versionadded:: 2.2\n    """"""\n\n    #: A list of functions that are called by\n    #: :meth:`handle_url_build_error` when :meth:`.url_for` raises a\n    #: :exc:`~werkzeug.routing.BuildError`. Each function is called with ``error``, ``endpoint`` and ``values``. If a function returns ``None`` or raises a ``BuildError``, it is skipped.\n    #: Otherwise, its return value is returned by ``url_for``.\n    #: \n    #: .. versionadded:: 0.9\n    self.url_build_error_handlers: t.List[\n        t.Callable[[Exception, str, t.Dict[str, t.Any]], str]\n    ] = []\n\n    #: A list of functions that will be called at the beginning of the\n    #: first request to this instance. To register a function, use the\n    #: :meth:`before_first_request` decorator.\n    #: \n    #: .. deprecated:: 2.2\n    #:     Will be removed in Flask 2.3. Run setup code when creating the application instead.\n    #: \n    #: .. versionadded:: 0.8\n    self.before_first_request_funcs: t.List[ft.BeforeFirstRequestCallable] = []\n\n    #: A list of functions that are called when the application context\n    #: is destroyed.  Since the application context is also torn down\n    #: if the request ends this is the place to store code that disconnects\n    #: from databases.\n    #: \n    #: .. versionadded:: 0.9\n    self.teardown_appcontext_funcs: t.List[ft.TeardownCallable] = []\n\n    #: A list of shell context processor functions that should be run\n    #: when a shell context is created.\n    #: \n    #: .. versionadded:: 0.11\n    self.shell_context_processors: t.List[ft.ShellContextProcessorCallable] = []\n\n    #: Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in.\n    #: Blueprints can be registered multiple times, this dict does not track how often they were attached.\n    #: \n    #: .. versionadded:: 0.7\n    self.blueprints: t.Dict[str, ""Blueprint""] = {}\n\n    #: a place where extensions can store application specific state.  For example this is where an extension could store database engines and similar things.\n    #: \n    #: The key must match the name of the extension module. For example in case of a ""Flask-Foo"" extension in `flask_foo`, the key would be `\'foo\'`.\n    #: \n    #: .. versionadded:: 0.7\n    self.extensions: dict = {}\n\n    #: The :class:`~werkzeug.routing.Map` for this instance.  You can use this to change the routing converters after the class was created but before any routes are connected.  Example::\n    #: \n    #:    from werkzeug.routing import BaseConverter\n    #: \n    #:    class ListConverter(BaseConverter):\n    #:        def to_python(self, value):\n    #:            return value.split(\',\')\n    #:        def to_url(self, values):\n    #:            return \',\'.join(super(ListConverter, self).to_url(value)\n    #:                            for value in values)\n    #:\n    #:    app = Flask(__name__)\n    #:    app.url_map.converters[\'list\'] = ListConverter\n    self.url_map = self.url_map_class()\n\n    self.url_map.host_matching = host_matching\n    self.subdomain_matching = subdomain_matching\n\n    # tracks internally if the application already handled at least one request.\n    self._got_first_request = False\n    self._before_request_lock = Lock()\n\n    # Add a static route using the provided static_url_path, static_host,\n    # and static_folder if there is a configured static_folder.\n    # Note we do this without checking if static_folder exists.\n    # For one, it might be created while the server is running (e.g. during\n    # development). Also, Google App Engine stores static files somewhere\n    if self.has_static_folder:\n        assert (\n            bool(static_host) == host_matching\n        ), ""Invalid static_host/host_matching combination""\n        # Use a weakref to avoid creating a reference cycle between the app\n        # and the view function (see #3761).\n        self_ref = weakref.ref(self)\n        self.add_url_rule(\n            f""{self.static_url_path}/<path:filename>"",\n            endpoint=""static"",\n            host=static_host,\n            view_func=lambda **kw: self_ref().send_static_file(**kw),  # type: ignore # noqa: B950\n        )\n\n    # Set the name of the Click group in case someone wants to add\n    # the app\'s commands to another CLI tool.\n    self.cli.name = self.name'
True, '""""""\nPropagates exceptions to the application\'s context.\n\nThis function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\nIf it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether exceptions should be propagated to the application\'s context.\n""""""'
False, 'def make_config(\n    """"""\n    Creates a configuration object for the application.\n\n    Args:\n        instance_relative (bool): If True, uses the instance\'s path as the root path.\n            Defaults to False.\n\n    Returns:\n        Config: The created configuration object.\n    """"""\n    root_path = self.root_path\n    if instance_relative:\n        root_path = self.instance_path\n    defaults = dict(self.default_config)\n    defaults[""ENV""] = os.environ.get(""FLASK_ENV"") or ""production""\n    defaults[""DEBUG""] = get_debug_flag()\n    return self.config_class(root_path, defaults)'
True, '""""""\nReturns the value of `TEMPLATES_AUTO_RELOAD` from the application configuration.\n\nIf `TEMPLATES_AUTO_RELOAD` is set, its value is returned. Otherwise, the value of `debug` is used as a fallback.\n\nDeprecated since Flask 2.3 in favor of using `TEMPLATES_AUTO_RELOAD` in `app.config`.\n\nArgs:\n    None\n\nReturns:\n    bool: The value of `TEMPLATES_AUTO_RELOAD` or `debug` if not set.\n""""""'
False, '""""""\nDeprecation Notice:\n\n    The `templates_auto_reload` method is deprecated and will be removed in Flask 2.3.\n    Use the \'TEMPLATES_AUTO_RELOAD\' configuration option instead.\n\n    Args:\n        value (bool): Whether to enable or disable template auto-reload.\n\n    Returns:\n        None\n""""""\ndef templates_auto_reload(self, value: bool) -> None:\nimport warnings\n\nwarnings.warn(\n    ""\'templates_auto_reload\' is deprecated and will be removed in Flask 2.3.""\n    "" Use \'TEMPLATES_AUTO_RELOAD\' in \'app.config\' instead."",\n    DeprecationWarning,\n    stacklevel=2,\n)\nself.config[""TEMPLATES_AUTO_RELOAD""] = value'
True, '""""""\nReturns the environment variable as a string.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3.\nUse `app.debug` instead.\n\nArgs:\n    None\n\nReturns:\n    str: The environment variable value.\n\nRaises:\n    DeprecationWarning: If the \'app.env\' method is called.\n""""""'
True, '""""""\nDeprecation Warning: `env` method is deprecated and will be removed in Flask 2.3.\nUse `debug` attribute instead.\n\nArgs:\n    value (str): The environment variable to set.\n\nReturns:\n    None\n""""""'
False, '```\nRun the Flask Development Server.\n\n### Parameters\n\n- `host`: The host IP address or hostname to bind to (default: None)\n- `port`: The port number to use for the server (default: None)\n- `debug`: Whether to enable debug mode (default: None, will override other sources)\n- `load_dotenv`: Whether to load environment variables from a .env file (default: True)\n- `options`: Additional options for the server (default: {})\n\n### Returns\n\nNone. This function runs the Flask development server and does not return any value.\n\n### Notes\n\nThis function is used to run the Flask development server. It takes several parameters, including host, port, debug mode, and environment variables from a .env file. The `debug` parameter can override other sources of debug information. If no host or port are provided, it will use the default values. The `options` dictionary can be used to customize the behavior of the server.\n\n### Example Usage\n\n```python\napp = Flask(__name__)\napp.run(host=""0.0.0.0"", port=5000)\n```\n\nThis example runs the Flask development server on host ""0.0.0.0"" and port 5000.'
True, '""""""\nDeprecation Warning: before_first_request function is deprecated and will be removed in Flask 2.3.\n \n   To avoid deprecation warnings, run setup code while creating the application instead.\n\n   Parameters:\n       f (T_before_first_request): The function to be executed before the first request.\n\n   Returns:\n       T_before_first_request: The input function for appending to self.before_first_request_funcs.\n\n   Note:\n       This function is deprecated and should not be used in new applications. Instead, run setup code while creating the application.\n""""""'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    # Run before_first_request functions if this is the thread\'s first request.\n    # Inlined to avoid a method call on subsequent requests.\n    # This is deprecated, will be removed in Flask 2.3.\n    if not self._got_first_request:\n        with self._before_request_lock:\n            if not self._got_first_request:\n                for func in self.before_first_request_funcs:\n                    self.ensure_sync(func)()\n\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nReturns the JSON encoder class, deprecation warning if applicable.\n\nThis function is deprecated and will be removed in Flask 2.3. It\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    None\n\nReturns:\n    t.Union[t.Type[json.JSONEncoder], None]: The JSON encoder class or None.\n""""""'
True, '""""""\nDeprecation Warning: json_encoder function is deprecated and will be removed in Flask 2.3.\n \nTo customize the JSON encoding behavior, use either \'app.json_provider_class\' or \'app.json\' instead.\n\nArgs:\n    value (Union[Type[JSONEncoder], None]): The JSON encoder class to use. Defaults to None.\n\nReturns:\n    None\n""""""'
False, '""""""\nDecodes JSON data.\n\nThis function returns the instance of `JSONDecoder` class, which is used to decode JSON data.\nHowever, due to deprecation, it\'s recommended to customize \'app.json_provider_class\' or \'app.json\' instead.\n\nReturns:\n    t.Union[t.Type[json.JSONDecoder], None]: The instance of `JSONDecoder` class or None if not available.'
True, '""""""\nDecodes JSON values.\n\nThis function is deprecated and will be removed in Flask 2.3.\nInstead, customize `app.json_provider_class` or `app.json`.\n\nArgs:\n    value (t.Union[t.Type[json.JSONDecoder], None]): The JSON decoder to use.\n\nReturns:\n    None\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
True, '""""""\nDeprecation Notice:\n\nThe `before_app_first_request` function is deprecated and will be removed in Flask 2.3.\nUse the `record_once` method instead to run setup code when registering a blueprint.\n\nParameters:\nf (T_before_first_request): The function to register for before first request.\n\nReturns:\nT_before_first_request: The registered function.\n\nRaises:\nDeprecationWarning: If the function is deprecated and should be replaced with `record_once`.\n""""""'
False, '""""""\nTests the session path configuration for a Flask application.\n\nThis function tests that the `APPLICATION_ROOT` is correctly set as the\nsession path. It does this by updating the app\'s config, creating an index\nroute with a test session value, and then making a GET request to the root\nURL of the app. The response headers are checked to ensure that the correct\nCookie is being set.\n\nArgs:\n    app (Flask): The Flask application instance.\n    client (requests.Session): A requests session object for making HTTP requests.\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the expected Cookie header value is not found in the response.'
False, '""""""\nTest session using server name and port.\n\nThis function tests the functionality of Flask\'s session handling when using a server name and port.\nIt updates the session with a value, sends a GET request to the root URL, and checks if the `Set-Cookie` header contains the expected domain information.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (requests Session): The requests session instance.\n\nReturns:\n    None\n""""""\ndef test_session_using_server_name_and_port(app, client):\n    app.config.update(SERVER_NAME=""example.com:8080"")\n\n    @app.route(""/"")\n    def index():\n        flask.session[""testing""] = 42\n        return ""Hello World""\n\n    rv = client.get(""/"", ""http://example.com:8080/"")\n    cookie = rv.headers[""set-cookie""].lower()\n    # or condition for Werkzeug < 2.3\n    assert ""domain=example.com"" in cookie or ""domain=.example.com"" in cookie'
True, '""""""\nFlask Session Initialization and Response Generation\n\nThis function initializes a Flask session variable \'testing\' with value 42 and returns a string response.\n\nParameters:\nNone\n\nReturns:\nstr: A greeting message ""Hello World""\n\nSide Effects:\n- Initializes the Flask session variable \'testing\' with value 42\n""""""'
False, '""""""\nTest session using server name, port and path.\n\nThis function tests the creation of a Flask session using the `server_name`, \n`application_root` configuration options. It verifies that the session is \ncorrectly set with the expected domain, path, and HTTP-only flags in the \nset-cookie header.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (requests Session): The requests session instance.\n\nReturns:\n    None\n""""""\ndef test_session_using_server_name_port_and_path(app, client):'
True, '""""""\nFlask Session Initialization and Response Generation\n\nThis function initializes a Flask session variable \'testing\' with value 42 and returns a string response.\n\nParameters:\nNone\n\nReturns:\nstr: A greeting message ""Hello World""\n\nSide Effects:\n- Initializes the Flask session variable \'testing\' with value 42\n""""""'
True, '""""""\nTest session warning for localhost.\n\nThis function tests the behavior of Flask\'s session warnings when using a local server.\nIt updates the session with a test value, sends a request to the index route,\nand verifies that the correct warning is raised and its message matches the expected value.\n\nParameters:\n    recwarn (WarningRegistry): The registry of warnings to be popped from.\n    app (Flask application instance): The Flask application instance.\n    client (TestClient): The test client for making requests to the application.\n\nReturns:\n    None\n""""""'
True, '""""""\nFlask Session Test Function\n\nThis function tests the functionality of Flask\'s session management.\nIt sets a test value in the session and returns a success message.\n\nReturns:\n    str: A success message indicating that the test was run successfully.\n\nNote:\n    This function should be used as part of a larger application to test session management.\n""""""'
True, '""""""\nTest session IP warning.\n\nThis function tests the behavior of Flask when setting a cookie with an IP address as its domain.\nIt verifies that a UserWarning is raised and that the warning message contains the expected text.\n\nParameters:\n    recwarn (warnings.Warnings): The warnings registry to use for this test.\n    app (Flask application instance): The Flask application instance to use for this test.\n    client (requests.Session): The requests session to use for making HTTP requests.\n\nReturns:\n    None\n""""""'
True, '""""""\nFlask Session Test Function\n\nThis function tests the functionality of Flask\'s session management.\nIt sets a test value in the session and returns a success message.\n\nReturns:\n    str: A success message indicating that the test was run successfully.\n\nNote:\n    This function should be used as part of a larger application to test session management.\n""""""'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = flask.Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of `flask.get_flashed_messages` with category filtering.\n\nThis function tests that the `get_flashed_messages` method returns a list of\nflashed messages, filtered by categories. The test case checks that the\nfiltered messages match the expected output.\n\nParameters:\n    None\n\nReturns:\n    A string indicating whether the test passed or failed.\n""""""\ndef test_filters():'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
True, '""""""\nRenders the first request to an application.\n\nThis function simulates a client making a GET request to the root URL of the application.\nIt asserts that the `debug` attribute is set to True, and that the response from the server matches the expected value.\nAdditionally, it tests that attempting to add a new route after the first request raises an AssertionError with a specific message.\n\nArgs:\n    app (Flask application): The Flask application instance being tested.\n    client (requests.Session): A requests session object used to simulate the client\'s request.\n\nReturns:\n    None\n""""""'
True, '""""""\nRequest Functions for Application Testing\n\nThis function tests the application\'s behavior when making requests before and after the first request.\n\nParameters:\napp (object): The application object to be tested.\nclient (object): The client object used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nAdds 42 to the \'got\' list.\n\nThis function is not intended for external use and should only be accessed internally within the application.\n""""""'
True, '""""""\nConcurrently tests the application\'s routing functionality by making a request to the root URL while another thread is asserting that a value was appended to the `got` list.\n\nThis function uses pytest\'s deprecated_call context manager to ensure that the `foo` function, which appends a value to the `got` list, is called before the first request is made. It then creates a new thread that runs the `get_and_assert` function in parallel with the main thread.\n\nThe `get_and_assert` function makes a GET request to the root URL and asserts that the value appended to the `got` list matches the expected value. The main thread waits for the thread to finish before asserting that the application\'s `got_first_request` attribute is set to True.\n\nThis test ensures that the application\'s routing functionality works correctly even when multiple threads are making requests concurrently.\n""""""'
True, '""""""\nReturns the result of appending 42 to the \'got\' list after a 200ms delay.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    None\n\nExample:\n    >>> get_and_asse()\n""""""'
False, '""""""\nTests the functionality of the get method on the client object.\n\nThis test case checks if the get method returns a list containing the expected value when called with the root URL (""/"").\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.\n""""""\n\nclient.get(""/"")\nassert got == [42]\n\n""""""\nTests the functionality of threading in Python.\n\nThis test case checks if the Thread class can be instantiated correctly and if it can target a specific function.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    AssertionError: If the thread is not created successfully or if it does not target the expected function.\n""""""\n\nt = Thread(target=  # <--- Missing keyword \'self\''
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
True, '""""""\nReturns an instance of the Logger class.\n\nThis method is used to initialize and return a new logger object. The logger object is created using the `create_logger` function, which takes the current object (`self`) as an argument.\n\nArgs:\n    self: The current object.\n\nReturns:\n    logging.Logger: An instance of the Logger class.\n""""""'
True, '""""""\nReturns an instance of Jinja2\'s Environment class.\n\nThis method is a wrapper around `create_jinja_environment` and provides a more Pythonic interface for creating a new Jinja environment. The returned environment can be used to compile templates, render templates with data, and perform other template-related tasks.\n\nNote: This method does not create a new environment instance; it simply delegates the creation to the underlying `create_jinja_environment` method.\n""""""'
False, '""""""\nPropagates exceptions to the application\'s context.\n\nThis function checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration.\nIf it exists, its value is returned. Otherwise, the function returns whether the application is running in testing or debug mode.\n\nDeprecation Warning: This method is deprecated and will be removed in Flask 2.3. It\'s recommended to use a different approach for exception propagation.\n\nArgs:\n    None\n\nReturns:\n    bool: Whether exceptions should be propagated to the application\'s context.\n""""""\ndef got_first_request(self) -> bool:\n    """"""\n    Checks the value of `PROPAGATE_EXCEPTIONS` in the Flask configuration and returns its value or whether the application is running in testing or debug mode.\n\n    Deprecation Warning: This method is deprecated and will be removed in Flask 2.4.\n    """"""\n    import warnings\n\n    warnings.warn(\n        ""\'got_first_request\' is deprecated and will be removed in Flask 2.4."",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    return self._got_first_request'
False, '```python\ndef run(\n    host: t.Optional[str] = None,\n    port: t.Optional[int] = None,\n    debug: t.Optional[bool] = None,\n    load_dotenv: bool = True,\n    **options: t.Any,\n) -> None:\n    """"""\n    Run the Flask development server.\n\n    This method is used to start a Flask development server. It takes several\n    optional parameters, including `host`, `port`, and `debug`. If these\n    parameters are not provided, they will be set based on the configuration\n    of the application.\n\n    Args:\n        host: The hostname or IP address to bind to. Defaults to None.\n        port: The port number to use. Defaults to None.\n        debug: A boolean indicating whether to enable debug mode. Defaults to None.\n        load_dotenv: A boolean indicating whether to load environment variables\n            from a .env file. Defaults to True.\n        **options: Additional keyword arguments to pass to the `run_simple`\n            function.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If an invalid port number is provided.\n    """"""\n```'
False, '""""""\nDispatches the full request, including running before_first_request functions and handling exceptions.\n\nThis method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\nParameters\nself (object): The instance of the class that this method belongs to.\n\nReturns\nResponse: The response from the dispatching process.\n""""""\ndef full_dispatch_request(self) -> Response:\n    """"""\n    Dispatches the full request, including running before_first_request functions and handling exceptions.\n\n    This method is deprecated in favor of a more efficient implementation. It should not be used in new code.\n\n    Parameters\n    self (object): The instance of the class that this method belongs to.\n\n    Returns\n    Response: The response from the dispatching process.\n    """"""\n    self._got_first_request = True\n\n    try:\n        request_started.send(self)\n        rv = self.preprocess_request()\n        if rv is None:\n            rv = self.dispatch_request()\n    except Exception as e:\n        rv = self.handle_user_exception(e)\n    return self.finalize_request(rv)'
True, '""""""\nInitialize a new instance of the class.\n\nParameters:\n    name (str): The name of the application or module.\n    import_name (str): The import name of the application or module.\n    static_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the static folder. Defaults to None.\n    static_url_path (t.Optional[str], optional): The URL path for static files. Defaults to None.\n    template_folder (t.Optional[t.Union[str, os.PathLike]], optional): The path to the template folder. Defaults to None.\n    url_prefix (t.Optional[str], optional): The prefix for URLs. Defaults to None.\n    subdomain (t.Optional[str], optional): The subdomain for URLs. Defaults to None.\n    url_defaults (t.Optional[dict], optional): Default values for URL parameters. Defaults to None.\n    root_path (t.Optional[str], optional): The root path of the application or module. Defaults to None.\n    cli_group (t.Optional[str], optional): The CLI group name. Defaults to _sentinel.\n\nRaises:\n    ValueError: If \'name\' is empty or contains a dot \'.\' character.\n\nAttributes:\n    name (str): The name of the application or module.\n    url_prefix (str): The prefix for URLs.\n    subdomain (str): The subdomain for URLs.\n    deferred_functions (list): A list of deferred functions.\n    url_values_defaults (dict): Default values for URL parameters.\n    cli_group (str): The CLI group name.\n    _blueprints (list): A list of blueprints and their configurations.\n\nNote:\nThis function initializes a new instance of the class, setting up various attributes such as `name`, `url_prefix`, `subdomain`, and more. It also raises a ValueError if the \'name\' parameter is empty or contains a dot \'.\' character.\n""""""'
True, '""""""\nRaises an AssertionError if the setup method has already been registered.\n\nIf the setup method has been called at least once, this function will raise\nan AssertionError with a message indicating that further calls to the setup\nmethod will not be applied consistently. This is intended to prevent changes\nto imports, decorators, functions, etc. from being made after registration.\n\nArgs:\n    f_name (str): The name of the setup method that was called.\n\nRaises:\n    AssertionError: If the setup method has already been registered.\n""""""'
False, 'def register(self, app: ""Flask"", options: dict) -> None:\n    """"""\n    Registers the current class instance as a Blueprint in the given Flask application.\n\n    Args:\n        app (Flask): The Flask application to register with.\n        options (dict): A dictionary of options for the registration process.\n\n    Raises:\n        ValueError: If a name conflict occurs while registering the Blueprint.\n\n    Returns:\n        None\n    """"""\n    # ... (rest of the code remains the same)'
False, 'def test_session_path(app, client):\n    """"""\n    Initializes a Flask session variable \'testing\' with value 42 and returns a string response.\n\n    Parameters:\n        None\n\n    Returns:\n        str: A greeting message ""Hello World""\n\n    Side Effects:\n        - Initializes the Flask session variable \'testing\' with value 42\n    """"""\n    app.config.update(APPLICATION_ROOT=""/foo"")\n\n    @app.route(""/"")\n    def index():\n        flask.session[""testing""] = 42\n        return ""Hello World""\n\n    rv = client.get(""/"", ""http://example.com:8080/foo"")\n    assert ""path=/foo"" in rv.headers[""set-cookie""].lower()'
False, '""""""\nTests the behavior of Flask\'s session object when storing special types such as bytes, Markup objects, and UUIDs.\n\nThis function tests that these types are stored correctly and can be retrieved later.\n\nParameters:\n    app (Flask application): The Flask application instance.\n    client (Client): The client instance used for testing.\n\nReturns:\n    None\n""""""\ndef test_session_special_types(app, client):\n    """"""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).\n""""""\n        flask.session[""t""] = (1, 2, 3)\n        flask.session[""b""] = b""\\xff""\n        flask.session[""m""] = Markup(""<html>"")\n        flask.session[""u""] = the_uuid\n        flask.session[""d""] = now\n        flask.session[""t_tag""] = {"" t"": ""not-a-tuple""}\n        flask.session[""di_t_tag""] = {"" t__"": ""not-a-tuple""}\n        flask.session[""di_tag""] = {"" di"": ""not-a-dict""}\n        return """", 204'
False, '""""""\nDumps session contents into the Flask session.\n\nThis function populates the Flask session with various data types, including a tuple, bytes, Markup object, UUID, datetime, and dictionaries. The returned value is an empty string and a status code of 204 (No Content).\n\nNote:\n- The `Markup` object is used to represent HTML content.\n- The `uuid` variable is assumed to be defined elsewhere in the codebase.\n- The `now` variable is assumed to be a datetime object representing the current time.\n\nReturns:\n    tuple: A tuple containing an empty string and a status code of 204 (No Content).'
True, '""""""\nTest the functionality of the `flask.flash` function.\n\nThis test suite checks that the `flask.flash` function correctly stores and retrieves\nmessages with different categories. It also tests that messages can be filtered by category.\n\nThe test suite consists of several routes, each testing a specific scenario:\n\n- `/`: Tests flashing a message without specifying a category.\n- `/test/`: Tests flashing multiple messages with different categories.\n- `/test_with_categories/`: Tests flashing a message with a category and retrieving it.\n- `/test_filter/`: Tests filtering messages by category.\n- `/test_filters/`: Tests filtering messages by multiple categories.\n- `/test_filters_without_returning_categories/`: Tests filtering messages without returning categories.\n\nEach test uses the `app.test_client()` to simulate a request to the route, ensuring that\nthe flashed messages are properly cleaned after each test.\n\nNote: Make sure to set `app.testing=True` before running these tests, as otherwise,\nAssertionErrors in view functions will cause a 500 response instead of propagating exceptions.\n""""""'
True, '""""""\nFlask Flash Messages Function\n\nThis function utilizes Flask\'s flash messaging system to display messages to the user.\nIt takes advantage of the `flash` method provided by Flask, which can be used to set and retrieve\nmessages for different types of notifications (e.g., success, error, warning).\n\nParameters:\n    None\n\nReturns:\n    str: An empty string indicating the function has completed its task.\n\nNotes:\n- The first call to `flask.flash(""Hello World"")` sets a default message type as \'success\'.\n- The second call to `flask.flash(""Hello World"", ""error"")` overrides the previous message with an error type.\n- The third call to `flask.flash(flask.Markup(""<em>Testing</em>""), ""warning"")` sets a warning message containing HTML markup.\n""""""'
False, '""""""\nTests that the `get_flashed_messages` function returns a list of flashed messages.\n\nThis test case checks if the `get_flashed_messages` function correctly retrieves and returns a list of flashed messages.\nIt asserts that the returned list contains the expected messages, including HTML markup.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution of the test.\n\nRaises:\n    AssertionError: If the returned list does not match the expected output.'
True, '""""""\nTests the functionality of getting flashed messages with categories.\n\nThis function tests the `flask.get_flashed_messages(with_categories=True)` method, \nwhich returns a list of tuples containing the category and message. The test \nasserts that the length of the returned list is 3 and that it contains the expected\nmessages with their respective categories.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string indicating successful execution.\n""""""'
False, '""""""\nTests the functionality of the `get_flashed_messages` function from Flask, \nspecifically when using category filters.\n\nThis test case checks that the function returns a list of messages with their respective categories,\nand that it correctly handles the \'with_categories\' parameter.\n\nParameters:\n- None\n\nReturns:\n- A string indicating whether the test passed or failed.\n""""""\ndef test_filters():\n    messages = flask.get_flashed_messages(\n        category_filter=[""message"", ""warning""], with_categories=True\n    )\n    assert list(messages) == [\n        (""message"", ""Hello World""),\n        (""warning"", Markup(""<em>Testing</em>"")),\n    ]\n    return """"'
True, '""""""\nTests the functionality of getting flashed messages with a category filter.\n\nThis function tests that the `flask.get_flashed_messages` method returns two messages\nwhen called with a category filter. The first message is expected to be ""Hello World""\nand the second message is expected to be an HTML-marked string ""<em>Testing</em>"".\n\nArgs:\n    None\n\nReturns:\n    str: An empty string, indicating successful test execution.\n""""""'
False, '""""""\nReturns the value of a deprecated attribute.\n\nIf the requested attribute is `_app_ctx_stack` or `_request_ctx_stack`, it returns its value and issues a deprecation warning. Otherwise, it raises an `AttributeError`.\n\nArgs:\n    name (str): The name of the attribute to return.\n\nReturns:\n    object: The value of the requested attribute, or raises an AttributeError if not found.\nRaises:\n    DeprecationWarning: If the requested attribute is deprecated and will be removed in a future version of Flask.'
False, '""""""\nReturns whether signals are available.\n\nThis function raises an `AttributeError` if the requested attribute is not \'signals_available\'.\nIf \'signals_available\' is requested, it returns `True` and issues a deprecation warning.\n\nArgs:\n    name (str): The name of the attribute to check for availability.\n\nReturns:\n    t.Any: Whether signals are available or the requested attribute value.\nRaises:\n    AttributeError: If the requested attribute does not exist.\n    DeprecationWarning: If \'signals_available\' is requested, indicating deprecation.']
True, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str. optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"". ""rt"". and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""'
True, '""""""\nOpens an instance resource file.\n\nArgs:\n    - `resource` (str): The path to the resource file.\n    - `mode` (str. optional): The mode in which to open the file. Defaults to ""rb"".\n\nReturns:\n    A file object opened at the specified location with the given mode.\n\nRaises:\n    FileNotFoundError: If the instance_path does not exist or the resource is not found.\n""""""'
False, 'def make_response(self. rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response tuple must be in one of the following formats:\n\n    - (body. status. headers)\n    - (body. status)\n    - (body. headers)\n\n    If the body is None. a TypeError is raised. If the body is not an instance\n    of the Response class. it is converted to the correct type.\n\n    Args:\n        rv: The result of the view function.\n\n    Returns:\n        A Response object.\n    """"""\n    status = headers = None\n\n    # unpack tuple returns\n    if isinstance(rv. tuple):\n        len_rv = len(rv)\n\n        # a 3-tuple is unpacked directly\n        if len_rv == 3:\n            rv. status. headers = rv  # type: ignore[misc]\n        # decide if a 2-tuple has status or headers\n        elif len_rv == 2:\n            if isinstance(rv[1]. (Headers. dict. tuple. list)):\n                rv. headers = rv\n            else:\n                rv. status = rv  # type: ignore[assignment.misc]\n        # other sized tuples are not allowed\n        else:\n            raise TypeError(\n                ""The view function did not return a valid response tuple.""\n                "" The tuple must have the form (body. status. headers).""\n                "" (body. status). or (body. headers).""\n            )\n\n    # the body must not be None\n    if rv is None:\n        raise TypeError(\n            f""The view function for {request.endpoint!r} did not""\n            "" return a valid response. The function either returned""\n            "" None or ended without a return statement.""\n        )\n\n    # make sure the body is an instance of the response class\n    if not isinstance(rv. self.response_class):\n        if isinstance(rv. (str. bytes. bytearray)) or isinstance(rv. cabc.Iterator):\n            # let the response class set the status and headers instead of\n            # waiting to do it manually. so that the class can handle any\n            # special logic\n            rv = self.response_class(\n                rv.\n                status=status.\n                headers=headers.  # type: ignore[arg-type]\n            )\n            status = headers = None\n        elif isinstance(rv. (dict. list)):\n            rv = self.json.response(rv)\n        elif isinstance(rv. BaseResponse) or callable(rv):\n            # evaluate a WSGI callable. or coerce a different response\n            # class to the correct type\n            try:\n                rv = self.response_class.force_type(\n                    rv.  # type: ignore[arg-type]\n                    request.environ.\n                )\n            except TypeError as e:\n                raise TypeError(\n                    f""{e}\\nThe view function did not return a valid""\n                    "" response. The return type must be a string.""\n                    "" dict. list. tuple with headers or status.""\n                    "" Response instance. or WSGI callable. but it""\n                    f"" was a {type(rv).__name__}.""\n                ).with_traceback(sys.exc_info()[2]) from None\n        else:\n            raise TypeError(\n                ""The view function did not return a valid""\n                "" response. The return type must be a string.""\n                "" dict. list. tuple with headers or status.""\n                "" Response instance. or WSGI callable. but it was a""\n                f"" {type(rv).__name__}.""\n            )\n\n    rv = t.cast(Response. rv)\n    # prefer the status if it was provided\n    if status is not None:\n        if isinstance(status. (str. bytes. bytearray)):\n            rv.status = status\n        else:\n            rv.status_code = status\n\n    # extend existing headers with provided headers\n    if headers:\n        rv.headers.update(headers)\n\n    return rv'
True, '""""""\nReturns the root path of the given imported module.\n\nIf the module has already been imported and its file attribute is available.\nits directory path is returned. Otherwise. it attempts to find the loader\nassociated with the import specification and uses it to determine the root\npath. If this fails. it falls back to using the current working directory.\n\nArgs:\n    import_name (str): The name of the module for which to retrieve the root path.\n\nReturns:\n    str: The root path of the given imported module.\nRaises:\n    ValueError: If the loader is not found or if the module specification is None.\n    RuntimeError: If no root path can be found for a namespace package.\n""""""'
True, '""""""\nInitialize a ScriptInfo object with optional parameters to configure the application.\n\nParameters:\napp_import_path (str | None): Optionally the import path for the Flask application.\ncreate_app (Callable[.... Flask] | None): Optionally a function that is passed the script info to create\nthe instance of the application.\nset_debug_flag (bool): A dictionary with arbitrary data that can be associated with this script info.\nload_dotenv_defaults (bool): Whether default ``.flaskenv`` and ``.env`` files should be loaded.\n\nReturns:\nNone\n\nRaises:\nNone\n\nVersion Added: 3.1\n""""""'
True, '""""""\nLoads an environment file using the python-dotenv library.\n\nIf a value was passed to the function. it will attempt to load the environment file.\nIf no value is passed and `load_dotenv_defaults` is set in the context object.\nit will also load default files. If neither condition is met. the function\nwill return None.\n\nRaises:\n    click.BadParameter: If python-dotenv must be installed but was not found.\n    Exception: Any other exception that occurs during file loading.\n\nReturns:\n    str | None: The loaded environment value or None if no value was passed.\n""""""'
True, '""""""\nCreates a Click context with optional information and extra settings.\n\nArgs:\n    info_name (str | None): The name of the info to use.\n    args (list[str]): A list of arguments to pass to the command.\n    parent (click.Context | None): The parent context. defaults to None.\n    **extra: t.Any: Additional keyword arguments to include in the context.\n\nReturns:\n    click.Context: The created Click context.\n\nNote:\n    This function sets a flag to prevent Flask from running when importing\n    this module. ensuring that commands are executed correctly. It also adds\n    an \'obj\' key to the extra dictionary if it\'s not already present. containing\n    a ScriptInfo object with necessary methods for creating and setting debug flags.\n""""""'
True, '""""""\nLoads environment variables from a .env file.\n\nThis function attempts to load environment variables from the current directory\nor from a specified path. If no .env files are found. it will display a tip\nmessage suggesting the installation of python-dotenv.\n\nArgs:\n    path (str | os.PathLike[str] | None): The path to the .env file to load.\n        If None. the function will look for a .env file in the current directory.\n    load_defaults (bool): Whether to load default environment variables from\n        .flaskenv and .env files. Defaults to True.\n\nReturns:\n    bool: True if at least one environment variable was loaded. False otherwise.\n""""""'
True, '""""""\nTest the behavior of `CliRunner` when invoked with a missing command.\n\nThis test checks that the `CliRunner` raises an error when attempting to run a command that is not defined. and that the error message includes the expected information.\n""""""'
False, '""""""\nTest the functionality of the `cli.invoke` method with the `--help` option.\n\nThis test checks that the command returns a non-zero exit code when run with the `--help` option.\nand that it prints the expected usage message and environment variable information to stderr.\n""""""\n\ndef test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning. TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli. [""--help""])\n    assert result.exit_code == 0\n    assert ""FLASK_APP"" in result.stderr\n    assert ""Usage:"" in result.stdout'
True, '""""""\nTest the functionality of the `CliRunner` class when invoking the help command.\n\nThis test checks that:\n\n- The `CliRunner` class can handle exceptions raised by the application.\n- The help command is invoked successfully and returns the expected output.\n- The exception message is correctly displayed in the stderr output.\n\nThe test uses a Flask app that raises an exception when called. simulating a real-world scenario where an error occurs during execution. It then checks that the `CliRunner` class can handle this exception and display the correct help message.\n""""""'
False, '""""""\nTest the functionality of the `load_dotenv` function.\n\nThis test checks that the function correctly loads environment variables from a `.env` file.\noverwrites existing variables. and handles non-existent files. It also tests the behavior when\nusing a different encoding for the environment file.\n\nArgs:\n    monkeypatch: A MonkeyPatch object used to mock out the `os.environ` and `os.path` modules.\n    test_path: The path of the test directory.\n    load_defaults (bool): Whether to use default values if the `.env` file is missing. Defaults to True.\n\nReturns:\n    bool: Whether the environment variables were loaded successfully.\n""""""\ndef test_load_dotenv(monkeypatch. test_path):\n    # ... (rest of the code remains the same)'
False, '""""""\nOpens a resource file.\n\nArgs:\n    resource (str): The path to the resource file.\n    mode (str. optional): The mode in which to open the file. Defaults to ""rb"". Supported modes are ""r"". ""rt"". and ""rb"".\n\nReturns:\n    t.IO[t.AnyStr]: A file object opened in the specified mode.\n\nRaises:\n    ValueError: If an unsupported mode is provided.\n""""""\ndef open_resource(self. resource: str. mode: str = ""rb"". encoding: str | None = None) -> t.IO[t.AnyStr]:\n""""""\nOpens an instance resource file.\n\nArgs:\n    - `resource` (str): The path to the resource file.\n    - `mode` (str. optional): The mode in which to open the file. Defaults to ""rb"".\n\nReturns:\n    A file object opened at the specified location with the given mode.\n\nRaises:\n    FileNotFoundError: If the instance_path does not exist or the resource is not found.\n""""""\ndef open_instance_resource(self. resource: str. mode: str = ""rb"". encoding: str | None = ""utf-8"") -> t.IO[t.AnyStr]:\n""""""'
False, 'def make_response(self. rv: ft.ResponseReturnValue) -> Response:\n    """"""\n    Creates a response object from the given view function result.\n\n    The response object is created based on the type of the view function result.\n    If the result is a tuple. it is unpacked into body. status. and headers.\n    If the result is not a valid response tuple. a TypeError is raised.\n    If the body is None. a TypeError is raised.\n    If the body is not an instance of the response class. it is converted to\n    the correct type.\n\n    Args:\n        rv: The view function result.\n\n    Returns:\n        A Response object.\n\n    Raises:\n        TypeError: If the view function did not return a valid response tuple.\n            or if the body is None.\n    """"""'
True, '""""""\nReturns a URLSafeTimedSerializer instance for signing purposes.\n\nIf the application\'s secret key is not set. returns None. Otherwise. uses the\nsecret key and any fallbacks specified in the configuration to generate a\nserializer.\n\nArgs:\n    app (Flask): The Flask application instance.\nReturns:\n    URLSafeTimedSerializer | None: A serializer instance for signing purposes.\n        or None if the secret key is not set.\n""""""'
True, '""""""\nTest the behavior of Flask\'s session when a secret key is changed and a fallback mechanism is enabled.\n\nThis test case covers three scenarios:\n\n- Initial setup: A session is created with an initial secret key. which can be loaded successfully.\n- Secret key change: The secret key is changed. causing the session to appear empty. However. if a fallback mechanism is enabled. the session can still be loaded.\n- Fallback mechanism: The fallback mechanism is explicitly set. allowing the session to be loaded even when the initial secret key is not available.\n\nThis test ensures that Flask\'s session handling behaves correctly in different scenarios. providing a robust and secure way to store user data.\n""""""'
True, '""""""\nSets a session variable \'a\' to 1 and returns an empty string.\n\nArgs:\n    None\n\nReturns:\n    str: An empty string. not used in this function.\n\nRaises:\n    None\n\nExample:\n    >>> set_session()\n    \'\'\n""""""'
True, '""""""\nReturns the current session as a dictionary.\n\nThis function leverages Flask\'s built-in session object to retrieve its contents.\nThe returned dictionary contains all key-value pairs present in the session.\n\nArgs:\n    None\n\nReturns:\n    dict[str. t.Any]: The current session as a dictionary\n""""""'
True, '""""""\nReturns an empty response object after synchronization.\n\nArgs:\n    response (Response): The response object to be synchronized.\n\nReturns:\n    Response: An empty response object.\n""""""'
True, '""""""\nReturns an empty response object. This function appears to be a placeholder or stub. as it does not actually process any data from the input `response` and instead returns a new. unpopulated response object.\n\nArgs:\n    response (Response): The input response object.\n\nReturns:\n    Response: An empty response object.\n""""""'
True, '""""""\nSynchronizes data before any operations.\n\nThis function is intended to be called before any data synchronization or update operations.\nIt may include tasks such as cleaning up temporary files. resetting session variables. or performing other necessary steps to ensure a consistent state.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nAsync Function to be Executed Before Asynchronous Operations\n\nThis function is designed to be executed before any asynchronous operations. It serves as a placeholder or initialization point for tasks that need to be completed before proceeding with asynchronous code.\n\nArgs:\n    None\n\nReturns:\n    None\n""""""'
True, '""""""\nTeardowns synchronization operations after an exception occurs.\n\nThis function is designed to be used as part of a larger error handling mechanism.\nIt takes an exception object as input and performs any necessary cleanup or rollback\nof the synchronization operation before continuing execution. If no exception occurred.\nit does nothing.\n\nParameters:\nexc (BaseException | None): The exception that occurred. or None if no exception occurred.\n\nReturns:\nNone: This function does not return a value.\n""""""'
True, '""""""\nTeardowns an asynchronous operation.\n\nThis function is used to handle exceptions that occur during an asynchronous operation.\nIt provides a way to clean up resources and restore the original state of the system\nafter an exception has occurred.\n\nArgs:\n    exc (BaseException | None): The exception that occurred during the operation. Can be None if no exception occurred.\n\nReturns:\n    None\n\nRaises:\n    BaseException: If an error occurs while cleaning up resources.\n""""""'
True, '""""""\nHandles 400 Bad Request exceptions by returning an empty string.\n\nArgs:\n    e (BadRequest): The exception object containing information about the bad request.\n\nReturns:\n    str: An empty string indicating that the request was not processed.\n""""""'
True, '""""""\nHandles custom exceptions by returning an empty string.\n\nArgs:\n    e (ValueError): The exception to be handled.\n\nReturns:\n    str: An empty string.\n""""""'
True, '""""""\nHandles an exception raised during base acceptance.\n\nArgs:\n    e (Exception): The exception object that was raised.\n\nReturns:\n    str: An empty string indicating successful handling of the exception.\n""""""'
True, '""""""\nHandles exceptions raised by API endpoints.\n\nThis function takes an exception object of type `BadRequest` or `NotFound` and returns a string response.\nIf no exception is provided. it returns an empty string.\n\nArgs:\n    e (BadRequest | NotFound): The exception to be handled.\n\nReturns:\n    str: A string representation of the error response.\n""""""'
True, '""""""\nReturns an HTML paragraph with \'Hello. World!\' as its content.\n\nArgs:\nNone\n\nReturns:\nstr: The HTML paragraph string.\n""""""'
True, '""""""\nReturns a bytes object containing the HTML representation of ""Hello. World!"".\n\nArgs:\n\nNone\n\nReturns:\n\nbytes: The bytes object containing the HTML representation of ""Hello. World!"".\n\nExample:\n>>> hello_bytes()\nb\'<p>Hello. World!</p>\'\n""""""'
True, '""""""\nReturns a JSON response with \'Hello. World!\' as its content.\n\nArgs:\n\nNone\n\nReturns:\n\nResponse: A JSON object containing the string ""Hello. World!"".\n\nRaises:\n\nNone\n""""""'
True, '""""""\nReturns a JSON dictionary with a greeting message.\n\nArgs:\n\nNone\n\nReturns:\n\nA dictionary containing a string response.\n\nExample:\n    >>> hello_json_dict()\n    {\'response\': \'Hello. World!\'}\n""""""'
False, '""""""\nReturns a JSON list containing two objects with \'message\' key.\n\nArgs:\n\nNone\n\nReturns:\n\nlist[t.Any]: A list of dictionaries. each containing a string message.\n\nExample:\nhello_json_list() -> [{""message"": ""Hello""}. {""message"": ""World""}]'
True, '""""""\nReturns a typed dictionary with a \'status\' key set to \'ok\'.\n\nArgs:\n\nNone\n\nReturns:\n\nStatusJSON: A dictionary containing a single key-value pair.\n\nRaises:\n\nNone\n""""""'
True, '""""""\nGenerates a generator that yields a string with the format ""data:<number>\\n\\n"" for 100 iterations.\n\nReturns:\n    t.Generator[str. None. None]: A generator that produces strings in the specified format.\n""""""'
True, '""""""\nGenerates a sequence of strings representing data points.\n\nYields:\n    A generator that produces strings in the format ""data:<int>\\n\\n"" for each integer from 0 to 99.\n""""""'
True, '""""""\nGenerates an iterator of bytes containing a \'hello\' message repeated 100 times.\n\nReturns:\n    Iterator[bytes]: An iterator yielding bytes representing the \'hello\' message.\n""""""'
True, '""""""\nReturns an iterator that yields 100 lines of data. each on a new line.\n\nThe data is generated by concatenating the string ""data:"" with numbers from 0 to 99.\nfollowed by a newline character. The iterator can be used to process this data in chunks.\n\nArgs:\n    None\n\nYields:\n    str: A single line of data\n\nRaises:\n    None\n""""""'
True, '""""""\nReturns a tuple containing a status message and an HTTP status code.\n\nArgs:\n    code (int): The HTTP status code. Defaults to 200.\n\nReturns:\n    tuple[str. int]: A tuple containing the status message and the HTTP status code.\n""""""'
True, '""""""\nReturns a tuple containing a string and an HTTP status code.\n\nThe string is always \'hello\'. while the HTTP status code is set to OK (200).\n\nArgs:\n\nNone\n\nReturns:\n\ntuple[str. int]: A tuple containing a string and an HTTP status code.\n\nRaises:\n\nNone\n\nExample:\n    result = tuple_status_enum()\n    print(result)  # Output: (\'hello\'. 200)\n""""""'
True, '""""""\nReturns a tuple containing a string and a dictionary.\n\nThe string is \'Hello. World!\' and the dictionary contains a single key-value pair with \'Content-Type\' as the key and \'text/plain\' as the value.\n\nArgs:\n    None\n\nReturns:\n    tuple[str. dict[str. str]]: A tuple containing a string and a dictionary.\n""""""'
True, '""""""\nReturns an HTML template with a given name.\n\nArgs:\n    name (str. optional): The name to be displayed in the template. Defaults to None.\n\nReturns:\n    str: The rendered HTML template.\n""""""'
True, '""""""\nReturns an iterator over a template stream.\n\nThis function uses the `stream_template` function from the `jinja2` library to generate\nan iterator over a template stream. The template is specified by its file path and\nname. which are passed as arguments to this function.\n\nArgs:\n    name (str): The name of the template.\n\nReturns:\n    Iterator[str]: An iterator over the lines in the template.\n""""""'
True, '""""""\nAsync Route Function\n\nReturns a string indicating that an asynchronous route has been reached.\n\nArgs:\n\nNone\n\nReturns:\n\nstr: A message confirming the presence of an asynchronous route.\n\nRaises:\n\nNo exceptions are raised by this function.\n""""""'
True, '""""""\nInitializes a new instance of `RenderTemplateView`.\n\nArgs:\n    template_name (str): The name of the template to render.\n\nReturns:\n    None\n""""""'
True, '""""""\nDispatches a request to render a template.\n\nThis method is responsible for rendering an HTML template using the provided `template_name`. It takes into account the type of view (`self`) and returns the rendered HTML as a string.\n\nArgs:\n    self (RenderTemplateView): The instance of the RenderTemplateView class.\nReturns:\n    str: The rendered HTML template.\n""""""'
True, '# Handles exceptions raised by API endpoints.\n\n# This function takes an exception object of type `BadRequest` or `NotFound` and returns a string response.\n# If no exception is provided. it returns an empty string.\n\n# Args:\n#     e (BadRequest | NotFound): The exception to be handled.\n\n# Returns:\n#     str: A string representation of the error response.'
True, '""""""\nCreates an URL adapter based on the provided request or server configuration.\n\nIf a request is provided. it will be used to bind the URL map to the environment.\nOtherwise. it will use the server name from the configuration to create the adapter.\n\nReturns:\n    MapAdapter | None: The created URL adapter or None if no valid configuration is found.\n""""""'
True, '""""""\nServes a Flask application that matches server name components.\n\nThis function sets up a Flask application and tests its behavior for different server name configurations.\nIt checks the response of the application\'s root route for various base. ABC. and XYZ expectations.\n\nParameters:\n    subdomain_matching (bool): Whether to match subdomains in the server name.\n    host_matching (bool): Whether to match hosts in the server name.\n    expect_base (str): The expected response text when matching the base component of the server name.\n    expect_abc (str): The expected response text when matching the ABC component of the server name.\n    expect_xyz (str): The expected response text when matching the XYZ component of the server name.\n\nReturns:\n    None\n""""""'
True, '""""""\nReturns the input string as is.\n\nArgs:\n    name (str): The input string to be returned.\n\nReturns:\n    str: The input string.\n\nExample:\n    >>> x(""Hello. World!"")\n    \'Hello. World!\'\n""""""'
True, '""""""\nTest the functionality of a Flask application with nested subdomains.\n\nThis test case verifies that the application correctly handles requests to \nsubdomains by registering a child blueprint under a parent blueprint and \nconfiguring the server name accordingly. It also checks for redirects from \nthe root domain to the subdomain.\n\nArgs:\n    app (Flask): The Flask application instance.\n    client (Client): The test client instance.\n\nReturns:\n    None\n""""""'
True, '""""""\nTest the functionality of a Flask application with subdomain matching.\n\nThis test case verifies that when using a subdomain. the correct route is matched and returned.\nIt also checks that without a subdomain. a 404 error is returned.\n\nParameters:\napp (Flask): The Flask application instance.\nclient (Client): The client instance used to make HTTP requests.\n\nReturns:\nNone\n""""""'
True, '""""""\nReturns the string \'child\'.\n\nThis function is likely part of a larger application or framework and serves as an index or entry point. The returned value suggests that it may be used to navigate to a child component or page.\n\nArgs:\n\nNone\n\nReturns:\nstr: The string \'child\'\n\nRaises:\nNo exceptions are expected to be raised by this function.\n""""""'
False, '""""""\nCreates an URL adapter based on the provided request or server configuration.\n\nIf a request is provided. it will be used to bind the URL map to the environment.\nOtherwise. it will use the server name from the configuration to create the adapter.\n\nReturns:\n    MapAdapter | None: The created URL adapter or None if no valid configuration is found.'
True, '""""""\nTest trusted hosts configuration for Flask application.\n\nThis function tests the Flask application\'s trusted hosts configuration by sending GET requests to different URLs.\nIt asserts that requests to trusted hosts return a 200 status code. while requests to non-trusted hosts return a 400 status code.\n\nParameters:\napp (Flask): The Flask application instance.\n\nReturns:\nNone\n""""""'
True, '""""""\nReturns an empty string. This function is intended to serve as a placeholder or a starting point for further development.\n\nArgs:\n\n    None\n\nReturns:\n\n    str: An empty string.\n""""""'
False, '""""""\nInitialize the object with an optional initial value.\n\nArgs:\n    initial (Mapping[str. Any] | Iterable[tuple[str. Any]] | None): The initial value for the object.\n        If provided. it must be a mapping or iterable of tuples containing string keys and any values.\n        If not provided. the object will be initialized with default values.\n\nReturns:\n    None\n""""""\ndef __init__(\n    self.\n    initial: c.Mapping[str. t.Any] | c.Iterable[tuple[str. t.Any]] | None = None.\n) -> None:\n    def on_update(self: te.Self) -> None:\n        """"""Update the object\'s state after modification.""""""\n        self.modified = True\n        self.accessed = True\n\n    super().__init__(initial. on_update)'
False, '""""""\nReturns the root path of the given imported module.\n\nIf the module has already been imported and its file attribute is available.\nits directory path is returned. Otherwise. it attempts to find the loader\nassociated with the import specification and uses it to determine the root\npath. If this fails. it falls back to using the current working directory.\n\nArgs:\n    import_name (str): The name of the module for which to retrieve the root path.\n\nReturns:\n    str: The root path of the given imported module.\n\nRaises:\n    ValueError: If the loader is not found or if the module specification is None.\n    RuntimeError: If no root path can be found for a namespace package.'
True, '""""""\nReturns the version of Flask.\n\nThis function is deprecated and will be removed in Flask 3.2.\nInstead. use feature detection or \'importlib.metadata.version(""flask"")\'.\n\nArgs:\n    name (str): The attribute being accessed.\n\nReturns:\n    t.Any: The version of Flask as a string.\n\nRaises:\n    AttributeError: If the attribute does not exist.\n""""""'
True, '""""""\nInvokes the parent class\'s invoke method with optional CLI and arguments.\n\nThis function is used to extend the functionality of the parent class by providing\nadditional parameters such as `cli` and `args`. If `cli` is not provided. it defaults\nto the application\'s CLI. The `obj` parameter is also optional and defaults to a\nScriptInfo object with a create_app lambda that returns the current application.\n\nArgs:\n    cli (t.Any): The command-line interface. Defaults to None.\n    args (t.Any): Additional arguments. Defaults to None.\n    **kwargs: Keyword arguments. including \'obj\' which defaults to ScriptInfo(create_app=lambda: self.app).\n\nReturns:\n    Result: The result of the parent class\'s invoke method.\n\nRaises:\n    t.Any: Any exception raised by the parent class\'s invoke method.\n""""""'
True, '""""""\nReturns the version of Flask.\n\nThis function is deprecated and will be removed in Flask 3.2.\nInstead. use feature detection or \'importlib.metadata.version(""flask"")\'.\n\nArgs:\n    name (str): The attribute being accessed.\n\nReturns:\n    t.Any: The version of Flask as a string.\n\nRaises:\n    AttributeError: If the attribute does not exist.\n""""""'